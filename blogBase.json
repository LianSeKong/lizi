{"singlePage": ["about"], "startSite": "", "filingNum": "", "onePageListNum": 15, "commentLabelColor": "#006b75", "yearColorList": ["#bc4c00", "#0969da", "#1f883d", "#A333D0"], "i18n": "CN", "themeMode": "manual", "dayTheme": "light", "nightTheme": "dark", "urlMode": "pinyin", "script": "", "style": "", "head": "", "indexScript": "", "indexStyle": "", "bottomText": "\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904", "showPostSource": 1, "iconList": {}, "UTC": 8, "rssSplit": "sentence", "exlink": {}, "needComment": 1, "allHead": "", "title": "Lizi", "subTitle": "\u5373\u662f\u4ee3\u7801\u4e5f\u662f\u751f\u6d3b\uff01", "avatarUrl": "https://img.icons8.com/doodle/480/mugman.png", "GMEEK_VERSION": "last", "postListJson": {"P1": {"htmlDir": "docs/post/Shell Lab.html", "labels": ["csapp", "cmu15-213", "lab"], "postTitle": "Shell Lab", "postUrl": "post/Shell%20Lab.html", "postSourceUrl": "https://github.com/LianSeKong/lizi/issues/1", "commentNum": 0, "wordCount": 11, "description": "# Shell Lab\u3002", "top": 0, "createdAt": 1721200658, "style": "", "script": "", "head": "", "ogImage": "https://img.icons8.com/doodle/480/mugman.png", "createdDate": "2024-07-17", "dateLabelColor": "#bc4c00"}, "P2": {"htmlDir": "docs/post/cs61a-su24-hw01.html", "labels": ["cs61a", "hw"], "postTitle": "cs61a-su24-hw01", "postUrl": "post/cs61a-su24-hw01.html", "postSourceUrl": "https://github.com/LianSeKong/lizi/issues/2", "commentNum": 0, "wordCount": 9590, "description": "---\r\nurl: https://cs61a.org/hw/hw01/\r\ntitle: Homework 1 \r\ndate: 2024-07-17 16:08:34\r\ntag: \r\nbanner: 'https://images.unsplash.com/photo-1719749937847-ab76d3e0dbb7?crop=entropy&cs=srgb&fm=jpg&ixid=M3w0Njc1ODd8MHwxfHJhbmRvbXx8fHx8fHwxfHwxNzIxMjAzNjE1fA&ixlib=rb-4.0.3&q=85&fit=crop&w=624&max-h=540'\r\nbanner_icon: \ud83d\udd16\r\n---\r\nsr-annote { all: unset; }\r\n\r\n_Due by 11:59pm on Wednesday, June 26  \r\n\u622a\u6b62\u65e5\u671f\u4e3a 6 \u6708 26 \u65e5\u661f\u671f\u4e09\u665a\u4e0a 11\uff1a59_\r\n\r\n## Instructions \u6307\u793a\r\n\r\nDownload [hw01.zip](https://cs61a.org/hw/hw01/hw01.zip). \u4e0b\u8f7dhw01.zip\u3002", "top": 0, "createdAt": 1721205134, "style": "", "script": "", "head": "", "ogImage": "https://img.icons8.com/doodle/480/mugman.png", "createdDate": "2024-07-17", "dateLabelColor": "#bc4c00"}, "P3": {"htmlDir": "docs/post/cs61a-su24-hw02.html", "labels": ["cs61a", "hw"], "postTitle": "cs61a-su24-hw02", "postUrl": "post/cs61a-su24-hw02.html", "postSourceUrl": "https://github.com/LianSeKong/lizi/issues/3", "commentNum": 0, "wordCount": 14725, "description": "## Instructions\r\n\r\nDownload [hw02.zip](https://cs61a.org/hw/hw02/hw02.zip). Inside the archive, you will find a file called [hw02.py](https://cs61a.org/hw/hw02/hw02.py), along with a copy of the `ok` autograder.\r\n\r\n**Submission:** When you are done, submit the assignment by uploading all code files you've edited to Gradescope. You may submit more than once before the deadline; only the final submission will be scored. Check that you have successfully submitted your code on Gradescope. See [Lab 0](https://cs61a.org/lab/lab00#task-c-submitting-the-assignment) for more instructions on submitting assignments.\r\n\r\n**Using Ok:** If you have any questions about using Ok, please refer to [this guide.](https://cs61a.org/articles/using-ok)\r\n\r\n**Readings:** You might find the following references useful:\r\n\r\n*   [Section 1.6](https://www.composingprograms.com/pages/16-higher-order-functions.html)\r\n*   [Section 1.7](https://www.composingprograms.com/pages/17-recursive-functions.html)\r\n\r\n**Grading:** Homework is graded based on correctness. Each incorrect problem will decrease the total score by one point. **This homework is out of 2 points.**\r\n\r\nSeveral doctests refer to these functions:\r\n\r\n```\r\nfrom operator import add, mul\r\n\r\nsquare = lambda x: x * x\r\n\r\nidentity = lambda x: x\r\n\r\ntriple = lambda x: 3 * x\r\n\r\nincrement = lambda x: x + 1\r\n\r\n```\r\n\r\n## Higher-Order Functions\r\n\r\n### Q1: Product\r\n\r\nWrite a function called `product` that returns the product of the first `n` terms of a sequence. Specifically, `product` takes in an integer `n` and `term`, a single-argument function that determines a sequence. (That is, `term(i)` gives the `i`th term of the sequence.) `product(n, term)` should return `term(1) * ... * term(n)`.\r\n\r\n```\r\ndef product(n, term):\r\n    '''Return the product of the first n terms in a sequence.\r\n\r\n    n: a positive integer\r\n    term:  a function that takes one argument to produce the term\r\n\r\n    >>> product(3, identity)  # 1 * 2 * 3\r\n    6\r\n    >>> product(5, identity)  # 1 * 2 * 3 * 4 * 5\r\n    120\r\n    >>> product(3, square)    # 1^2 * 2^2 * 3^2\r\n    36\r\n    >>> product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\r\n    14400\r\n    >>> product(3, increment) # (1+1) * (2+1) * (3+1)\r\n    24\r\n    >>> product(3, triple)    # 1*3 * 2*3 * 3*3\r\n    162\r\n    '''\r\n    '*** YOUR CODE HERE ***'\r\n\r\n\r\n```\r\n\r\nUse Ok to test your code:\r\n\r\n```\r\npython3 ok -q product\r\n\r\n```\r\n\r\n:bear: <u>\u6bd4\u8f83\u7b80\u5355\uff0c\u5c31\u4e0d\u89e3\u91ca\u4e86</u>\r\n\r\n```python\r\ndef product(n, term):\r\n    i, count = 1, 1\r\n    while i <= n:\r\n        count, i = mul(count, term(i)), add(i, 1)\r\n    return count\r\n```\r\n\r\n### Q2: Accumulate\r\n\r\nLet's take a look at how `product` is an instance of a more general function called `accumulate`, which we would like to implement:\r\n\r\n```\r\ndef accumulate(fuse, start, n, term):\r\n    '''Return the result of fusing together the first n terms in a sequence \r\n    and start.  The terms to be fused are term(1), term(2), ..., term(n). \r\n    The function fuse is a two-argument commutative & associative function.\r\n\r\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\r\n    15\r\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\r\n    26\r\n    >>> accumulate(add, 11, 0, identity) # 11 (fuse is never used)\r\n    11\r\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\r\n    25\r\n    >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2\r\n    72\r\n    >>> # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1)\r\n    >>> accumulate(lambda x, y: x + y + 1, 2, 3, square)\r\n    19\r\n    '''\r\n    '*** YOUR CODE HERE ***'\r\n\r\n\r\n```\r\n\r\n`accumulate` has the following parameters:\r\n\r\n*   `fuse`: a two-argument function that specifies how the current term is fused with the previously accumulated terms\r\n*   `start`: value at which to start the accumulation\r\n*   `n`: a non-negative integer indicating the number of terms to fuse\r\n*   `term`: a single-argument function; `term(i)` is the `i`th term of the sequence\r\n\r\nImplement `accumulate`, which fuses the first `n` terms of the sequence defined by `term` with the `start` value using the `fuse` function.\r\n\r\nFor example, the result of `accumulate(add, 11, 3, square)` is\r\n\r\n```\r\nadd(11,  add(square(1), add(square(2),  square(3)))) =\r\n    11 +     square(1) +    square(2) + square(3)    =\r\n    11 +     1         +    4         + 9            = 25\r\n\r\n```\r\n\r\nAssume that `fuse` is commutative, `fuse(a, b) == fuse(b, a)`, and associative, `fuse(fuse(a, b), c) == fuse(a, fuse(b, c))`.\r\n\r\nThen, implement `summation` (from lecture) and `product` as one-line calls to `accumulate`.\r\n\r\n**Important:** Both `summation_using_accumulate` and `product_using_accumulate` should be implemented with a single line of code starting with `return`.\r\n\r\n```\r\ndef summation_using_accumulate(n, term):\r\n    '''Returns the sum: term(1) + ... + term(n), using accumulate.\r\n\r\n    >>> summation_using_accumulate(5, square) # square(0) + square(1) + ... + square(4) + square(5)\r\n    55\r\n    >>> summation_using_accumulate(5, triple) # triple(0) + triple(1) + ... + triple(4) + triple(5)\r\n    45\r\n    >>> # This test checks that the body of the function is just a return statement.\r\n    >>> import inspect, ast\r\n    >>> [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body]\r\n    ['Expr', 'Return']\r\n    '''\r\n    return ____\r\n\r\ndef product_using_accumulate(n, term):\r\n    '''Returns the product: term(1) * ... * term(n), using accumulate.\r\n\r\n    >>> product_using_accumulate(4, square) # square(1) * square(2) * square(3) * square()\r\n    576\r\n    >>> product_using_accumulate(6, triple) # triple(1) * triple(2) * ... * triple(5) * triple(6)\r\n    524880\r\n    >>> # This test checks that the body of the function is just a return statement.\r\n    >>> import inspect, ast\r\n    >>> [type(x).__name__ for x in ast.parse(inspect.getsource(product_using_accumulate)).body[0].body]\r\n    ['Expr', 'Return']\r\n    '''\r\n    return ____\r\n\r\n\r\n```\r\n\r\nUse Ok to test your code:\r\n\r\n```\r\npython3 ok -q accumulate\r\npython3 ok -q summation_using_accumulate\r\npython3 ok -q product_using_accumulate\r\n\r\n```\r\n\r\n:bear: `accumulate\uff1a \u5bf9product\u7684\u6bcf\u6b21\u76f8\u4e58\u884c\u4e3a\u66ff\u6362\u4e3a\u62bd\u8c61\u7684\u51fd\u6570`\r\n\r\n```python\r\ndef accumulate(fuse, start, n, term):\r\n    i, count = 1, start\r\n    while i <= n:\r\n        start, i = merger(fuse, term(i)), add(i + 1)\r\n    return count\r\n```\r\n\r\n:bear: `summation_using_accumulate: product\u7684\u53d8\u4f53`\r\n\r\n```python\r\ndef summation_using_accumulate(n, term):\r\n    return accumulate(add, term(0), n, term)\r\n```\r\n\r\n:bear: `sproduct_using_accumulate: product\u7684\u53d8\u4f53`\r\n\r\n```python\r\ndef product_using_accumulate(n, term):\r\n \treturn accumulate(mul, 1, n, term)\r\n```\r\n\r\n\r\n\r\n### Q3: Make Repeater\r\n\r\nImplement the function `make_repeater` which takes a one-argument function `f` and a positive integer `n`. It returns a one-argument function, where `make_repeater(f, n)(x)` returns the value of `f(f(...f(x)...))` in which `f` is applied `n` times to `x`. For example, `make_repeater(square, 3)(5)` squares 5 three times and returns 390625, just like `square(square(square(5)))`.\r\n\r\n```\r\ndef make_repeater(f, n):\r\n    '''Returns the function that computes the nth application of f.\r\n\r\n    >>> add_three = make_repeater(increment, 3)\r\n    >>> add_three(5)\r\n    8\r\n    >>> make_repeater(triple, 5)(1) # 3 * (3 * (3 * (3 * (3 * 1))))\r\n    243\r\n    >>> make_repeater(square, 2)(5) # square(square(5))\r\n    625\r\n    >>> make_repeater(square, 3)(5) # square(square(square(5)))\r\n    390625\r\n    '''\r\n    '*** YOUR CODE HERE ***'\r\n\r\n\r\n```\r\n\r\nUse Ok to test your code:\r\n\r\n```\r\npython3 ok -q make_repeater\r\n\r\n```\r\n\r\n:bear:  \r\n\r\n```python\r\ndef make_repeater(f, n):\r\n    def helper(x):\r\n        i = n;\r\n        while i:\r\n            x = f(x)\r\n            i = i - 1;\r\n        return x\r\n    return helper\r\n```\r\n\r\n\r\n\r\n## Recursion\r\n\r\n### Q4: Digit Distance\r\n\r\nFor a given integer, the _digit distance_ is the sum of the absolute differences between consecutive digits. For example:\r\n\r\n*   The digit distance of `6` is `0`.\r\n*   The digit distance of `61` is `5`, as the absolute value of `6 - 1` is `5`.\r\n*   The digit distance of `71253` is `12` (`6 + 1 + 3 + 2`).\r\n\r\nWrite a function that determines the digit distance of a given positive integer. You must use recursion or the tests will fail.\r\n\r\n**Hint:** There are multiple valid ways of solving this problem! If you're stuck, try writing out an iterative solution first, and then convert your iterative solution into a recursive one.\r\n\r\n```\r\ndef digit_distance(n):\r\n    '''Determines the digit distance of n.\r\n\r\n    >>> digit_distance(3)\r\n    0\r\n    >>> digit_distance(777)\r\n    0\r\n    >>> digit_distance(314)\r\n    5\r\n    >>> digit_distance(31415926535)\r\n    32\r\n    >>> digit_distance(3464660003)\r\n    16\r\n    >>> from construct_check import check\r\n    >>> # ban all loops\r\n    >>> check(HW_SOURCE_FILE, 'digit_distance',\r\n    ...       ['For', 'While'])\r\n    True\r\n    '''\r\n    '*** YOUR CODE HERE ***'\r\n\r\n\r\n```\r\n\r\nUse Ok to test your code:\r\n\r\n```\r\npython3 ok -q digit_distance\r\n\r\n```\r\n\r\n:bear:\r\n\r\n```python\r\ndef digit_distance(n):\r\n    if n < 10:\r\n        return 0\r\n    else:\r\n        return abs(sub(n % 10, n // 10 % 10)) + digit_distance(n // 10)\r\n```\r\n\r\n\r\n\r\n### Q5: Interleaved Sum\r\n\r\nWrite a function `interleaved_sum`, which takes in a number `n` and two one-argument functions: `odd_func` and `even_func`. It applies `odd_func` to every odd number and `even_func` to every even number from 1 to `n` _inclusive_ and returns the sum.\r\n\r\nFor example, executing `interleaved_sum(5, lambda x: x, lambda x: x * x)` returns `1 + 2*2 + 3 + 4*4 + 5 = 29`.\r\n\r\n**Important:** Implement this function without using any loops or directly testing if a number is odd or even -- aka modulos (`%`) are not allowed! Instead of directly checking whether a number is even or odd, start with 1, which you know is an odd number.\r\n\r\n**Hint:** Introduce an inner helper function that takes an odd number `k` and computes an interleaved sum from `k` to `n` (including `n`).\r\n\r\n```\r\ndef interleaved_sum(n, odd_func, even_func):\r\n    '''Compute the sum odd_func(1) + even_func(2) + odd_func(3) + ..., up\r\n    to n.\r\n\r\n    >>> identity = lambda x: x\r\n    >>> square = lambda x: x * x\r\n    >>> triple = lambda x: x * 3\r\n    >>> interleaved_sum(5, identity, square) # 1   + 2*2 + 3   + 4*4 + 5\r\n    29\r\n    >>> interleaved_sum(5, square, identity) # 1*1 + 2   + 3*3 + 4   + 5*5\r\n    41\r\n    >>> interleaved_sum(4, triple, square)   # 1*3 + 2*2 + 3*3 + 4*4\r\n    32\r\n    >>> interleaved_sum(4, square, triple)   # 1*1 + 2*3 + 3*3 + 4*3\r\n    28\r\n    >>> from construct_check import check\r\n    >>> check(HW_SOURCE_FILE, 'interleaved_sum', ['While', 'For', 'Mod']) # ban loops and %\r\n    True\r\n    >>> check(HW_SOURCE_FILE, 'interleaved_sum', ['BitAnd', 'BitOr', 'BitXor']) # ban bitwise operators, don't worry about these if you don't know what they are\r\n    True\r\n    '''\r\n    '*** YOUR CODE HERE ***'\r\n\r\n\r\n```\r\n\r\nUse Ok to test your code:\r\n\r\n```\r\npython3 ok -q interleaved_sum\r\n\r\n```\r\n\r\n:bear:`interleaved_sum`\r\n\r\n```python\r\ndef interleaved_sum(n, odd_func, even_func):\r\n    if n == 0:\r\n        return 0\r\n    elif n % 2 == 1:\r\n        return odd_func(n) + interleaved_sum(n - 1, odd_func, even_func)\r\n    else:\r\n        return even_func(n) + interleaved_sum(n - 1, odd_func, even_func)\r\n\r\n```\r\n\r\n\r\n\r\n### Q6: Count Coins\r\n\r\nGiven a positive integer `total`, a set of coins makes change for `total` if the sum of the values of the coins is `total`. Here we will use standard US Coin values: 1, 5, 10, 25. For example, the following sets make change for `15`:\r\n\r\n*   15 1-cent coins\r\n*   10 1-cent, 1 5-cent coins\r\n*   5 1-cent, 2 5-cent coins\r\n*   5 1-cent, 1 10-cent coins\r\n*   3 5-cent coins\r\n*   1 5-cent, 1 10-cent coin\r\n\r\nThus, there are 6 ways to make change for `15`. Write a **recursive** function `count_coins` that takes a positive integer `total` and returns the number of ways to make change for `total` using coins.\r\n\r\nYou can use _either_ of the functions given to you:\r\n\r\n*   `next_larger_coin` will return the next larger coin denomination from the input, i.e. `next_larger_coin(5)` is `10`.\r\n*   `next_smaller_coin` will return the next smaller coin denomination from the input, i.e. `next_smaller_coin(5)` is `1`.\r\n*   Either function will return `None` if the next coin value does not exist\r\n\r\nThere are two main ways in which you can approach this problem. One way uses `next_larger_coin`, and another uses `next_smaller_coin`. It is up to you which one you want to use!\r\n\r\n**Important:** Use recursion; the tests will fail if you use loops.\r\n\r\n**Hint:** Refer to the [implementation](https://www.composingprograms.com/pages/17-recursive-functions.html#example-partitions) of `count_partitions` for an example of how to count the ways to sum up to a final value with smaller parts. If you need to keep track of more than one value across recursive calls, consider writing a helper function.\r\n\r\n```\r\ndef next_larger_coin(coin):\r\n    '''Returns the next larger coin in order.\r\n    >>> next_larger_coin(1)\r\n    5\r\n    >>> next_larger_coin(5)\r\n    10\r\n    >>> next_larger_coin(10)\r\n    25\r\n    >>> next_larger_coin(2) # Other values return None\r\n    '''\r\n    if coin == 1:\r\n        return 5\r\n    elif coin == 5:\r\n        return 10\r\n    elif coin == 10:\r\n        return 25\r\n\r\ndef next_smaller_coin(coin):\r\n    '''Returns the next smaller coin in order.\r\n    >>> next_smaller_coin(25)\r\n    10\r\n    >>> next_smaller_coin(10)\r\n    5\r\n    >>> next_smaller_coin(5)\r\n    1\r\n    >>> next_smaller_coin(2) # Other values return None\r\n    '''\r\n    if coin == 25:\r\n        return 10\r\n    elif coin == 10:\r\n        return 5\r\n    elif coin == 5:\r\n        return 1\r\n\r\ndef count_coins(total):\r\n    '''Return the number of ways to make change using coins of value of 1, 5, 10, 25.\r\n    >>> count_coins(15)\r\n    6\r\n    >>> count_coins(10)\r\n    4\r\n    >>> count_coins(20)\r\n    9\r\n    >>> count_coins(100) # How many ways to make change for a dollar?\r\n    242\r\n    >>> count_coins(200)\r\n    1463\r\n    >>> from construct_check import check\r\n    >>> # ban iteration\r\n    >>> check(HW_SOURCE_FILE, 'count_coins', ['While', 'For'])\r\n    True\r\n    '''\r\n    '*** YOUR CODE HERE ***'\r\n\r\n\r\n```\r\n\r\n```\r\npython3 ok -q count_coins\r\n```\r\n\r\n:bear:\r\n\r\n```python\r\n# \u8fb9\u754c\u60c5\u51b5\uff1a \u786c\u5e01\u4e3a0\uff0c\u65b9\u6848\u6b63\u786e\u3002", "top": 0, "createdAt": 1721216324, "style": "", "script": "", "head": "", "ogImage": "https://img.icons8.com/doodle/480/mugman.png", "createdDate": "2024-07-17", "dateLabelColor": "#bc4c00"}, "P4": {"htmlDir": "docs/post/cmu15213-fa15-lec25.html", "labels": ["csapp", "cmu15-213", "lecture"], "postTitle": "cmu15213-fa15-lec25", "postUrl": "post/cmu15213-fa15-lec25.html", "postSourceUrl": "https://github.com/LianSeKong/lizi/issues/4", "commentNum": 0, "wordCount": 7895, "description": "\r\n# \u9ad8\u7ea7\r\n\r\n\r\n> \u4f7f\u7528\u4fe1\u53f7\u91cf\u534f\u8c03\u5bf9\u5171\u4eab\u8d44\u6e90\u7684\u8bbf\u95ee\r\n> \u4f7f\u7528\u540c\u6b65\u53ef\u80fd\u4f1a\u8ba9\u4ee3\u7801\u6267\u884c\u53d8\u6162\r\n\r\n\u57fa\u672c\u601d\u60f3\uff1a\u7ebf\u7a0b\u4f7f\u7528\u4fe1\u53f7\u91cf\u64cd\u4f5c\u6765\u901a\u77e5\u53e6\u4e00\u4e2a\u7ebf\u7a0b\u67d0\u4e2a\u6761\u4ef6\u5df2\u53d8\u4e3a\u771f\r\n1. \u4f7f\u7528\u8ba1\u6570\u4fe1\u53f7\u91cf\u6765\u8ddf\u8e2a\u8d44\u6e90\u72b6\u6001\u5e76\u901a\u77e5\u5176\u4ed6\u7ebf\u7a0b\r\n2. \u4f7f\u7528\u4e92\u65a5\u9501\u6765\u4fdd\u62a4\u5bf9\u8d44\u6e90\u7684\u8bbf\u95ee\r\n\r\n\u4e24\u79cd\u5178\u578b\u4f8b\u5b50\uff1a \r\n1. \u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u95ee\u9898\r\n2. \u8bfb\u8005-\u5199\u8005\u95ee\u9898\r\n\r\n### \u751f\u4ea7\u8005-\u6d88\u8d39\u8005\r\n\r\n\u5e38\u89c1\u7684\u540c\u6b65\u6a21\u5f0f\uff1a\r\n1. \u751f\u4ea7\u8005\u7b49\u5f85\u7a7a\u4f4d\uff0c\u5c06\u9879\u76ee\u63d2\u5165\u7f13\u51b2\u533a\uff0c\u5e76\u901a\u77e5\u6d88\u8d39\u8005\u3002", "top": 0, "createdAt": 1721272770, "style": "", "script": "", "head": "", "ogImage": "https://img.icons8.com/doodle/480/mugman.png", "createdDate": "2024-07-18", "dateLabelColor": "#bc4c00"}, "P5": {"htmlDir": "docs/post/cmu15213-fa15-hw12.html", "labels": ["csapp", "cmu15-213", "hw"], "postTitle": "cmu15213-fa15-hw12", "postUrl": "post/cmu15213-fa15-hw12.html", "postSourceUrl": "https://github.com/LianSeKong/lizi/issues/5", "commentNum": 0, "wordCount": 2714, "description": "# HW12\r\n\r\n## 12.16\r\n\r\n```c\r\nvoid* thread(void * vargp) {\r\n    printf('12.16 homework threadId:  %ld!\\n', pthread_self());\r\n    return NULL;\r\n}\r\n\r\nint main(int argc, char **argv) {\r\n    if (argc != 2) {\r\n        fprintf(stderr, 'usage: %s <n>\\n', argv[0]);\r\n        exit(0);\r\n    }\r\n    int n = atoi(argv[1]);\r\n    pthread_t tid[n];\r\n    for (size_t i = 0; i < n; i++) {\r\n        pthread_create(&tid[i], NULL, thread, NULL);\r\n    }\r\n    for (size_t i = 0; i < n; i++) {\r\n        pthread_join(tid[i], NULL); // \u7b49\u5f85\u7ebf\u7a0b\u7ed3\u675f\r\n    }\r\n    exit(0);\r\n}\r\n```\r\n\r\n## 12.17\r\n\r\n```c\r\n\r\nvoid* thread(void * vargp) {\r\n    sleep(1);\r\n    printf('Hello, world!\\n');\r\n    return NULL;\r\n}\r\n\r\nint main(int argc, char **argv) {\r\n    pthread_t tid;\r\n    pthread_create(&tid, NULL, thread, NULL);\r\n    pthread_join(tid, NULL);\r\n    exit(0);\r\n}\r\n\r\n```\r\n\r\n## 12.35\r\n\r\n\r\n\r\n```c\r\nstatic int cnt = 0;\r\n\r\nvoid signchld_handler(int sig) {\r\n    // WNOHANG: \u5982\u679c\u7b49\u5f85\u96c6\u4e2d\u7684\u5b50\u8fdb\u7a0b\u5747\u672a\u7ec8\u6b62\uff0c\u5219\u7acb\u5373\u8fd4\u56de\uff08\u8fd4\u56de\u503c\u4e3a 0\uff09\u3002", "top": 0, "createdAt": 1721383737, "style": "", "script": "", "head": "", "ogImage": "https://img.icons8.com/doodle/480/mugman.png", "createdDate": "2024-07-19", "dateLabelColor": "#bc4c00"}, "P6": {"htmlDir": "docs/post/ubuntu-shang-an-zhuang-mysql.html", "labels": ["database", "mysql"], "postTitle": "ubuntu\u4e0a\u5b89\u88c5mysql", "postUrl": "post/ubuntu-shang-an-zhuang-mysql.html", "postSourceUrl": "https://github.com/LianSeKong/lizi/issues/6", "commentNum": 0, "wordCount": 740, "description": "# Ubuntu Install Mysql\r\n\r\n1. \u66f4\u65b0\u8f6f\u4ef6\u5305\r\n\r\n   ```shell\r\n   sudo apt install update\r\n   ```\r\n\r\n2. \u5b89\u88c5mysql\u670d\u52a1\u5668\r\n\r\n   ```shell\r\n   sudo apt install mysql-server\r\n   ```\r\n\r\n3. \u542f\u52a8\u670d\u52a1\r\n\r\n   ```shell\r\n   sudo systemctl start mysql\r\n   ```\r\n\r\n4. \u5f00\u673a\u81ea\u542f\u52a8\r\n\r\n   ```shell\r\n   sudo systemctl enable mysql\r\n   ```\r\n\r\n5. \u4fee\u6539\u5bc6\u7801\r\n\r\n   ```shell\r\n   # \u767b\u5f55, \u56e0\u4e3a\u6ca1\u6709\u8bbe\u7f6e\u5bc6\u7801\uff0c\u7ba1\u7406\u5458\u4e0b\u76f4\u63a5\u4ee5root\u7528\u6237\u767b\u5f55\r\n   sudo mysql\r\n   \r\n   ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password';\r\n   flush privileges;\r\n   # \r\n   \r\n   ```\r\n\r\n6. \u521b\u5efa\u65b0\u7528\u6237\r\n\r\n   ```sql\r\n    // % \u4ee3\u8868\u6240\u6709\u5730\u5740\u90fd\u53ef\u901a\u8fc7\u6b64\u7528\u6237\u767b\u5f55\r\n   CREATE USER 'lpf'@'%' IDENTIFIED BY '123';\r\n   \r\n   ```\r\n7. \u591f\u4fa6\u542c\u8fdc\u7a0b\u53ef\u8bbf\u95ee\u7684\u63a5\u53e3 \r\n\r\n\t``` shell\r\n\tsudo nvim /etc/mysql/mysql.conf.d/mysqld.cnf\r\n\t\r\n\t```\r\n\t`bind-address = 0.0.0.0`\r\n\r\n\t\r\n   \r\n\r\n\u3002", "top": 0, "createdAt": 1721460513, "style": "", "script": "", "head": "", "ogImage": "https://img.icons8.com/doodle/480/mugman.png", "createdDate": "2024-07-20", "dateLabelColor": "#bc4c00"}, "P7": {"htmlDir": "docs/post/Proxy Lab.html", "labels": ["csapp", "cmu15-213", "lab"], "postTitle": "Proxy Lab", "postUrl": "post/Proxy%20Lab.html", "postSourceUrl": "https://github.com/LianSeKong/lizi/issues/7", "commentNum": 0, "wordCount": 10625, "description": "# Proxy Lab\r\n\r\n\r\n>  \u672c\u5b9e\u9a8c\u662fCSAPP\u7684\u6700\u540e\u4e00\u4e2a\u5b9e\u9a8c\uff0c\u5927\u90e8\u5206\u5185\u5bb9\u90fd\u53ef\u53c2\u8003\u4e66\u5185\u6837\u4f8b\r\n>  \u5b9e\u9a8c\u4e3b\u8981\u6d89\u53ca\u4e86IO\u3001\u591a\u7ebf\u7a0b\u3001\u7f51\u7edc\u7f16\u7a0b\u548c\u5e76\u884c\u7b49\u65b9\u9762\u5185\u5bb9\r\n>  Web\u4ee3\u7406\u662f\u4e00\u4e2a\u5728Web\u6d4f\u89c8\u5668\u548c\u7ec8\u7aef\u670d\u52a1\u5668\u4e4b\u95f4\u5145\u5f53\u4e2d\u95f4\u4eba\u7684\u7a0b\u5e8f\u3002", "top": 0, "createdAt": 1721890955, "style": "", "script": "", "head": "", "ogImage": "https://img.icons8.com/doodle/480/mugman.png", "createdDate": "2024-07-25", "dateLabelColor": "#bc4c00"}, "P8": {"htmlDir": "docs/post/Malloc lab.html", "labels": ["csapp", "cmu15-213", "lab"], "postTitle": "Malloc lab", "postUrl": "post/Malloc%20lab.html", "postSourceUrl": "https://github.com/LianSeKong/lizi/issues/8", "commentNum": 0, "wordCount": 17166, "description": "# Malloc lab \r\n\r\n## \u9690\u5f0f\u5217\u8868  78 / 100 points\r\n\r\n\r\n``` c \r\n/*\r\n * mm-naive.c - The fastest, least memory-efficient malloc package.\r\n\r\n */\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <assert.h>\r\n#include <unistd.h>\r\n#include <string.h>\r\n\r\n#include 'mm.h'\r\n#include 'memlib.h'\r\n\r\nteam_t team = {\r\n    /* Team name */\r\n    'Cranberry', // \u8513\u8d8a\u8393\r\n    /* First member's full name */\r\n    'Lizi',\r\n    /* First member's email address */\r\n    'liansekong@gmail.com',\r\n    /* Second member's full name (leave blank if none) */\r\n    '',\r\n    /* Second member's email address (leave blank if none) */\r\n    ''};\r\n\r\n/* single word (4) or double word (8) alignment */\r\n#define ALIGNMENT 8\r\n\r\n/* rounds up to the nearest multiple of ALIGNMENT */\r\n#define ALIGN(size) (((size) + (ALIGNMENT - 1)) & ~0x7)\r\n\r\n#define SIZE_T_SIZE (ALIGN(sizeof(size_t)))\r\n\r\n#define WSIZE 4\r\n#define DSIZE 8\r\n\r\n// bytes\r\n#define CHUNKSIZE (1 << 12) // 4096 bytes ->  4kb page size\r\n\r\n#define MAX(x, y) ((x) > (y) ? (x) : (y))\r\n\r\n// Pack a size and allocated bit into a word\r\n#define PACK(size, alloc) ((size) | (alloc))\r\n\r\n// Read and write a word at address p\r\n#define GET(p) (*(unsigned int *)(p))\r\n#define PUT(p, val) (*(unsigned int *)(p) = (val))\r\n\r\n// Read the size and allocated fields from address p\r\n// Size \u4e3a\u6574\u4e2a\u5757\u5927\u5c0f\r\n#define GET_SIZE(p) (GET(p) & ~0x7)\r\n#define GET_ALLOC(p) (GET(p) & 0x1)\r\n\r\n// bp\u6307\u5411\u7b2c\u4e00\u4e2a\u6709\u6548\u8f7d\u8377\u5b57\u8282\r\n#define HDRP(bp) ((char *)(bp) - WSIZE)\r\n#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)\r\n\r\n#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))\r\n#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))\r\n\r\nstatic void *extend_heap(size_t words);\r\nstatic void *coalesce(void *bp);\r\nstatic void *find_fit(size_t asize);\r\nstatic void place(void *bp, size_t size);\r\n\r\nvoid *mm_malloc(size_t size);\r\n\r\nchar *heap_listp;\r\n\r\n/*\r\n * mm_init - initialize the malloc package.\r\n */\r\nint mm_init(void)\r\n{\r\n\r\n    if ((heap_listp = mem_sbrk(4 * WSIZE)) == (void *)-1)\r\n    {\r\n        return -1;\r\n    }\r\n\r\n    PUT(heap_listp, 0);                            // \u8d77\u59cb\u4f4d\u7f6e\r\n    PUT(heap_listp + (1 * WSIZE), PACK(DSIZE, 1)); // \u5e8f\u8a00\u5757 8/1\r\n    PUT(heap_listp + (2 * WSIZE), PACK(DSIZE, 1)); // \u5e8f\u8a00\u5757 8/1\r\n    PUT(heap_listp + (3 * WSIZE), PACK(0, 1));     // \u7ed3\u5c3e\u5757 0/1\r\n\r\n    // \u6307\u5411\u7b2c\u4e8c\u4e2a\u5e8f\u8a00\u5757\r\n    heap_listp += (2 * WSIZE);\r\n\r\n    if (extend_heap(CHUNKSIZE) == NULL)\r\n        return -1;\r\n    // printf('init finsh!\\n');\r\n    return 0;\r\n}\r\n\r\n/**\r\n * \u9996\u6b21\u5339\u914d\r\n */\r\n\r\nstatic void *find_fit(size_t asize)\r\n{\r\n    char *start_bp = heap_listp + DSIZE;\r\n    while (GET_SIZE(HDRP(start_bp)) > 0)\r\n    {\r\n        if (GET_ALLOC(HDRP(start_bp)) == 0 && (GET_SIZE(HDRP(start_bp)) >= asize))\r\n        {\r\n            return start_bp;\r\n        }\r\n        start_bp = NEXT_BLKP(start_bp);\r\n    }\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * \u8bbe\u7f6e\u5206\u914d\u5757\r\n * 1. \u8bbe\u7f6e\u5206\u914d\u4f4d\u4e3a1\r\n * 2. \u5206\u5272\u7a7a\u95f2\u5757\r\n */\r\nstatic void place(void *bp, size_t size)\r\n{\r\n    size_t cur_bk_size = GET_SIZE(HDRP(bp));\r\n    if (cur_bk_size - size >= DSIZE * 2)\r\n    {\r\n        PUT(HDRP(bp), PACK(size, 1));\r\n        PUT(FTRP(bp), PACK(size, 1));\r\n        PUT(HDRP(NEXT_BLKP(bp)), PACK(cur_bk_size - size, 0));\r\n        PUT(FTRP(NEXT_BLKP(bp)), PACK(cur_bk_size - size, 0));\r\n    }\r\n    else\r\n    {\r\n        PUT(HDRP(bp), PACK(cur_bk_size, 1));\r\n        PUT(FTRP(bp), PACK(cur_bk_size, 1));\r\n    }\r\n}\r\n\r\n/*\r\n * mm_malloc - Allocate a block by incrementing the brk pointer.\r\n *     Always allocate a block whose size is a multiple of the alignment.\r\n */\r\nvoid *mm_malloc(size_t size)\r\n{\r\n    if (size == 0)\r\n    {\r\n        return NULL;\r\n    }\r\n    // payload + padding + hdr + ftr\r\n    // Double word algin\r\n    size_t asize = ALIGN(size) + DSIZE;\r\n    size_t extend_size;\r\n    char *bp;\r\n    // \u5bfb\u627e\u7a7a\u95f2\u5757\r\n    if ((bp = find_fit(asize)) != NULL)\r\n    {\r\n        place(bp, asize);\r\n        return bp;\r\n    }\r\n    // \u65e0\u7a7a\u95f2\u5217\u8868\uff0c\u5219\u5411\u7cfb\u7edf\u7533\u8bf7\u5206\u914d\u5185\u5b58\uff0c \u6700\u5c0f\u5355\u4f4d\u4e3a 4kb\r\n    extend_size = MAX(asize, CHUNKSIZE);\r\n    if ((bp = extend_heap(extend_size)) == NULL)\r\n        return NULL;\r\n    place(bp, asize);\r\n    return bp;\r\n}\r\n\r\n/*\r\n * mm_free - Freeing a block does nothing.\r\n */\r\nvoid mm_free(void *bp)\r\n{\r\n    // \u83b7\u53d6\u5f53\u524d\u5757\u7684\u5927\u5c0f\r\n    size_t size = GET_SIZE(HDRP(bp));\r\n    // \u8bbe\u7f6e\u5934\u5c3e\u4e3a\u672a\u5206\u914d\r\n    PUT(HDRP(bp), PACK(size, 0));\r\n    PUT(FTRP(bp), PACK(size, 0));\r\n    // \u5408\u5e76\r\n    coalesce(bp);\r\n}\r\n\r\n/*\r\n * mm_realloc - Implemented simply in terms of mm_malloc and mm_free\r\n */\r\n\r\nvoid *mm_realloc(void *ptr, size_t size)\r\n{\r\n    if (ptr == NULL)\r\n    {\r\n        return mm_malloc(size);\r\n    }\r\n    if (size == 0)\r\n    {\r\n        mm_free(ptr);\r\n        return NULL;\r\n    }\r\n\r\n    size_t asize = ALIGN(size) + DSIZE;\r\n    size_t cur_bk_size = GET_SIZE(HDRP(ptr));\r\n\r\n    if (cur_bk_size == asize)\r\n    {\r\n        return ptr;\r\n    }\r\n    else if (cur_bk_size < asize)\r\n    {\r\n        // expand\r\n        char *new_ptr = mm_malloc(size);\r\n        memcpy(new_ptr, ptr, cur_bk_size - DSIZE);\r\n        mm_free(ptr);\r\n        return new_ptr;\r\n    }\r\n    else\r\n    {\r\n        // shrink\r\n        if (cur_bk_size - asize <= 2 * DSIZE)\r\n        {\r\n            return ptr;\r\n        }\r\n        else\r\n        {\r\n            place(ptr, asize);\r\n            return ptr;\r\n        }\r\n    }\r\n}\r\n\r\n// 1. \u5806\u521d\u59cb\u5316\u65f6\u8c03\u7528\r\n// 2. mm_malloc\u4e0d\u80fd\u627e\u5230\u4e00\u4e2a\u5408\u9002\u7684\u5339\u914d\u5757\u65f6\r\nstatic void *extend_heap(size_t size)\r\n{\r\n    size_t asize = size % CHUNKSIZE == 0 ? size : ((size / CHUNKSIZE) + 1) * CHUNKSIZE;\r\n    char *bp;\r\n    if ((bp = mem_sbrk(asize)) == (void *)-1)\r\n    {\r\n        return NULL;\r\n    }\r\n    // \u5206\u914dblock\u65f6bp\u6307\u5411\u5757\u7684\u5934\u90e8\u8868\uff0c bp\u524d\u4e00\u4e2a\u5757\u4e3a\u4e4b\u524d\u7684\u7ed3\u5c3e\u5757\uff080/1\uff09\r\n    // \u6b64\u65f6\u5c06\u4e4b\u524d\u7684\u7ed3\u5c3e\u5757\u5f53\u4f5c\u5934\u90e8\uff0c\u73b0\u5728\u5206\u914d\u5757\u7684\u6700\u540e\u4e00\u4e2aword\u8bbe\u4e3a\u7ed3\u5c3e\u5757\r\n    PUT(HDRP(bp), PACK(asize, 0));\r\n    PUT(FTRP(bp), PACK(asize, 0));\r\n    PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1));\r\n    return coalesce(bp);\r\n}\r\n\r\nstatic void *coalesce(void *bp)\r\n{\r\n    size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));\r\n    size_t next_alloc = GET_ALLOC(FTRP(NEXT_BLKP(bp)));\r\n\r\n    size_t size = GET_SIZE(HDRP(bp));\r\n    if (prev_alloc && next_alloc)\r\n    {\r\n        return bp;\r\n    }\r\n    if (prev_alloc && !next_alloc)\r\n    {\r\n        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));\r\n        PUT(HDRP(bp), PACK(size, 0));\r\n        PUT(FTRP(bp), PACK(size, 0));\r\n    }\r\n    else if (!prev_alloc && next_alloc)\r\n    {\r\n        size += GET_SIZE(HDRP(PREV_BLKP(bp)));\r\n        PUT(FTRP(bp), PACK(size, 0));\r\n        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));\r\n        bp = PREV_BLKP(bp);\r\n    }\r\n    else\r\n    {\r\n        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(HDRP(NEXT_BLKP(bp)));\r\n        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));\r\n        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0));\r\n        bp = PREV_BLKP(bp);\r\n    }\r\n    return bp;\r\n}\r\n\r\n```\r\n\r\n## \u5206\u79bb\u5217\u8868\r\n\r\n``` c\r\n/*\r\n\r\n * mm-naive.c - The fastest, least memory-efficient malloc package.\r\n */\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <assert.h>\r\n#include <unistd.h>\r\n#include <string.h>\r\n#include 'mm.h'\r\n#include 'memlib.h'\r\n\r\nteam_t team = {\r\n    /* Team name */\r\n    'Cranberry', // \u8513\u8d8a\u8393\r\n    /* First member's full name */\r\n    'Lizi',\r\n    /* First member's email address */\r\n    'liansekong@gmail.com',\r\n    /* Second member's full name (leave blank if none) */\r\n    '',\r\n    /* Second member's email address (leave blank if none) */\r\n    ''\r\n};\r\n\r\n/* single word (4) or double word (8) alignment */\r\n#define ALIGNMENT 8\r\n/* rounds up to the nearest multiple of ALIGNMENT */\r\n#define ALIGN(size) (((size) + (ALIGNMENT - 1)) & ~0x7)\r\n\r\n#define WSIZE 4\r\n#define DSIZE 8\r\n#define MINI_BLOCK_SIZE 16\r\n\r\n// SEG_LIST\r\n\r\n#define SEG_LIST_LEN 15\r\n\r\n// 4096 bytes ->  4kb page size\r\n\r\n#define CHUNKSIZE (1 << 12)\r\n\r\n#define MAX(x, y) ((x) > (y) ? (x) : (y))\r\n\r\n// Pack a size and allocated bit into a word\r\n\r\n#define PACK(size, alloc) ((size) | (alloc))\r\n\r\n// Read and write a word at address p\r\n\r\n#define GET(p) (*(unsigned int *)(p))\r\n\r\n#define PUT(p, val) (*(unsigned int *)(p) = (val))\r\n\r\n// Read the size and allocated fields from address p\r\n\r\n#define GET_SIZE(p) (GET(p) & ~0x7)\r\n\r\n#define GET_ALLOC(p) (GET(p) & 0x1)\r\n\r\n// bp\u6307\u5411\u7b2c\u4e00\u4e2a\u6709\u6548\u8f7d\u8377\u5b57\u8282\r\n\r\n#define HDRP(bp) ((char *)(bp) - WSIZE)\r\n#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)\r\n#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))\r\n#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))\r\n#define PREV(bp) ((char *)(bp))\r\n#define SUCC(bp) ((char *)(bp) + WSIZE)\r\n\r\n// \u5206\u79bb\u7a7a\u95f2\u94fe\u8868\r\n\r\n// \u6839\u636e\u4e0b\u6807\u83b7\u53d6\u5206\u79bb\u7a7a\u95f2\u5217\u8868\u7684\u5143\u7d20\r\n#define ITEM_OF_FREE_LIST(listp, index) ((listp) + ((index) * (WSIZE) * 4))\r\n\r\n#define PREV_FREE_BLKP(bp) (GET(bp))\r\n#define SUCC_FREE_BLKP(bp) (GET((char *)(bp) + WSIZE))\r\n\r\nstatic void *extend_heap(size_t words);\r\n\r\nstatic void *coalesce(void *bp);\r\n\r\nstatic void *find_fit(size_t asize);\r\n\r\nstatic void place(void *bp, size_t size);\r\n\r\nstatic size_t find_index(size_t size);\r\n\r\nstatic void disconnect(void *bp);\r\n\r\nvoid *mm_malloc(size_t size);\r\n\r\nstatic void place_free(void *bp);\r\n\r\nchar *seg_listp;\r\n\r\nchar *heap_listp;\r\n\r\n/*\r\n\r\n * mm_init - initialize the malloc package.\r\n\r\n */\r\n\r\nint mm_init(void)\r\n{\r\n    /**\r\n     * \u5206\u79bb\u7a7a\u95f2\u5217\u8868\uff1aseg_list\r\n     * 1. \u6bcf\u4e2a\u5217\u8868\u5934\u4e3a\uff1a 4 Word \r\n     *      * Header: size (32) + allocated bit (001) \r\n     *      * Prev: \u4e0a\u4e00\u4e2a\u7a7a\u95f2\u5217\u8868\u7684\u5730\u5740 \r\n     *      * Succ: \u4e0b\u4e00\u4e2a\u7a7a\u5fc3\u5217\u8868\u7684\u5730\u5740\r\n     *      * Footer: size (32) + allocated bit (001) \r\n     * 2. \u5217\u8868\u7684\u5143\u7d20\u4e3a\uff1a\r\n     *      * Header: size (32) + allocated bit (001)\r\n     *      * Prev: \u4e0a\u4e00\u4e2a\u7a7a\u95f2\u5217\u8868\u7684\u5730\u5740 \r\n     *      * Succ: \u4e0b\u4e00\u4e2a\u7a7a\u5fc3\u5217\u8868\u7684\u5730\u5740\r\n     *      * Payload\r\n     *      * Footer: size (32) + allocated bit (001)    \r\n     */\r\n    if ((seg_listp = mem_sbrk(SEG_LIST_LEN * WSIZE * 4)) == (void *)-1)\r\n    {\r\n        return -1;\r\n    }\r\n    seg_listp = seg_listp + WSIZE; // \u6307\u5411\u9996\u4e2a\u5217\u8868\u7684\u5757\u4f4d\u7f6e\r\n    // \u521d\u59cb\u5316\u7a7a\u95f2\u5217\u8868\r\n    for (size_t i = 0; i < SEG_LIST_LEN; i++)\r\n    {\r\n        char *bp = ITEM_OF_FREE_LIST(seg_listp, i);\r\n        PUT(HDRP(bp), PACK(4 * WSIZE, 1));\r\n        PUT(FTRP(bp), PACK(4 * WSIZE, 1));\r\n        PUT(PREV(bp), 0);\r\n        PUT(SUCC(bp), 0);\r\n    }\r\n    // \u521d\u59cb\u5316\u9690\u5f0f\u5217\u8868\r\n    if ((heap_listp = mem_sbrk(4 * WSIZE)) == (void *)-1)\r\n    {\r\n        return -1;\r\n    }\r\n\r\n    PUT(heap_listp, 0);                            // \u8d77\u59cb\u4f4d\u7f6e\r\n    PUT(heap_listp + (1 * WSIZE), PACK(DSIZE, 1)); // \u5e8f\u8a00\u5757 8/1\r\n    PUT(heap_listp + (2 * WSIZE), PACK(DSIZE, 1)); // \u5e8f\u8a00\u5757 8/1\r\n    PUT(heap_listp + (3 * WSIZE), PACK(0, 1));     // \u7ed3\u5c3e\u5757 0/1\r\n\r\n    // \u6307\u5411\u666e\u901a\u5757\u8d77\u59cb\u4f4d\u7f6e\r\n    heap_listp += (2 * WSIZE);\r\n\r\n    char *bp;\r\n    if ((bp = extend_heap(CHUNKSIZE)) == NULL) {\r\n        return -1;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * find_fit - \u5bfb\u627e\u7a7a\u95f2\u5757\r\n * \u7b56\u7565\uff1a \u9996\u6b21\u5339\u914d\r\n * \r\n */\r\nstatic void *find_fit(size_t asize) {\r\n    size_t index = find_index(asize);\r\n    for (size_t i = index; i < SEG_LIST_LEN; i++)\r\n    {\r\n        char *cur_free_bp = ITEM_OF_FREE_LIST(seg_listp, i);\r\n        char *succ_free_bp = SUCC_FREE_BLKP(cur_free_bp);\r\n        while (succ_free_bp != 0)\r\n        {\r\n            if (succ_free_bp != 0 && GET_SIZE(HDRP(succ_free_bp)) >= asize)\r\n            {\r\n                return succ_free_bp;\r\n            }\r\n            succ_free_bp = SUCC_FREE_BLKP(succ_free_bp);\r\n        }\r\n    }\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * - disconnect \u65ad\u5f00\u5728\u7a7a\u95f2\u94fe\u8868\u4e2d\u7684\u8fde\u63a5\r\n * \r\n */\r\nstatic void disconnect(void *bp)\r\n{\r\n    char *prev_free_bp = PREV_FREE_BLKP(bp);\r\n    char *succ_free_bp = SUCC_FREE_BLKP(bp);\r\n\r\n    PUT(SUCC(prev_free_bp), succ_free_bp);\r\n    if (succ_free_bp != 0)\r\n    {\r\n        PUT(PREV(succ_free_bp), prev_free_bp);\r\n    }\r\n}\r\n\r\n/**\r\n\r\n * Allocated block\r\n\r\n * hdr (4bytes): size(29bit) allocated bit(001)(3bit)\r\n * payload\r\n * padding\r\n * ftr (4bytes): size(29bit) allocated bit(001)(3bit)\r\n *\r\n * Free block\r\n * hdr (4bytes): size(29bit) allocated bit(000)(3bit) (010) \u4ee3\u8868\u524d\u4e00\u4e2a\u5757\r\n * succ\r\n * payload\r\n * padding\r\n * ftr (4bytes): size(29bit) allocated bit(001)(3bit)\r\n */\r\n\r\nstatic void place(void *bp, size_t size) {\r\n    disconnect(bp);\r\n    size_t cur_bk_size = GET_SIZE(HDRP(bp));\r\n    size_t remaining_size = cur_bk_size - size;\r\n    if (remaining_size >= MINI_BLOCK_SIZE) {\r\n        PUT(HDRP(bp), PACK(size, 1));\r\n        PUT(FTRP(bp), PACK(size, 1));\r\n        PUT(HDRP(NEXT_BLKP(bp)), PACK(remaining_size, 0));\r\n        PUT(FTRP(NEXT_BLKP(bp)), PACK(remaining_size, 0));\r\n        place_free(NEXT_BLKP(bp));\r\n    }\r\n    else\r\n    {\r\n        PUT(HDRP(bp), PACK(cur_bk_size, 1));\r\n        PUT(FTRP(bp), PACK(cur_bk_size, 1));\r\n    }\r\n}\r\n\r\n/*\r\n\r\n * mm_malloc - Allocate a block by incrementing the brk pointer.\r\n\r\n *     Always allocate a block whose size is a multiple of the alignment.\r\n\r\n */\r\n\r\nvoid *mm_malloc(size_t size)\r\n{\r\n    if (size == 0) {\r\n        return NULL;\r\n    }\r\n\r\n    size_t asize = ALIGN(size) + DSIZE;\r\n    size_t extend_size;\r\n    char *bp;\r\n\r\n    if ((bp = find_fit(asize)) != NULL) {\r\n        place(bp, asize);\r\n        return bp;\r\n    }\r\n\r\n    // \u65e0\u7a7a\u95f2\u5217\u8868\uff0c\u5219\u5411\u7cfb\u7edf\u7533\u8bf7\u5206\u914d\u5185\u5b58\uff0c \u6700\u5c0f\u5355\u4f4d\u4e3a 4kb\r\n    extend_size = MAX(asize, CHUNKSIZE);\r\n    \r\n    if ((bp = extend_heap(extend_size)) == NULL)\r\n        return NULL;\r\n    place(bp, asize);\r\n    return bp;\r\n}\r\n\r\nstatic void place_free(void *bp)\r\n{\r\n    size_t index = find_index(GET_SIZE(HDRP(bp)));\r\n    char *start_bp = ITEM_OF_FREE_LIST(seg_listp, index);\r\n\r\n    // \u6839\u636eDIFO\u7b56\u7565\u5bfb\u627e\u5408\u9002\u4f4d\u7f6e\r\n    while (SUCC_FREE_BLKP(start_bp)!= 0)\r\n    {\r\n        if (SUCC_FREE_BLKP(start_bp) > (unsigned int)bp)\r\n        {\r\n            break;\r\n        }\r\n        start_bp = SUCC_FREE_BLKP(start_bp);\r\n    }\r\n\r\n    // \u5728\u5408\u9002\u4f4d\u7f6e\u5efa\u7acb\u94fe\u63a5start_bp_succ\r\n    char *start_bp_succ = SUCC_FREE_BLKP(start_bp);\r\n    PUT(SUCC(start_bp), bp);\r\n    PUT(PREV(bp), start_bp);\r\n    PUT(SUCC(bp), start_bp_succ);\r\n    if (start_bp_succ != 0) {\r\n        PUT(PREV(start_bp_succ), bp);\r\n    }\r\n}\r\n\r\n/*\r\n * mm_free - Freeing a block does nothing.\r\n */\r\n\r\nvoid mm_free(void *bp) {\r\n    size_t size = GET_SIZE(HDRP(bp));\r\n    PUT(HDRP(bp), PACK(size, 0));\r\n    PUT(FTRP(bp), PACK(size, 0));\r\n    coalesce(bp);\r\n}\r\n\r\n/*\r\n * mm_realloc - Implemented simply in terms of mm_malloc and mm_free\r\n */\r\n\r\nvoid *mm_realloc(void *ptr, size_t size)\r\n{\r\n    if (ptr == NULL) {\r\n        return mm_malloc(size);\r\n    }\r\n    if (size == 0) {\r\n        mm_free(ptr);\r\n        return NULL;\r\n    }\r\n    \r\n    size_t asize = ALIGN(size) + DSIZE;\r\n    size_t cur_bk_size = GET_SIZE(HDRP(ptr));\r\n\r\n    if (cur_bk_size == asize) {\r\n        return ptr;\r\n    } else if (cur_bk_size < asize)\r\n    {\r\n        char *new_ptr = mm_malloc(size);\r\n        memcpy(new_ptr, ptr, cur_bk_size - DSIZE);\r\n        mm_free(ptr);\r\n        return new_ptr;\r\n    } else {\r\n        // shrink\r\n         size_t remaining_size = cur_bk_size - asize;\r\n        if (remaining_size >= MINI_BLOCK_SIZE)\r\n        {\r\n            PUT(HDRP(ptr), PACK(size, 1));\r\n            PUT(FTRP(ptr), PACK(size, 1));\r\n            PUT(HDRP(NEXT_BLKP(ptr)), PACK((remaining_size), 0));\r\n            PUT(FTRP(NEXT_BLKP(ptr)), PACK((remaining_size), 0));\r\n            coalesce(NEXT_BLKP(ptr));\r\n        }\r\n        return ptr;\r\n    }\r\n}\r\n\r\nstatic void *extend_heap(size_t size) {\r\n    size_t asize = size % CHUNKSIZE == 0 ? size : ((size / CHUNKSIZE) + 1) * CHUNKSIZE;\r\n    char *bp;\r\n    if ((bp = mem_sbrk(asize)) == (void *)-1)\r\n    {\r\n        return NULL;\r\n    }\r\n    PUT(HDRP(bp), PACK(asize, 0));\r\n    PUT(FTRP(bp), PACK(asize, 0));\r\n    PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1));\r\n\r\n    size_t prev_alloc = GET_ALLOC(HDRP(PREV_BLKP(bp)));\r\n    if (!prev_alloc)\r\n    {\r\n        disconnect(PREV_BLKP(bp));\r\n        asize += GET_SIZE(HDRP(PREV_BLKP(bp)));\r\n        PUT(FTRP(bp), PACK(asize, 0));\r\n        PUT(HDRP(PREV_BLKP(bp)), PACK(asize, 0));\r\n        bp = PREV_BLKP(bp);\r\n    }\r\n    place_free(bp);\r\n    return bp;\r\n}\r\n\r\nstatic void *coalesce(void *bp) {\r\n\r\n    size_t size = GET_SIZE(HDRP(bp));\r\n    size_t prev_alloc = GET_ALLOC(HDRP(PREV_BLKP(bp)));\r\n    size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));\r\n    if (prev_alloc && next_alloc)\r\n    {\r\n        place_free(bp);\r\n        return bp;\r\n    }\r\n\r\n    if (prev_alloc && !next_alloc)\r\n    {\r\n        disconnect(NEXT_BLKP(bp));\r\n        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));\r\n        PUT(HDRP(bp), PACK(size, 0));\r\n        PUT(FTRP(bp), PACK(size, 0));\r\n        place_free(bp);\r\n    } else if (!prev_alloc && next_alloc) {\r\n        disconnect(PREV_BLKP(bp));\r\n        size += GET_SIZE(HDRP(PREV_BLKP(bp)));\r\n        PUT(FTRP(bp), PACK(size, 0));\r\n        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));\r\n        bp = PREV_BLKP(bp);\r\n        place_free(bp);\r\n    } else\r\n    {\r\n        disconnect(NEXT_BLKP(bp));\r\n        disconnect(PREV_BLKP(bp));\r\n        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(HDRP(NEXT_BLKP(bp)));\r\n        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));\r\n        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0));\r\n        bp = PREV_BLKP(bp);\r\n        place_free(bp);\r\n    }\r\n    return bp;\r\n}\r\n\r\nstatic size_t find_index(size_t size)\r\n{\r\n    if (size <= 16)\r\n        return 0;\r\n    if (size <= 32)\r\n        return 1;\r\n    if (size <= 64)\r\n        return 2;\r\n    if (size <= 80)\r\n        return 3;\r\n    if (size <= 120)\r\n        return 4;\r\n    if (size <= 240)\r\n        return 5;\r\n    if (size <= 480)\r\n        return 6;\r\n    if (size <= 960)\r\n        return 7;\r\n    if (size <= 1920)\r\n        return 8;\r\n    if (size <= 3840)\r\n        return 9;\r\n    if (size <= 4096)\r\n        return 10;\r\n    if (size <= 15360)\r\n        return 11;\r\n    if (size <= 30720)\r\n        return 12;\r\n    if (size <= 61440)\r\n        return 13;\r\n    else\r\n        return 14;\r\n}\r\n```\r\n\u3002", "top": 0, "createdAt": 1722939209, "style": "", "script": "", "head": "", "ogImage": "https://img.icons8.com/doodle/480/mugman.png", "createdDate": "2024-08-06", "dateLabelColor": "#bc4c00"}, "P9": {"htmlDir": "docs/post/cs61c-su24-project1- snek.html", "labels": ["project", "cs61c"], "postTitle": "cs61c-su24-project1: snek", "postUrl": "post/cs61c-su24-project1-%20snek.html", "postSourceUrl": "https://github.com/LianSeKong/lizi/issues/9", "commentNum": 0, "wordCount": 30656, "description": "# Snake\r\n\r\n> creating a playable snake game\r\n\r\n## Conceptual Overview\r\n\r\n### Snakes\r\n\r\nA snake game can be represented by a grid of characters. \r\n\r\nThe grid contains walls, fruits, and one or more snakes. \r\n\r\nAn example of a game is shown below:\r\n\r\n```javascript\r\n##############\r\n#            #\r\n#    dv      #\r\n#     v   #  #\r\n#     v   #  #\r\n#   s >>D #  #\r\n#   v     #  #\r\n# *A<  *  #  #\r\n#            #\r\n##############\r\n```\r\n\r\nThe grid has the following special characters:\r\n\r\n*   `#` denotes a wall.\r\n*   (space character) denotes an empty space.\r\n*   `*` denotes a fruit.\r\n*   `wasd` denotes the tail of a snake.\r\n*   `^<v>` denotes the body of a snake.\r\n*   `WASD` denotes the head of a snake.\r\n*   `x` denotes the head of a snake that has died.\r\n\r\nEach character of the snake tells you what direction the snake is currently heading in:\r\n\r\n*   `w`, `W`, or `^` denotes up\r\n*   `a`, `A`, or `<` denotes left\r\n*   `s`, `S`, or `v` denotes down\r\n*   `d`, `D`, or `>` denotes right\r\n\r\nAt each time step, each snakes moves according to the following rules:\r\n\r\n*   Each snake moves one step in the direction of its head.\r\n*   If the head crashes into the body of a snake or a wall, the snake dies and stops moving. When a snake dies, the head is replaced with an `x`.\r\n*   If the head moves into a fruit, the snake eats the fruit and grows by 1 unit in length. Each time fruit is consumed, a new fruit is generated on the board.\r\n\r\nIn the example above, after one time step, the board will look like this:\r\n\r\n```\r\n##############\r\n#         *  #\r\n#     s      #\r\n#     v   #  #\r\n#     v   #  #\r\n#   s >>>D#  #\r\n#   v     #  #\r\n# A<<  *  #  #\r\n#            #\r\n##############\r\n```\r\n\r\nAfter one more time step, the board will look like this:\r\n\r\n```\r\n##############\r\n#         *  #\r\n#     s      #\r\n#     v   #  #\r\n#     v   #  #\r\n#     >>>x#  #\r\n#   s     #  #\r\n#A<<<  *  #  #\r\n#            #\r\n##############\r\n```\r\n\r\nSnakes are guaranteed to be at least three units long.\r\n\r\n### Numbering snakes\r\n\r\nEach snake on the board is numbered depending on the position of its tail, in the order that the tails appear in the file (going from top-to-bottom, then left-to-right). For example, consider the following board with four snakes:\r\n\r\n```\r\n#############\r\n#  s  d>>D  #\r\n#  v   A<a  #\r\n#  S    W   #\r\n#       ^   #\r\n#       w   #\r\n#############\r\n```\r\n\r\nSnake 0 is the snake with tail `s`, snake 1 has tail `d`, snake 2 has tail `a`, and snake 3 has tail `w`.\r\n\r\nOnce the snakes are numbered from their initial positions, the numbering of the snakes does not change throughout the game.\r\n\r\n### Game board\r\n\r\nA game board is a grid of characters, not necessarily rectangular. Here's an example of a non-rectangular board:\r\n\r\n```\r\n##############\r\n#            #######\r\n#####             ##\r\n#   #             ##\r\n#####             ######\r\n#                 ##   #\r\n#                 ######\r\n#                 ##\r\n#                  #\r\n#      #####       #\r\n########   #########\r\n```\r\n\r\nNote that each row can have a different number of characters, but will start and end with a wall (`#`). You can also assume that the board is an enclosed space, so snakes can't travel infinitely far in any direction.\r\n\r\n### The `game_state_t` struct\r\n\r\nA snake game is stored in memory in a `game_state_t` struct, which is defined in `state.h`. The struct contains the following fields:\r\n\r\n*   `unsigned int num_rows`: The number of rows in the game board.\r\n*   `char** board`: The game board in memory. Each element of the `board` array is a `char*` pointer to a character array containing a row of the board. Each row must be terminated by a new line character and must be a valid string.\r\n*   `unsigned int num_snakes`: The number of snakes on the board.\r\n*   `snake_t* snakes`: An array of `snake_t` structs.\r\n\r\n### The `snake_t` struct\r\n\r\nAlso defined in `state.h`, each `snake_t` struct contains the following fields:\r\n\r\n*   `unsigned int tail_row`: The row of the snake's tail.\r\n*   `unsigned int tail_col`: The column of the snake's tail.\r\n*   `unsigned int head_row`: The row of the snake's head.\r\n*   `unsigned int head_col`: The column of the snake's head.\r\n*   `bool live`: `true` if the snake is alive, and `false` if the snake is dead.\r\n\r\nPlease don't modify the provided struct definitions. You should only need to modify `state.c` `snake.c`, and `custom_tests.c` in this project.\r\n\r\n## Task 1: `create_default_state`\r\n\r\nImplement the `create_default_state` function in `state.c`. This function should create a default snake game in memory with the following starting state (which you can hardcode), and return a pointer to the newly created `game_state_t` struct.\r\n\r\n```\r\n####################\r\n#                  #\r\n# d>D    *         #\r\n#                  #\r\n#                  #\r\n#                  #\r\n#                  #\r\n#                  #\r\n#                  #\r\n#                  #\r\n#                  #\r\n#                  #\r\n#                  #\r\n#                  #\r\n#                  #\r\n#                  #\r\n#                  #\r\n####################\r\n```\r\n\r\n<table><colgroup><col span='1'> <col span='1'> <col span='1'> </colgroup><tbody><tr><td colspan='3'><code>create_default_state</code></td></tr><tr><td><b>Arguments</b></td><td colspan='2'>None</td></tr><tr><td><b>Return values</b></td><td><code>game_state_t *</code></td><td>A pointer to the newly created <code>game_state_t</code> struct.</td></tr></tbody></table>\r\n\r\n### Hints\r\n\r\n*   The board has 18 rows, and each row has 20 columns. The fruit is at row 2, column 9 (zero-indexed). The tail is at row 2, column 2, and the head is at row 2, column 4.\r\n*   Which part of memory (code, static, stack, heap) should you store the new game in?\r\n*   `strcpy` may be helpful.\r\n\r\n\r\n\r\n## Solution\r\n\r\n```c\r\n/* Task 1 */\r\ngame_state_t *create_default_state() {\r\n  unsigned int num_cols = 20;\r\n  game_state_t *state = (game_state_t *)malloc(sizeof(game_state_t));\r\n  state->num_rows = 18;\r\n  state->num_snakes = 1;\r\n\r\n  // init board\r\n  state->board = (char **)calloc(state->num_rows, sizeof(char *));\r\n  for (size_t i = 0; i < state->num_rows; i++) {\r\n    state->board[i] = (char *)calloc(num_cols + 1, sizeof(char));\r\n  }\r\n  // begin an end row\r\n  strcpy(state->board[0], '####################');\r\n  strcpy(state->board[state->num_rows - 1], '####################');\r\n  // main body\r\n  for (unsigned int i = 1; i < state->num_rows - 1; i++) {\r\n    strcpy(state->board[i], '#                  #');\r\n  }\r\n\r\n  // init snake\r\n  state->snakes = (snake_t *)malloc(sizeof(snake_t) * state->num_snakes);\r\n  state->snakes[0].tail_row = 2;\r\n  state->snakes[0].tail_col = 2;\r\n  state->snakes[0].head_row = 2;\r\n  state->snakes[0].head_col = 4;\r\n  state->snakes[0].live = true;\r\n\r\n  // init fruit  \r\n  state->board[2][9] = '*';\r\n\r\n  // render board\r\n  snake_t snake = state->snakes[0];\r\n  state->board[2][2] = 'd';\r\n  state->board[snake.tail_row][snake.tail_col] = 'd';\r\n  state->board[snake.head_row][snake.head_col] = 'D';\r\n  state->board[snake.head_row][snake.head_col - 1] = '>';\r\n  return state;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## Task 2: `free_state`\r\n\r\nImplement the `free_state` function in `state.c`. This function should free all memory allocated for the given state, including all `snake` structs and all `state`->`board` contents.\r\n\r\n<table><colgroup><col span='1'> <col span='1'> <col span='1'> </colgroup><tbody><tr><td colspan='3'><code>free_state</code></td></tr><tr><td><b>Arguments</b></td><td><code>game_state_t* state</code></td><td>A pointer to the <code>game_state_t</code> struct to be freed</td></tr><tr><td><b>Return values</b></td><td colspan='2'>None</td></tr></tbody></table>\r\n\r\n## Solution\r\n\r\n```c\r\n/* Task 2 */\r\nvoid free_state(game_state_t *state)\r\n{\r\n  for (size_t i = 0; i < state->num_rows; i++) {\r\n    free(state->board[i]);\r\n  }\r\n  free(state->snakes);\r\n  free(state->board);\r\n  free(state);\r\n  return;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Task 3: `print_board`\r\n\r\nImplement the `print_board` function in `state.c`. This function should print out the given game board to the given file pointer.\r\n\r\n<table><colgroup><col span='1'> <col span='1'> <col span='1'> </colgroup><tbody><tr><td colspan='3'><code>print_board</code></td></tr><tr><td rowspan='2'><b>Arguments</b></td><td><code>game_state_t* state</code></td><td>A pointer to the <code>game_state_t</code> struct to be printed</td></tr><tr><td><code>FILE* fp</code></td><td>A pointer to the file object where the board should be printed to</td></tr><tr><td><b>Return values</b></td><td colspan='2'>None</td></tr></tbody></table>\r\n\r\n### Hints\r\n\r\n*   The `fprintf` function will help you print out characters and/or strings to a given file pointer.\r\n\r\n## Solution\r\n\r\n```c\r\nvoid print_board(game_state_t *state, FILE *fp)\r\n{\r\n  for (size_t i = 0; i < state->num_rows; i++) {\r\n    fprintf(fp, '%s\\n', state->board[i]);\r\n  }\r\n  return;\r\n}\r\n```\r\n\r\n\r\n\r\n## Task 4: `update_state`\r\n\r\nImplement the `update_state` function in `state.c`. This function should move the snakes one timestep according to the rules of the game.\r\n\r\nHelper functions are not graded; for this task, we'll only be checking that `update_state` is correct.\r\n\r\n### Task 4.1: Helpers\r\n\r\nWe have provided the following helper function definitions that you can implement. These functions are entirely independent of any game board or snake; they only take in a single character and output some information about that character.\r\n\r\n*   `bool is_tail(char c)`: Returns true if `c` is part of the snake's tail. The snake's tail consists of these characters: `wasd`. Returns false otherwise.\r\n*   `bool is_head(char c)`: Returns true if `c` is part of the snake's head. The snake's head consists of these characters: `WASDx`. Returns false otherwise.\r\n*   `bool is_snake(char c)`: Returns true if `c` is part of the snake. The snake consists of these characters: `wasd^<v>WASDx`. Returns false otherwise.\r\n*   `char body_to_tail(char c)`: Converts a character in the snake's body (`^<v>`) to the matching character representing the snake's tail (`wasd`). The output may be undefined for characters that are not a snake's body.\r\n*   `char head_to_body(char c)`: Converts a character in the snake's head (`WASD`) to the matching character representing the snake's body (`^<v>`). The output may be undefined for characters that are not a snake's head.\r\n*   `unsigned int get_next_row(unsigned int cur_row, char c)`: Returns `cur_row + 1` if `c` is `v` or `s` or `S`. Returns `cur_row - 1` if `c` is `^` or `w` or `W`. Returns `cur_row` otherwise.\r\n*   `unsigned int get_next_col(unsigned int cur_col, char c)`: Returns `cur_col + 1` if `c` is `>` or `d` or `D`. Returns `cur_col - 1` if `c` is `<` or `a` or `A`. Returns `cur_col` otherwise.\r\n\r\nUnit tests are not provided for these helper functions, so you'll have to write your own tests in `custom_tests.c` to make sure that these are working as expected. Make sure that these tests comprehensively test your helper functions--our autograder will run your tests on buggy implementations to make sure that your tests can catch bugs!\r\n\r\nWhen writing a unit test, the test function should return `false` if the test fails, and `true` if the test passes. You can use `printf` to print out debugging statements. Some of the assert helper functions in `asserts.h` might be useful.\r\n\r\nOnce you've written your own unit tests, you can run them with `make run-custom-tests` and `make debug-custom-tests`.\r\n\r\n## Solution\r\n\r\n```c\r\nstatic bool is_tail(char c) {\r\n  return c == 'w' || c == 'a' || c == 's' || c == 'd';\r\n}\r\nstatic bool is_head(char c) {\r\n  return c == 'W' || c == 'A' || c == 'S' || c == 'D' || c == 'x';\r\n}\r\nstatic bool is_snake(char c) {\r\n  return is_tail(c) || is_head(c) || c == 'v' || c == '^' || c == '<' || c == '>';\r\n}\r\nstatic char body_to_tail(char ch) {\r\n  switch (ch) {\r\n      case '^':\r\n          ch = 'w';\r\n          break;\r\n      case 'v':\r\n          ch = 's';\r\n          break;\r\n      case '>':\r\n          ch = 'd';\r\n          break;\r\n      case '<':\r\n          ch = 'a';\r\n          break;\r\n      default:\r\n          ch = '?';\r\n          break;\r\n  }\r\n  return ch;\r\n}\r\nstatic char head_to_body(char c) {\r\n  char cb;\r\n  switch (c) {\r\n      case 'W':\r\n        cb = '^';\r\n        break;\r\n      case 'S':\r\n        cb = 'v';\r\n        break;\r\n      case 'A':\r\n        cb = '<';\r\n        break;\r\n      case 'D':\r\n        cb = '>';\r\n        break;\r\n      default:\r\n        cb = '?';\r\n  }\r\n  return cb;\r\n}\r\n\r\nstatic unsigned int get_next_row(unsigned int cur_row, char c) {\r\n  if (c == 'v' || c == 's' || c == 'S') {\r\n    cur_row += 1;\r\n  }\r\n  else if (c == '^' || c == 'w' || c == 'W') {\r\n    cur_row -= 1;\r\n  }\r\n  return cur_row;\r\n}\r\n\r\nstatic unsigned int get_next_col(unsigned int cur_col, char c) {\r\n  if (c == '>' || c == 'd' || c == 'D') {\r\n    cur_col += 1;\r\n  }\r\n  else if (c == '<' || c == 'a' || c == 'A') {\r\n    cur_col -= 1;\r\n  }\r\n  return cur_col;\r\n}\r\n```\r\n\r\n\r\n\r\n### Task 4.2: `next_square`\r\n\r\nImplement the `next_square` helper function in `state.c`. This function returns the character in the cell the given snake is moving into. This function should not modify anything in the game stored in memory.\r\n\r\n<table><colgroup><col span='1'> <col span='1'> <col span='1'> </colgroup><tbody><tr><td colspan='3'><code>next_square</code></td></tr><tr><td rowspan='2'><b>Arguments</b></td><td><code>game_state_t* state</code></td><td>A pointer to the <code>game_state_t</code> struct to be analyzed</td></tr><tr><td><code>int snum</code></td><td>The index of the snake to be analyzed</td></tr><tr><td><b>Return values</b></td><td><code>char</code></td><td>The character in the cell the given snake is moving into</td></tr></tbody></table>\r\n\r\nAs an example, consider the following board:\r\n\r\n```\r\n##############\r\n#            #\r\n#            #\r\n#            #\r\n#   d>D*     #\r\n#            #\r\n#       s    #\r\n#       v    #\r\n#       S    #\r\n##############\r\n```\r\n\r\nAssuming that `state` is a pointer to this game state, then `next_square(state, 0)` should return `*`, because the head of snake 0 is moving into a cell with `*` in it. Similarly, `next_square(state, 1)` should return `#` for snake 1.\r\n\r\nThe helper functions you wrote earlier might be helpful for this function (and the rest of this task too). Also, check out `get_board_at` and `set_board_at`, which are helper functions we wrote for you.\r\n\r\nUse `make run-unit-tests` and `make debug-unit-tests` to run the provided unit tests. You can also use `p print_board(state, stdout)` to print out your entire board while debugging in `cgdb`.\r\n\r\n\r\n\r\n## Solution\r\n\r\n```c\r\nstatic char next_square(game_state_t *state, unsigned int snum) {\r\n  snake_t snake = state->snakes[snum];\r\n  char head_char = state->board[snake.head_row][snake.head_col];\r\n  unsigned int next_col = get_next_col(snake.head_col, head_char);\r\n  unsigned int next_row = get_next_row(snake.head_row, head_char);\r\n  return get_board_at(state, next_row, next_col);\r\n}\r\n```\r\n\r\n\r\n\r\n### Task 4.3: `update_head`\r\n\r\nImplement the `update_head` function in `state.c`. This function will update the head of the snake.\r\n\r\nRemember that you will need to update the head both on the game board and in the `snake_t` struct. On the game board, add a character where the snake is moving. In the `snake_t` struct, update the row and column of the head.\r\n\r\n<table><colgroup><col span='1'> <col span='1'> <col span='1'> </colgroup><tbody><tr><td colspan='3'><code>update_head</code></td></tr><tr><td rowspan='2'><b>Arguments</b></td><td><code>game_state_t* state</code></td><td>A pointer to the <code>game_state_t</code> struct to be updated</td></tr><tr><td><code>int snum</code></td><td>The index of the snake to be updated</td></tr><tr><td><b>Return values</b></td><td colspan='2'>None</td></tr></tbody></table>\r\n\r\nAs an example, consider the following board:\r\n\r\n```\r\n##############\r\n#   d>D      #\r\n#        *   #\r\n#        W   #\r\n#        ^   #\r\n#        ^   #\r\n#        w   #\r\n#            #\r\n#            #\r\n##############\r\n\r\n\r\n```\r\n\r\nAssuming that `state` is a pointer to this game state, then `update_head(state, 0)` will move the head of snake 0, leaving all other snakes unchanged. In the `snake_t` struct corresponding to snake 0, the `head_col` value should be updated from 6 to 7, and the `head_row` value should stay unchanged at 1. The new board will look like this:\r\n\r\n```\r\n##############\r\n#   d>>D     #\r\n#        *   #\r\n#        W   #\r\n#        ^   #\r\n#        ^   #\r\n#        w   #\r\n#            #\r\n#            #\r\n##############\r\n\r\n\r\n```\r\n\r\nNote that this function ignores food, walls, and snake bodies when moving the head.\r\n\r\n## Solution\r\n\r\n```c\r\nstatic void update_head(game_state_t *state, unsigned int snum) {\r\n  snake_t *snake = (state->snakes) + snum;\r\n  unsigned int cur_row = snake->head_row;\r\n  unsigned int cur_col = snake->head_col;\r\n  char cur_char = state->board[cur_row][cur_col];\r\n  unsigned int next_row = get_next_row(cur_row, cur_char);\r\n  unsigned int next_col = get_next_col(cur_col, cur_char);\r\n  set_board_at(state, next_row, next_col, cur_char);\r\n  set_board_at(state, cur_row, cur_col, head_to_body(cur_char));\r\n  snake->head_row = next_row;\r\n  snake->head_col = next_col;\r\n  return;\r\n}\r\n```\r\n\r\n\r\n\r\n### Task 4.4: `update_tail`\r\n\r\nImplement the `update_tail` function in `state.c`. This function will update the tail of the snake.\r\n\r\nRemember that you will need to update the tail both on the game board and in the `snake_t` struct. On the game board, blank out the current tail, and change the new tail from a body character (`^<v>`) into a tail character (`wasd`). In the `snake_t` struct, update the row and column of the tail.\r\n\r\n<table><colgroup><col span='1'> <col span='1'> <col span='1'> </colgroup><tbody><tr><td colspan='3'><code>update_tail</code></td></tr><tr><td rowspan='2'><b>Arguments</b></td><td><code>game_state_t* state</code></td><td>A pointer to the <code>game_state_t</code> struct to be updated</td></tr><tr><td><code>int snum</code></td><td>The index of the snake to be updated</td></tr><tr><td><b>Return values</b></td><td colspan='2'>None</td></tr></tbody></table>\r\n\r\nAs an example, consider the following board:\r\n\r\n```\r\n##############\r\n#   d>D      #\r\n#        *   #\r\n#        W   #\r\n#        ^   #\r\n#        ^   #\r\n#        w   #\r\n#            #\r\n#            #\r\n##############\r\n```\r\n\r\nAssuming that `state` is a pointer to this game state, then `update_tail(state, 1)` will move the tail of snake 1, leaving all other snakes unchanged. In the `snake_t` struct corresponding to snake 1, the `tail_row` value should be updated from 6 to 5, and the `tail_col` value should stay unchanged at 9. The new board will look like this:\r\n\r\n```\r\n##############\r\n#   d>D      #\r\n#        *   #\r\n#        W   #\r\n#        ^   #\r\n#        w   #\r\n#            #\r\n#            #\r\n#            #\r\n##############\r\n```\r\n\r\n## Solution\r\n\r\n```c\r\nstatic void update_tail(game_state_t *state, unsigned int snum) {\r\n  snake_t *snake_ptr = &state->snakes[snum];\r\n  char tail_char = state->board[snake_ptr->tail_row][snake_ptr->tail_col];\r\n  unsigned int next_row = get_next_row(snake_ptr->tail_row, tail_char);\r\n  unsigned int next_col = get_next_col(snake_ptr->tail_col, tail_char);\r\n  set_board_at(state, snake_ptr->tail_row, snake_ptr->tail_col, ' ');\r\n  set_board_at(state, next_row, next_col, body_to_tail(state->board[next_row][next_col]));\r\n  snake_ptr->tail_row = next_row;\r\n  snake_ptr->tail_col = next_col;\r\n  return;\r\n}\r\n```\r\n\r\n\r\n\r\n### Task 4.5: `update_state`\r\n\r\nUsing the helpers you created, implement `update_state` in `state.c`.\r\n\r\nAs a reminder, the rules for moving a snake are as follows:\r\n\r\n*   Each snake moves one step in the direction of its head.\r\n*   If the head crashes into the body of a snake or a wall, the snake dies and stops moving. When a snake dies, the head is replaced with an `x`.\r\n*   If the head moves into a fruit, the snake eats the fruit and grows by 1 unit in length. (You can implement growing by 1 unit by updating the head without updating the tail.) Each time fruit is consumed, a new fruit is generated on the board.\r\n\r\nThe `int (*add_food)(game_state_t* state)` argument is a function pointer, which means that `add_food` is a pointer to the code section of memory. The code that `add_food` is pointing at is a function that takes in `game_state_t* state` as an argument and returns an `int`. You can call this function with `add_food(x)`, replacing `x` with your argument, to add a fruit to the board.\r\n\r\n<table><colgroup><col span='1'> <col span='1'> <col span='1'> </colgroup><tbody><tr><td colspan='3'><code>update_state</code></td></tr><tr><td rowspan='2'><b>Arguments</b></td><td><code>game_state_t* state</code></td><td>A pointer to the <code>game_state_t</code> struct to be updated</td></tr><tr><td><code>int (*add_food)(game_state_t* state)</code></td><td>A pointer to a function that will add fruit to the board</td></tr><tr><td><b>Return values</b></td><td colspan='2'>None</td></tr></tbody></table>\r\n\r\n## Solution\r\n\r\n```c\r\nvoid update_state(game_state_t *state, int (*add_food)(game_state_t *state))\r\n{\r\n  for (unsigned int i = 0; i < state->num_snakes; i++)\r\n  {\r\n    snake_t *snake_ptr = state->snakes + i;\r\n    char head_char = get_board_at(state, snake_ptr->head_row, snake_ptr->head_col);\r\n    unsigned int next_row = get_next_row(snake_ptr->head_row, head_char);\r\n    unsigned int next_col = get_next_col(snake_ptr->head_col, head_char);\r\n    char next_char = get_board_at(state, next_row, next_col);\r\n    if (is_snake(next_char) || next_char == '#') {\r\n      snake_ptr->live = false;\r\n      set_board_at(state, snake_ptr->head_row, snake_ptr->head_col, 'x');\r\n    } else if (next_char == '*') {\r\n      update_head(state, i);\r\n      add_food(state);\r\n    } else {\r\n      update_head(state, i);\r\n      update_tail(state, i);\r\n    }\r\n  }\r\n  return;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## Task 5: `load_board`\r\n\r\nImplement the `load_board` function in `state.c`. This function will read a game board from a stream (`FILE *`) into memory. Your implementation of `load_board` must support reading in from `stdin` and any other streams, so please do not use anything that does not support `stdin`, such as seeking, rewinding, or reopening.\r\n\r\nRemember that each row of the game board might have a different number of columns. Your implementation should be memory-efficient and should not allocate significantly more memory than necessary to store the board. For example, if a row is 3 characters long, you shouldn't be allocating 100 bytes of space for that row.\r\n\r\nYou must use `fgets` to read from the file pointer. We reserve the ability to manually regrade your submission if it uses a function other than `fgets` to read from `file`. Other string functions, such as `strchr`, may be helpful here as well!\r\n\r\nHint: `realloc` may be helpful for this task.\r\n\r\nTasks 5 and 6 combined will create a `game_state_t` struct in memory with all its fields set up. In this task, please set `num_snakes` to 0 and set the `snakes` array to `NULL`, since these will be initialized in task 6.\r\n\r\n### Task 5.1: `read_line`\r\n\r\nImplement the `read_line` function in `state.c`. Given a `FILE *` `file`, read a line from `file` and store the string on the heap. If `fgets` errors, return `NULL`.\r\n\r\n<table><colgroup><col span='1'> <col span='1'> <col span='1'> </colgroup><tbody><tr><td colspan='3'><code>read_line</code></td></tr><tr><td><b>Arguments</b></td><td><code>FILE* file</code></td><td>A file pointer where the string can be read from</td></tr><tr><td><b>Return values</b></td><td><code>char *</code></td><td>A pointer to the newly read string. <code>NULL</code> if there are any errors, or if <code>EOF</code> is reached.</td></tr></tbody></table>\r\n\r\n## Solution\r\n\r\n```c\r\nchar *read_line(FILE *fp) {\r\n  char *str = (char *) malloc(sizeof(char) * 255);\r\n  if (fgets(str, 255, fp) == NULL) {\r\n    return NULL;\r\n  }\r\n  while (str[strlen(str) - 1] != '\\n') {\r\n    str = realloc(str, sizeof(char) * strlen(str) * 2);\r\n    fgets(str + strlen(str), 255, fp);\r\n  }\r\n  str = realloc(str, sizeof(char) * (strlen(str) + 1));\r\n  return str;\r\n}\r\n```\r\n\r\n\r\n\r\n### Task 5.2: `load_board`\r\n\r\nUsing `read_line`, implement the `load_board` function in `state.c`.\r\n\r\n<table><colgroup><col span='1'> <col span='1'> <col span='1'> </colgroup><tbody><tr><td colspan='3'><code>load_board</code></td></tr><tr><td><b>Arguments</b></td><td><code>FILE* file</code></td><td>A file pointer where the board can be read from</td></tr><tr><td><b>Return values</b></td><td><code>game_state_t *</code></td><td>A pointer to the newly created <code>game_state_t</code> struct. <code>NULL</code> if there are any errors.</td></tr></tbody></table>\r\n\r\n## Solution\r\n\r\n```c\r\ngame_state_t *load_board(FILE *fp) {\r\n  unsigned int capacity = 255;\r\n  game_state_t* state = (game_state_t *) malloc(sizeof(game_state_t));\r\n  state->num_snakes = 0;\r\n  state->snakes = NULL;\r\n  state->num_rows = 0;\r\n  state->board = (char **)calloc(capacity, sizeof(char *));\r\n  char* str;\r\n  while ((str = read_line(fp)) != NULL) {\r\n    if (str[strlen(str) - 1] == '\\n') {\r\n      str[strlen(str) - 1] = '\\0';\r\n    }\r\n    state->board[(state->num_rows)++] = str;\r\n    if (state->num_rows >= capacity) {\r\n      capacity *= 2;\r\n      state->board = (char **) realloc(state->board, sizeof(char *) * capacity);\r\n    }\r\n  }\r\n  state->board = (char **) realloc(state->board, sizeof(char *) * state->num_rows);\r\n  return state;\r\n}\r\n```\r\n\r\n\r\n\r\n## Task 6: `initialize_snake`\r\n\r\nImplement the `initialize_snake` function in `state.c`. This function takes in a game board and creates the array of `snake_t` structs.\r\n\r\n### Task 6.1: `find_head`\r\n\r\nImplement the `find_head` function in `state.c`. Given a `snake_t` struct with the tail row and column filled in, this function traces through the board to find the head row and column, and fills in the head row and column in the struct.\r\n\r\n<table><colgroup><col span='1'> <col span='1'> <col span='1'> </colgroup><tbody><tr><td colspan='3'><code>find_head</code></td></tr><tr><td rowspan='2'><b>Arguments</b></td><td><code>game_state_t* state</code></td><td>A pointer to the <code>game_state_t</code> struct to be analyzed</td></tr><tr><td><code>int snum</code></td><td>The index of the snake to be analyzed</td></tr><tr><td><b>Return values</b></td><td colspan='2'>None</td></tr></tbody></table>\r\n\r\nAs an example, consider the following board:\r\n\r\n```\r\n##############\r\n#            #\r\n#        *   #\r\n#            #\r\n#   d>v      #\r\n#     v      #\r\n#  W  v      #\r\n#  ^<<<      #\r\n#            #\r\n##############\r\n\r\n\r\n```\r\n\r\nAssuming that `state` is a pointer to this game state, then `find_head(state, 0)` will fill in the `head_row` and `head_col` fields of the snake 0 struct with 6 and 3, respectively.\r\n\r\n## Solution\r\n\r\n```c\r\nstatic void find_head(game_state_t *state, unsigned int snum) {\r\n  snake_t * snake_ptr = (state->snakes) + snum;\r\n  unsigned int row = snake_ptr->tail_row;\r\n  unsigned int col = snake_ptr->tail_col;\r\n  char ch = state->board[row][col];\r\n  while (is_snake(ch) && !is_head(ch)) {\r\n    row = get_next_row(row, ch);\r\n    col = get_next_col(col, ch);\r\n    ch = state->board[row][col];\r\n  }\r\n  snake_ptr->head_row = row;\r\n  snake_ptr->head_col = col;\r\n  return;\r\n}\r\n```\r\n\r\n\r\n\r\n### Task 6.2: `initialize_snake`\r\n\r\nUsing `find_head`, implement the `initialize_snake` function in `state.c`. You can assume that the state passed into this function is the result of calling `load_board`, but you may not assume that the `snakes` array is defined. This means the board-related fields are already filled in, and you only need to fill in `num_snakes` and create the `snakes` array.\r\n\r\nYou may assume that all snakes on the board start out alive.\r\n\r\n<table><colgroup><col span='1'> <col span='1'> <col span='1'> </colgroup><tbody><tr><td colspan='3'><code>initialize_snakes</code></td></tr><tr><td><b>Arguments</b></td><td><code>game_state_t* state</code></td><td>A pointer to the <code>game_state_t</code> struct to be filled in</td></tr><tr><td><b>Return values</b></td><td><code>game_state_t* state</code></td><td>A pointer to the <code>game_state_t</code> struct with fields filled in. This can be the same as the struct passed in (you can modify the struct in-place).</td></tr></tbody></table>\r\n\r\n## Solution\r\n\r\n```c\r\ngame_state_t *initialize_snakes(game_state_t *state) {\r\n  state->snakes = (snake_t *)malloc(sizeof(snake_t) * 512);\r\n  state->num_snakes = 0;\r\n  for (unsigned int i = 0; i < state->num_rows; i++)\r\n  {\r\n    char* row = state->board[i];\r\n\r\n    for (unsigned int j = 0; j < strlen(row); j++)\r\n    {\r\n      \r\n      char ch = row[j];\r\n      if (is_tail(ch)) {\r\n        snake_t* snake = state->snakes + (state->num_snakes);\r\n        snake->live = true;\r\n        snake->tail_row = i;\r\n        snake->tail_col = j;\r\n        state->num_snakes += 1;\r\n      }\r\n    }\r\n  }\r\n  for (unsigned int i = 0; i < state->num_snakes; i++) {\r\n    find_head(state, i);\r\n  }\r\n  print_board(state, stdout);\r\n  return state;\r\n}\r\n```\r\n\r\n\r\n\r\n## Task 7: `main`\r\n\r\nUsing the functions you implemented in all the previous tasks, fill in the blanks in `snake.c`. Each time the `snake.c` program is run, the board will be updated by one time step.\r\n\r\n## Solution\r\n\r\n```c\r\nint main(int argc, char *argv[]) {\r\n  bool io_stdin = false;\r\n  char *in_filename = NULL;\r\n  char *out_filename = NULL;\r\n  game_state_t *state = NULL;\r\n\r\n  for (int i = 1; i < argc; i++) {\r\n    if (strcmp(argv[i], '-i') == 0 && i < argc - 1) {\r\n      if (io_stdin) {\r\n        fprintf(stderr, 'Usage: %s [-i filename | --stdin] [-o filename]\\n', argv[0]);\r\n        return 1;\r\n      }\r\n      in_filename = argv[i + 1];\r\n      i++;\r\n      continue;\r\n    } else if (strcmp(argv[i], '--stdin') == 0) {\r\n      if (in_filename != NULL) {\r\n        fprintf(stderr, 'Usage: %s [-i filename | --stdin] [-o filename]\\n', argv[0]);\r\n        return 1;\r\n      }\r\n      io_stdin = true;\r\n      continue;\r\n    }\r\n    if (strcmp(argv[i], '-o') == 0 && i < argc - 1) {\r\n      out_filename = argv[i + 1];\r\n      i++;\r\n      continue;\r\n    }\r\n    fprintf(stderr, 'Usage: %s [-i filename | --stdin] [-o filename]\\n', argv[0]);\r\n    return 1;\r\n  }\r\n\r\n  if (in_filename != NULL) {\r\n    FILE * fp = fopen(in_filename, 'r');\r\n    if (fp == NULL) {\r\n      return -1;\r\n    }\r\n    state = load_board(fp);\r\n    initialize_snakes(state);\r\n  } else if (io_stdin) {\r\n    state = load_board(stdin);\r\n    initialize_snakes(state);\r\n  } else {\r\n    create_default_state();\r\n  }\r\n  update_state(state, deterministic_food);\r\n  if (out_filename != NULL) {\r\n    FILE *fp = fopen(out_filename, 'w+');\r\n    print_board(state, fp);\r\n  } else {\r\n    print_board(state, stdout);\r\n  }\r\n  free_state(state);\r\n  return 0;\r\n}\r\n```\r\n\r\n\u3002", "top": 0, "createdAt": 1723540705, "style": "", "script": "", "head": "", "ogImage": "https://img.icons8.com/doodle/480/mugman.png", "createdDate": "2024-08-13", "dateLabelColor": "#bc4c00"}, "P10": {"htmlDir": "docs/post/cs61a-su24-disc01.html", "labels": ["cs61a", "disc"], "postTitle": "cs61a-su24-disc01", "postUrl": "post/cs61a-su24-disc01.html", "postSourceUrl": "https://github.com/LianSeKong/lizi/issues/10", "commentNum": 0, "wordCount": 3434, "description": "``` python\r\nfrom math import sqrt\r\n\r\n# positive integer: \u5927\u4e8e0\u7684\u6574\u6570\r\n\r\n#Q1: Race\r\n#The race function below sometimes returns the wrong value and sometimes runs forever.\r\n\r\ndef race(x, y):\r\n    '''The tortoise always walks x feet per minute, while the hare repeatedly\r\n    runs y feet per minute for 5 minutes, then rests for 5 minutes. Return how\r\n    many minutes pass until the tortoise first catches up to the hare.\r\n\r\n    >>> race(5, 7)  # After 7 minutes, both have gone 35 steps\r\n    7\r\n    >>> race(2, 4) # After 10 minutes, both have gone 20 steps\r\n    10\r\n    '''\r\n    assert y > x and y <= 2 * x, 'the hare must be fast but not too fast'\r\n    tortoise, hare, minutes = 0, 0, 0\r\n    while minutes == 0 or tortoise - hare:\r\n        tortoise += x\r\n        if minutes % 10 < 5:\r\n            hare += y\r\n        minutes += 1\r\n    return minutes\r\n\r\n\r\n# x <= (y - x) * 5 <= 5x \r\n#  1. 6x<=5y\r\n#  3. y <= 2x\r\n# Example: 9 10\r\n\r\n\r\n# Q2: Fizzbuzz\r\n\r\ndef fizzbuzz(n):\r\n    '''\r\n    >>> result = fizzbuzz(16)\r\n    1\r\n    2\r\n    fizz\r\n    4\r\n    buzz\r\n    fizz\r\n    7\r\n    8\r\n    fizz\r\n    buzz\r\n    11\r\n    fizz\r\n    13\r\n    14\r\n    fizzbuzz\r\n    16\r\n    >>> print(result)\r\n    None\r\n    '''\r\n    '*** YOUR CODE HERE ***'\r\n    i = 1\r\n    while i <= n:\r\n        if i % 15 == 0:\r\n            print('fizzbuzz')\r\n        elif i % 3 == 0:\r\n            print('fizz')\r\n        elif i % 5 == 0:\r\n            print('buzz')\r\n        else:\r\n            print(i)\r\n        i += 1\r\n\r\n# Q3: Is Prime?\r\n\r\n\r\ndef is_prime(n):\r\n    '''\r\n    >>> is_prime(10)\r\n    False\r\n    >>> is_prime(7)\r\n    True\r\n    >>> is_prime(1) # one is not a prime number!!\r\n    False\r\n    '''\r\n    # prime number:  A positive integer that is divisible only by 1 and itself\r\n    # 1. determine that n is 1 No\r\n    # 2. iterate from 2 to n\r\n    # 3. if n is divisible by i, False is returned\r\n    # 4. else return True\r\n    assert n > 0, 'the n must be larger than 0'\r\n    if n == 1:\r\n        return False\r\n    i = 2\r\n    while i <= sqrt(n):\r\n        if n % i == 0:\r\n            return False\r\n        i += 1\r\n    return True\r\n\r\n\r\n# Q4: Unique Digits\r\n# Write a function that returns the number of unique digits in a positive integer.\r\n\r\ndef unique_digits(n):\r\n    '''Return the number of unique digits in positive integer n.\r\n\r\n    >>> unique_digits(8675309) # All are unique\r\n    7\r\n    >>> unique_digits(13173131) # 1, 3, and 7\r\n    3\r\n    >>> unique_digits(101) # 0 and 1\r\n    2\r\n    '''\r\n    count, i = 0, 0\r\n    while i <= 9:\r\n        if (has_digit(n, i)):\r\n            count += 1\r\n        i += 1\r\n    return count\r\n\r\n\r\ndef has_digit(n, k):\r\n    '''Returns whether k is a digit in n.\r\n\r\n    >>> has_digit(10, 1)\r\n    True\r\n    >>> has_digit(12, 7)\r\n    False\r\n    '''\r\n    assert k >= 0 and k < 10\r\n    while n > 0:\r\n        if n % 10 == k:\r\n            return True \r\n        n //= 10\r\n    return False\r\n\r\n\r\n# Q5: Ordered Digits\r\n\r\ndef ordered_digits(x):\r\n    '''Return True if the (base 10) digits of X>0 are in non-decreasing\r\n    order, and False otherwise.\r\n\r\n    >>> ordered_digits(5)\r\n    True\r\n    >>> ordered_digits(11)\r\n    True\r\n    >>> ordered_digits(127)\r\n    True\r\n    >>> ordered_digits(1357)\r\n    True\r\n    >>> ordered_digits(21)\r\n    False\r\n    >>> result = ordered_digits(1375) # Return, don't print\r\n    >>> result\r\n    False\r\n\r\n    '''\r\n    while x >= 10:\r\n        if (x % 10 < x // 10 % 10):\r\n            return False\r\n        x //= 10\r\n    return True\r\n\r\n```\u3002", "top": 0, "createdAt": 1723716453, "style": "", "script": "", "head": "", "ogImage": "https://img.icons8.com/doodle/480/mugman.png", "createdDate": "2024-08-15", "dateLabelColor": "#bc4c00"}, "P11": {"htmlDir": "docs/post/cs61a-su24-lab09.html", "labels": ["lab", "cs61a"], "postTitle": "cs61a-su24-lab09", "postUrl": "post/cs61a-su24-lab09.html", "postSourceUrl": "https://github.com/LianSeKong/lizi/issues/11", "commentNum": 0, "wordCount": 1036, "description": "``` python\r\n\r\n(define (over-or-under num1 num2) \r\n      (cond ((= num1 num2) 0)\r\n            ((< num1 num2) -1)\r\n            ((> num1 num2) 1)\r\n      )\r\n)\r\n(define (make-adder num) (lambda (incr) (+ num incr)))\r\n\r\n(define (composed f g) (lambda (x) (f (g x))))\r\n\r\n(define (repeat f n) (lambda (x) (if (= n 0) x ((repeat f (- n 1)) (f x)))))\r\n\r\n(define (max a b)\r\n  (if (> a b)\r\n      a\r\n      b))\r\n\r\n(define (min a b)\r\n  (if (> a b)\r\n      b\r\n      a))\r\n\r\n(define (gcd a b) (if (= 0 (modulo (max a b) (min a b))) (min a b) (gcd (min a b) (modulo (max a b) (min a b)))))\r\n\r\n(define (duplicate lst) \r\n  (if (null? lst)\r\n    lst\r\n    (cons (car lst)\r\n          (cons (car lst) \r\n                (duplicate (cdr lst))\r\n          )\r\n    )\r\n  )\r\n)\r\n\r\n(expect (duplicate '(1 2 3)) (1 1 2 2 3 3))\r\n\r\n(expect (duplicate '(1 1)) (1 1 1 1))\r\n\r\n(define (deep-map fn s) \r\n    (cond ((null? s) s) \r\n          ((list? (car s)) (cons (deep-map fn (car s)) (deep-map fn (cdr s)))) \r\n          (else (cons (fn (car s)) (deep-map fn (cdr s)))) \r\n))\r\n\r\n```\u3002", "top": 0, "createdAt": 1724747169, "style": "", "script": "", "head": "", "ogImage": "https://img.icons8.com/doodle/480/mugman.png", "createdDate": "2024-08-27", "dateLabelColor": "#bc4c00"}, "P12": {"htmlDir": "docs/post/cs61a-su24-lab09.html", "labels": ["lab", "cs61a"], "postTitle": "cs61a-su24-lab09", "postUrl": "post/cs61a-su24-lab09.html", "postSourceUrl": "https://github.com/LianSeKong/lizi/issues/12", "commentNum": 0, "wordCount": 1036, "description": "``` python\r\n\r\n(define (over-or-under num1 num2) \r\n      (cond ((= num1 num2) 0)\r\n            ((< num1 num2) -1)\r\n            ((> num1 num2) 1)\r\n      )\r\n)\r\n(define (make-adder num) (lambda (incr) (+ num incr)))\r\n\r\n(define (composed f g) (lambda (x) (f (g x))))\r\n\r\n(define (repeat f n) (lambda (x) (if (= n 0) x ((repeat f (- n 1)) (f x)))))\r\n\r\n(define (max a b)\r\n  (if (> a b)\r\n      a\r\n      b))\r\n\r\n(define (min a b)\r\n  (if (> a b)\r\n      b\r\n      a))\r\n\r\n(define (gcd a b) (if (= 0 (modulo (max a b) (min a b))) (min a b) (gcd (min a b) (modulo (max a b) (min a b)))))\r\n\r\n(define (duplicate lst) \r\n  (if (null? lst)\r\n    lst\r\n    (cons (car lst)\r\n          (cons (car lst) \r\n                (duplicate (cdr lst))\r\n          )\r\n    )\r\n  )\r\n)\r\n\r\n(expect (duplicate '(1 2 3)) (1 1 2 2 3 3))\r\n\r\n(expect (duplicate '(1 1)) (1 1 1 1))\r\n\r\n(define (deep-map fn s) \r\n    (cond ((null? s) s) \r\n          ((list? (car s)) (cons (deep-map fn (car s)) (deep-map fn (cdr s)))) \r\n          (else (cons (fn (car s)) (deep-map fn (cdr s)))) \r\n))\r\n\r\n```\u3002", "top": 0, "createdAt": 1724747481, "style": "", "script": "", "head": "", "ogImage": "https://img.icons8.com/doodle/480/mugman.png", "createdDate": "2024-08-27", "dateLabelColor": "#bc4c00"}, "P13": {"htmlDir": "docs/post/cs61a-su24-hw.html", "labels": ["cs61a", "hw"], "postTitle": "cs61a-su24-hw", "postUrl": "post/cs61a-su24-hw.html", "postSourceUrl": "https://github.com/LianSeKong/lizi/issues/13", "commentNum": 0, "wordCount": 42539, "description": "# CS61 Summer2024  homework \r\n\r\n\r\n\r\n## hw01\r\n\r\n\r\n\r\n```python\r\nfrom operator import add, sub\r\n\r\ndef a_plus_abs_b(a, b):\r\n    '''Return a+abs(b), but without calling abs.\r\n\r\n    >>> a_plus_abs_b(2, 3)\r\n    5\r\n    >>> a_plus_abs_b(2, -3)\r\n    5\r\n    >>> a_plus_abs_b(-1, 4)\r\n    3\r\n    >>> a_plus_abs_b(-1, -4)\r\n    3\r\n    '''\r\n    if b < 0:\r\n        f = sub\r\n    else:\r\n        f = add\r\n    return f(a, b)\r\n\r\n\r\ndef two_of_three(i, j, k):\r\n    '''Return m*m + n*n, where m and n are the two smallest members of the\r\n    positive numbers i, j, and k.\r\n\r\n    >>> two_of_three(1, 2, 3)\r\n    5\r\n    >>> two_of_three(5, 3, 1)\r\n    10\r\n    >>> two_of_three(10, 2, 8)\r\n    68\r\n    >>> two_of_three(5, 5, 5)\r\n    50\r\n    '''\r\n    return i ** 2 + j ** 2 + k ** 2 - max(i, j, k) ** 2\r\n\r\n\r\n\r\ndef largest_factor(n):\r\n    '''Return the largest factor of n that is smaller than n.\r\n\r\n    >>> largest_factor(15) # factors are 1, 3, 5\r\n    5\r\n    >>> largest_factor(80) # factors are 1, 2, 4, 5, 8, 10, 16, 20, 40\r\n    40\r\n    >>> largest_factor(13) # factor is 1 since 13 is prime\r\n    1\r\n    '''\r\n    i = n - 1\r\n    while i >= 1:\r\n        if n % i == 0: \r\n            return i\r\n        i = i -1    \r\n\r\n\r\n\r\ndef hailstone(n):\r\n    '''Print the hailstone sequence starting at n and return its\r\n    length.\r\n\r\n    >>> a = hailstone(10)\r\n    10\r\n    5\r\n    16\r\n    8\r\n    4\r\n    2\r\n    1\r\n    >>> a\r\n    7\r\n    >>> b = hailstone(1)\r\n    1\r\n    >>> b\r\n    1\r\n    '''\r\n    length = 1\r\n    while n != 1:\r\n        print(n)\r\n        if n % 2 == 0:\r\n            n = n //2\r\n        else:\r\n            n = 3 * n + 1\r\n        length = length + 1\r\n    print(n)\r\n    return length\r\n```\r\n\r\n## hw02\r\n\r\n```python\r\nfrom operator import add, mul, sub\r\n\r\nsquare = lambda x: x * x\r\n\r\nidentity = lambda x: x\r\n\r\ntriple = lambda x: 3 * x\r\n\r\nincrement = lambda x: x + 1\r\n\r\n\r\nHW_SOURCE_FILE=__file__\r\n\r\n\r\ndef product(n, term):\r\n    '''Return the product of the first n terms in a sequence.\r\n\r\n    n: a positive integer\r\n    term:  a function that takes one argument to produce the term\r\n\r\n    >>> product(3, identity)  # 1 * 2 * 3\r\n    6\r\n    >>> product(5, identity)  # 1 * 2 * 3 * 4 * 5\r\n    120\r\n    >>> product(3, square)    # 1^2 * 2^2 * 3^2\r\n    36\r\n    >>> product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2\r\n    14400\r\n    >>> product(3, increment) # (1+1) * (2+1) * (3+1)\r\n    24\r\n    >>> product(3, triple)    # 1*3 * 2*3 * 3*3\r\n    162\r\n    '''\r\n    i, product_result = 1, 1\r\n    while i <= n:\r\n        product_result, i = product_result * term(i), i + 1\r\n    return product_result\r\n\r\n\r\ndef accumulate(fuse, start, n, term):\r\n    '''Return the result of fusing together the first n terms in a sequence \r\n    and start.  The terms to be fused are term(1), term(2), ..., term(n). \r\n    The function fuse is a two-argument commutative & associative function.\r\n\r\n    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5\r\n    15\r\n    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5\r\n    26\r\n    >>> accumulate(add, 11, 0, identity) # 11 (fuse is never used)\r\n    11\r\n    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2\r\n    25\r\n    >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2\r\n    72\r\n    >>> # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1)\r\n    >>> accumulate(lambda x, y: x + y + 1, 2, 3, square)\r\n    19\r\n    '''\r\n    i = 1\r\n    product_result = start\r\n    while i <= n:\r\n        product_result = fuse(product_result, term(i))\r\n        i = i + 1\r\n    return product_result\r\n\r\n\r\ndef summation_using_accumulate(n, term):\r\n    '''Returns the sum: term(1) + ... + term(n), using accumulate.\r\n\r\n    >>> summation_using_accumulate(5, square) # square(0) + square(1) + ... + square(4) + square(5)\r\n    55\r\n    >>> summation_using_accumulate(5, triple) # triple(0) + triple(1) + ... + triple(4) + triple(5)\r\n    45\r\n    >>> # This test checks that the body of the function is just a return statement.\r\n    >>> import inspect, ast\r\n    >>> [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body]\r\n    ['Expr', 'Return']\r\n    '''\r\n    return accumulate(add, term(0), n, term)\r\n\r\n\r\ndef product_using_accumulate(n, term):\r\n    '''Returns the product: term(1) * ... * term(n), using accumulate.\r\n\r\n    >>> product_using_accumulate(4, square) # square(1) * square(2) * square(3) * square()\r\n    576\r\n    >>> product_using_accumulate(6, triple) # triple(1) * triple(2) * ... * triple(5) * triple(6)\r\n    524880\r\n    >>> # This test checks that the body of the function is just a return statement.\r\n    >>> import inspect, ast\r\n    >>> [type(x).__name__ for x in ast.parse(inspect.getsource(product_using_accumulate)).body[0].body]\r\n    ['Expr', 'Return']\r\n    '''\r\n    return accumulate(mul,1,n,term)\r\n\r\n\r\ndef make_repeater(f, n):\r\n    '''Returns the function that computes the nth application of f.\r\n\r\n    >>> add_three = make_repeater(increment, 3)\r\n    >>> add_three(5)\r\n    8\r\n    >>> make_repeater(triple, 5)(1) # 3 * (3 * (3 * (3 * (3 * 1))))\r\n    243\r\n    >>> make_repeater(square, 2)(5) # square(square(5))\r\n    625\r\n    >>> make_repeater(square, 3)(5) # square(square(square(5)))\r\n    390625\r\n    '''\r\n    def repeater(x):\r\n            k = 0\r\n            while k < n:\r\n                x, k = f(x), k + 1\r\n            return x\r\n    return repeater \r\n\r\n\r\ndef digit_distance(n):\r\n    '''Determines the digit distance of n.\r\n\r\n    >>> digit_distance(3)\r\n    0\r\n    >>> digit_distance(777)\r\n    0\r\n    >>> digit_distance(314)\r\n    5\r\n    >>> digit_distance(31415926535)\r\n    32\r\n    >>> digit_distance(3464660003)\r\n    16\r\n    >>> from construct_check import check\r\n    >>> # ban all loops\r\n    >>> check(HW_SOURCE_FILE, 'digit_distance',\r\n    ...       ['For', 'While'])\r\n    True\r\n    '''\r\n    if n < 10:\r\n        return 0\r\n    else:\r\n        return abs(sub(n % 10, n // 10 % 10)) + digit_distance(n // 10)\r\n\r\n\r\ndef interleaved_sum(n, odd_func, even_func):\r\n    '''Compute the sum odd_func(1) + even_func(2) + odd_func(3) + ..., up\r\n    to n.\r\n\r\n    >>> identity = lambda x: x\r\n    >>> square = lambda x: x * x\r\n    >>> triple = lambda x: x * 3\r\n    >>> interleaved_sum(5, identity, square) # 1   + 2*2 + 3   + 4*4 + 5\r\n    29\r\n    >>> interleaved_sum(5, square, identity) # 1*1 + 2   + 3*3 + 4   + 5*5\r\n    41\r\n    >>> interleaved_sum(4, triple, square)   # 1*3 + 2*2 + 3*3 + 4*4\r\n    32\r\n    >>> interleaved_sum(4, square, triple)   # 1*1 + 2*3 + 3*3 + 4*3\r\n    28\r\n    >>> from construct_check import check\r\n    >>> check(HW_SOURCE_FILE, 'interleaved_sum', ['While', 'For', 'Mod']) # ban loops and %\r\n    True\r\n    >>> check(HW_SOURCE_FILE, 'interleaved_sum', ['BitAnd', 'BitOr', 'BitXor']) # ban bitwise operators, don't worry about these if you don't know what they are\r\n    True\r\n    '''\r\n\r\n    if n == 0:\r\n        return 0\r\n    elif n % 2 == 1:\r\n        return odd_func(n) + interleaved_sum(n - 1, odd_func, even_func)\r\n    else:\r\n        return even_func(n) + interleaved_sum(n - 1, odd_func, even_func)\r\n\r\n\r\ndef next_larger_coin(coin):\r\n    '''Returns the next larger coin in order.\r\n    >>> next_larger_coin(1)\r\n    5\r\n    >>> next_larger_coin(5)\r\n    10\r\n    >>> next_larger_coin(10)\r\n    25\r\n    >>> next_larger_coin(2) # Other values return None\r\n    '''\r\n    if coin == 1:\r\n        return 5\r\n    elif coin == 5:\r\n        return 10\r\n    elif coin == 10:\r\n        return 25\r\n\r\ndef next_smaller_coin(coin):\r\n    '''Returns the next smaller coin in order.\r\n    >>> next_smaller_coin(25)\r\n    10\r\n    >>> next_smaller_coin(10)\r\n    5\r\n    >>> next_smaller_coin(5)\r\n    1\r\n    >>> next_smaller_coin(2) # Other values return None\r\n    '''\r\n    if coin == 25:\r\n        return 10\r\n    elif coin == 10:\r\n        return 5\r\n    elif coin == 5:\r\n        return 1\r\n\r\ndef count_coins(total):\r\n    '''Return the number of ways to make change using coins of value of 1, 5, 10, 25.\r\n    >>> count_coins(15)\r\n    6\r\n    >>> count_coins(10)\r\n    4\r\n    >>> count_coins(20)\r\n    9\r\n    >>> count_coins(100) # How many ways to make change for a dollar?\r\n    242\r\n    >>> count_coins(200)\r\n    1463\r\n    >>> from construct_check import check\r\n    >>> # ban iteration\r\n    >>> check(HW_SOURCE_FILE, 'count_coins', ['While', 'For'])\r\n    True\r\n    '''\r\n                                        \r\n    def helper(total, coin):\r\n        if total == 0:\r\n            return 1\r\n        if total < 0 or not coin :\r\n            return 0\r\n        return helper(total - coin,coin) + helper(total, next_smaller_coin(coin))\r\n    return helper(total, 25)\r\n```\r\n\r\n## hw03\r\n\r\n\r\n\r\n```python\r\n\r\nHW_SOURCE_FILE=__file__\r\n\r\n\r\ndef pascal(row, column):\r\n    '''Returns the value of the item in Pascal's Triangle\r\n    whose position is specified by row and column.\r\n    >>> pascal(0, 0)    # The top left (the point of the triangle)\r\n    1\r\n    >>> pascal(0, 5)\t# Empty entry; outside of Pascal's Triangle\r\n    0\r\n    >>> pascal(3, 2)\t# Row 3 (1 3 3 1), Column 2\r\n    3\r\n    >>> pascal(4, 2)     # Row 4 (1 4 6 4 1), Column 2\r\n    6\r\n    '''\r\n    if column == 0:\r\n        return 1\r\n    elif row == 0:\r\n        return 0\r\n    else:\r\n        return pascal(row - 1, column) + pascal(row - 1, column - 1)\r\n\r\ndef insert_items(s, before, after):\r\n    '''Insert after into s after each occurrence of before and then return s.\r\n\r\n    >>> test_s = [1, 5, 8, 5, 2, 3]\r\n    >>> new_s = insert_items(test_s, 5, 7)\r\n    >>> new_s\r\n    [1, 5, 7, 8, 5, 7, 2, 3]\r\n    >>> test_s\r\n    [1, 5, 7, 8, 5, 7, 2, 3]\r\n    >>> new_s is test_s\r\n    True\r\n    >>> double_s = [1, 2, 1, 2, 3, 3]\r\n    >>> double_s = insert_items(double_s, 3, 4)\r\n    >>> double_s\r\n    [1, 2, 1, 2, 3, 4, 3, 4]\r\n    >>> large_s = [1, 4, 8]\r\n    >>> large_s2 = insert_items(large_s, 4, 4)\r\n    >>> large_s2\r\n    [1, 4, 4, 8]\r\n    >>> large_s3 = insert_items(large_s2, 4, 6)\r\n    >>> large_s3\r\n    [1, 4, 6, 4, 6, 8]\r\n    >>> large_s3 is large_s\r\n    True\r\n    '''\r\n    i = 0\r\n    while i < len(s):\r\n        if s[i] == before:\r\n            s.insert(i + 1, after)\r\n            i += 1\r\n        i += 1\r\n    return s\r\n\r\n\r\nHW_SOURCE_FILE=__file__\r\n\r\n\r\ndef planet(mass):\r\n    '''Construct a planet of some mass.'''\r\n    assert mass > 0\r\n\r\n    return ['planet', mass]\r\ndef mass(p):\r\n    '''Select the mass of a planet.'''\r\n    assert is_planet(p), 'must call mass on a planet'\r\n    return p[1]\r\n\r\n\r\ndef is_planet(p):\r\n    '''Whether p is a planet.'''\r\n    return type(p) == list and len(p) == 2 and p[0] == 'planet'\r\n\r\ndef examples():\r\n    t = mobile(arm(1, planet(2)),\r\n               arm(2, planet(1)))\r\n    u = mobile(arm(5, planet(1)),\r\n               arm(1, mobile(arm(2, planet(3)),\r\n                             arm(3, planet(2)))))\r\n    v = mobile(arm(4, t), arm(2, u))\r\n    return t, u, v\r\n\r\ndef total_mass(m):\r\n    '''Return the total mass of m, a planet or mobile.\r\n\r\n    >>> t, u, v = examples()\r\n    >>> total_mass(t)\r\n    3\r\n    >>> total_mass(u)\r\n    6\r\n    >>> total_mass(v)\r\n    9\r\n    '''\r\n    if is_planet(m):\r\n        return mass(m)\r\n    else:\r\n        assert is_mobile(m), 'must get total mass of a mobile or a planet'\r\n        return total_mass(end(left(m))) + total_mass(end(right(m)))\r\n\r\ndef balanced(m):\r\n    '''Return whether m is balanced.\r\n\r\n    >>> t, u, v = examples()\r\n    >>> balanced(t)\r\n    True\r\n    >>> balanced(v)\r\n    True\r\n    >>> p = mobile(arm(3, t), arm(2, u))\r\n    >>> balanced(p)\r\n    False\r\n    >>> balanced(mobile(arm(1, v), arm(1, p)))\r\n    False\r\n    >>> balanced(mobile(arm(1, p), arm(1, v)))\r\n    False\r\n    >>> from construct_check import check\r\n    >>> # checking for abstraction barrier violations by banning indexing\r\n    >>> check(HW_SOURCE_FILE, 'balanced', ['Index'])\r\n    True\r\n    '''\r\n    if is_planet(m):\r\n        return True\r\n    else:\r\n        left_end, right_end = end(left(m)), end(right(m))\r\n        torque_left = length(left(m)) * total_mass(left_end)\r\n        torque_right = length(right(m)) * total_mass(right_end)\r\n        return torque_left == torque_right and balanced(left_end) and balanced(right_end)\r\n\r\ndef berry_finder(t):\r\n    '''Returns True if t contains a node with the value 'berry' and \r\n    False otherwise.\r\n\r\n    >>> scrat = tree('berry')\r\n    >>> berry_finder(scrat)\r\n    True\r\n    >>> sproul = tree('roots', [tree('branch1', [tree('leaf'), tree('berry')]), tree('branch2')])\r\n    >>> berry_finder(sproul)\r\n    True\r\n    >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])\r\n    >>> berry_finder(numbers)\r\n    False\r\n    >>> t = tree(1, [tree('berry',[tree('not berry')])])\r\n    >>> berry_finder(t)\r\n    True\r\n    '''\r\n    if label(t) == 'berry':\r\n        return True\r\n    \r\n    return len([x for x in branches(t) if berry_finder(x) == True]) > 0\r\n\r\n\r\nHW_SOURCE_FILE=__file__\r\n\r\n\r\ndef max_path_sum(t):\r\n    '''Return the maximum root-to-leaf path sum of a tree.\r\n    >>> t = tree(1, [tree(5, [tree(1), tree(3)]), tree(10)])\r\n    >>> max_path_sum(t) # 1, 10\r\n    11\r\n    >>> t2 = tree(5, [tree(4, [tree(1), tree(3)]), tree(2, [tree(10), tree(3)])])\r\n    >>> max_path_sum(t2) # 5, 2, 10\r\n    17\r\n    '''\r\n    if is_leaf(t):\r\n        return label(t)\r\n    \r\n    return max([max_path_sum(i) for i in branches(t)]) + label(t)\r\n\r\n\r\ndef print_move(origin, destination):\r\n    '''Print instructions to move a disk.'''\r\n    print('Move the top disk from rod', origin, 'to rod', destination)\r\n\r\ndef move_stack(n, start, end):\r\n    '''Print the moves required to move n disks on the start pole to the end\r\n    pole without violating the rules of Towers of Hanoi.\r\n\r\n    n -- number of disks\r\n    start -- a pole position, either 1, 2, or 3\r\n    end -- a pole position, either 1, 2, or 3\r\n\r\n    There are exactly three poles, and start and end must be different. Assume\r\n    that the start pole has at least n disks of increasing size, and the end\r\n    pole is either empty or has a top disk larger than the top n start disks.\r\n\r\n    >>> move_stack(1, 1, 3)\r\n    Move the top disk from rod 1 to rod 3\r\n    >>> move_stack(2, 1, 3)\r\n    Move the top disk from rod 1 to rod 2\r\n    Move the top disk from rod 1 to rod 3\r\n    Move the top disk from rod 2 to rod 3\r\n    >>> move_stack(3, 1, 3)\r\n    Move the top disk from rod 1 to rod 3\r\n    Move the top disk from rod 1 to rod 2\r\n    Move the top disk from rod 3 to rod 2\r\n    Move the top disk from rod 1 to rod 3\r\n    Move the top disk from rod 2 to rod 1\r\n    Move the top disk from rod 2 to rod 3\r\n    Move the top disk from rod 1 to rod 3\r\n    '''\r\n    assert 1 <= start <= 3 and 1 <= end <= 3 and start != end, 'Bad start/end'\r\n    if n == 1:\r\n        print_move(start, end)\r\n    else: \r\n        move_stack(n - 1, start, 6 - start - end)\r\n        move_stack(1, start, end)\r\n        move_stack(n - 1, 6 - start - end, end)\r\n\r\nfrom operator import sub, mul\r\n\r\ndef make_anonymous_factorial():\r\n    '''Return the value of an expression that computes factorial.\r\n\r\n    >>> make_anonymous_factorial()(5)\r\n    120\r\n    >>> from construct_check import check\r\n    >>> # ban any assignments or recursion\r\n    >>> check(HW_SOURCE_FILE, 'make_anonymous_factorial',\r\n    ...     ['Assign', 'AnnAssign', 'AugAssign', 'NamedExpr', 'FunctionDef', 'Recursion'])\r\n    True\r\n    '''\r\n    return (lambda f: lambda k: f(f, k))(lambda f, k: k if k == 1 else mul(k, f(f, sub(k, 1))))\r\n\r\n\r\ndef mobile(left, right):\r\n    '''Construct a mobile from a left arm and a right arm.'''\r\n    assert is_arm(left), 'left must be an arm'\r\n    assert is_arm(right), 'right must be an arm'\r\n    return ['mobile', left, right]\r\n\r\ndef is_mobile(m):\r\n    '''Return whether m is a mobile.'''\r\n    return type(m) == list and len(m) == 3 and m[0] == 'mobile'\r\n\r\ndef left(m):\r\n    '''Select the left arm of a mobile.'''\r\n    assert is_mobile(m), 'must call left on a mobile'\r\n    return m[1]\r\n\r\ndef right(m):\r\n    '''Select the right arm of a mobile.'''\r\n    assert is_mobile(m), 'must call right on a mobile'\r\n    return m[2]\r\n\r\ndef arm(length, mobile_or_planet):\r\n    '''Construct an arm: a length of rod with a mobile or planet at the end.'''\r\n    assert is_mobile(mobile_or_planet) or is_planet(mobile_or_planet)\r\n    return ['arm', length, mobile_or_planet]\r\n\r\ndef is_arm(s):\r\n    '''Return whether s is an arm.'''\r\n    return type(s) == list and len(s) == 3 and s[0] == 'arm'\r\n\r\ndef length(s):\r\n    '''Select the length of an arm.'''\r\n    assert is_arm(s), 'must call length on an arm'\r\n    return s[1]\r\n\r\ndef end(s):\r\n    '''Select the mobile or planet hanging at the end of an arm.'''\r\n    assert is_arm(s), 'must call end on an arm'\r\n    return s[2]\r\n\r\n\r\n\r\n# Tree Data Abstraction\r\n\r\ndef tree(label, branches=[]):\r\n    '''Construct a tree with the given label value and a list of branches.'''\r\n    for branch in branches:\r\n        assert is_tree(branch), 'branches must be trees'\r\n    return [label] + list(branches)\r\n\r\ndef label(tree):\r\n    '''Return the label value of a tree.'''\r\n    return tree[0]\r\n\r\ndef branches(tree):\r\n    '''Return the list of branches of the given tree.'''\r\n    return tree[1:]\r\n\r\ndef is_tree(tree):\r\n    '''Returns True if the given tree is a tree, and False otherwise.'''\r\n    if type(tree) != list or len(tree) < 1:\r\n        return False\r\n    for branch in branches(tree):\r\n        if not is_tree(branch):\r\n            return False\r\n    return True\r\n\r\ndef is_leaf(tree):\r\n    '''Returns True if the given tree's list of branches is empty, and False\r\n    otherwise.\r\n    '''\r\n    return not branches(tree)\r\n\r\ndef print_tree(t, indent=0):\r\n    '''Print a representation of this tree in which each node is\r\n    indented by two spaces times its depth from the root.\r\n\r\n    >>> print_tree(tree(1))\r\n    1\r\n    >>> print_tree(tree(1, [tree(2)]))\r\n    1\r\n      2\r\n    >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])\r\n    >>> print_tree(numbers)\r\n    1\r\n      2\r\n      3\r\n        4\r\n        5\r\n      6\r\n        7\r\n    '''\r\n    print('  ' * indent + str(label(t)))\r\n    for b in branches(t):\r\n        print_tree(b, indent + 1)\r\n\r\ndef copy_tree(t):\r\n    '''Returns a copy of t. Only for testing purposes.\r\n\r\n    >>> t = tree(5)\r\n    >>> copy = copy_tree(t)\r\n    >>> t = tree(6)\r\n    >>> print_tree(copy)\r\n    5\r\n    '''\r\n    return tree(label(t), [copy_tree(b) for b in branches(t)])\r\n\r\n```\r\n\r\n\r\n\r\n## hw04\r\n\r\n\r\n\r\n```python\r\ndef hailstone(n):\r\n    '''Q1: Yields the elements of the hailstone sequence starting at n.\r\n       At the end of the sequence, yield 1 infinitely.\r\n\r\n    >>> hail_gen = hailstone(10)\r\n    >>> [next(hail_gen) for _ in range(10)]\r\n    [10, 5, 16, 8, 4, 2, 1, 1, 1, 1]\r\n    >>> next(hail_gen)\r\n    1\r\n    '''\r\n    yield n\r\n    if n == 1:\r\n       yield from hailstone(1)\r\n    elif n % 2 == 1: \r\n        yield from hailstone(n * 3 + 1)\r\n    else:\r\n        yield from hailstone(n // 2)\r\n\r\n\r\ndef merge(a, b):\r\n    '''Q2:\r\n    >>> def sequence(start, step):\r\n    ...     while True:\r\n    ...         yield start\r\n    ...         start += step\r\n    >>> a = sequence(2, 3) # 2, 5, 8, 11, 14, ...\r\n    >>> b = sequence(3, 2) # 3, 5, 7, 9, 11, 13, 15, ...\r\n    >>> result = merge(a, b) # 2, 3, 5, 7, 8, 9, 11, 13, 14, 15\r\n    >>> [next(result) for _ in range(10)]\r\n    [2, 3, 5, 7, 8, 9, 11, 13, 14, 15]\r\n    '''\r\n    first_a, first_b = next(a), next(b)\r\n    while True:\r\n        if first_a == first_b:\r\n            yield first_a\r\n            first_a, first_b = next(a), next(b)\r\n        elif first_a < first_b:\r\n            yield first_a\r\n            first_a = next(a)\r\n        else:\r\n            yield first_b\r\n            first_b = next(b)\r\n\r\ndef perms(seq):\r\n    '''Q3: Generates all permutations of the given sequence. Each permutation is a\r\n    list of the elements in SEQ in a different order. The permutations may be\r\n    yielded in any order.\r\n\r\n    >>> p = perms([100])\r\n    >>> type(p)\r\n    <class 'generator'>\r\n    >>> next(p)\r\n    [100]\r\n    >>> try: # Prints 'No more permutations!' if calling next would cause an error\r\n    ...     next(p)\r\n    ... except StopIteration:\r\n    ...     print('No more permutations!')\r\n    No more permutations!\r\n    >>> sorted(perms([1, 2, 3])) # Returns a sorted list containing elements of the generator\r\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\r\n    >>> sorted(perms((10, 20, 30)))\r\n    [[10, 20, 30], [10, 30, 20], [20, 10, 30], [20, 30, 10], [30, 10, 20], [30, 20, 10]]\r\n    >>> sorted(perms('ab'))\r\n    [['a', 'b'], ['b', 'a']]\r\n    '''\r\n    if len(seq) == 1:\r\n        yield [seq[0]]\r\n    else:\r\n        for i in range(len(seq)):\r\n            lst = list(perms(seq[:i] + seq[(i + 1):]))\r\n            for it in lst:\r\n                it.append(seq[i]) \r\n                yield it\r\n\r\n\r\n\r\n\r\ndef yield_paths(t, value):\r\n    '''Q4: Yields all possible paths from the root of t to a node with the label\r\n    value as a list.\r\n\r\n    >>> t1 = tree(1, [tree(2, [tree(3), tree(4, [tree(6)]), tree(5)]), tree(5)])\r\n    >>> print_tree(t1)\r\n    1\r\n      2\r\n        3\r\n        4\r\n          6\r\n        5\r\n      5\r\n    >>> next(yield_paths(t1, 6))\r\n    [1, 2, 4, 6]\r\n    >>> path_to_5 = yield_paths(t1, 5)\r\n    >>> sorted(list(path_to_5))\r\n    [[1, 2, 5], [1, 5]]\r\n\r\n    >>> t2 = tree(0, [tree(2, [t1])])\r\n    >>> print_tree(t2)\r\n    0\r\n      2\r\n        1\r\n          2\r\n            3\r\n            4\r\n              6\r\n            5\r\n          5\r\n    >>> path_to_2 = yield_paths(t2, 2)\r\n    >>> sorted(list(path_to_2))\r\n    [[0, 2], [0, 2, 1, 2]]\r\n    '''\r\n    if label(t) == value:\r\n        yield [label(t)]\r\n    for b in branches(t):\r\n        for path in list(yield_paths(b, value)):\r\n            yield [label(t)] + path\r\n\r\n\r\nclass Minty:\r\n    '''A mint creates coins by stamping on years. The update method sets the mint's stamp to Minty.present_year.\r\n    >>> mint = Minty()\r\n    >>> mint.year\r\n    2021\r\n    >>> dime = mint.create('Dime')\r\n    >>> dime.year\r\n    2021\r\n    >>> Minty.present_year = 2101  # Time passes\r\n    >>> nickel = mint.create('Nickel')\r\n    >>> nickel.year     # The mint has not updated its stamp yet\r\n    2021\r\n    >>> nickel.worth()  # 5 cents + (80 - 50 years)\r\n    35\r\n    >>> mint.update()   # The mint's year is updated to 2101\r\n    >>> Minty.present_year = 2176     # More time passes\r\n    >>> mint.create('Dime').worth()    # 10 cents + (75 - 50 years)\r\n    35\r\n    >>> Minty().create('Dime').worth()  # A new mint has the current year\r\n    10\r\n    >>> dime.worth()     # 10 cents + (155 - 50 years)\r\n    115\r\n    '''\r\n    present_year = 2021\r\n\r\n    def __init__(self):\r\n        self.update()\r\n\r\n    def create(self, type):\r\n        return Coin(self.year, type)\r\n\r\n    def update(self):\r\n        self.year = Minty.present_year\r\n\r\nclass Coin:\r\n    cents = 50\r\n\r\n    def __init__(self, year, type):\r\n        self.year = year\r\n        if type == ('Dime'):\r\n            self.cents = 10\r\n        elif type == ('Nickel'):\r\n            self.cents = 5\r\n\r\n    def worth(self):\r\n        return self.cents + max(0, Minty.present_year - self.year - 50)\r\n\r\n\r\nclass VendingMachine:\r\n    '''A vending machine that vends some product for some price.\r\n\r\n    >>> v = VendingMachine('candy', 10)\r\n    >>> v.vend()\r\n    'Nothing left to vend. Please restock.'\r\n    >>> v.add_funds(15)\r\n    'Nothing left to vend. Please restock. Here is your $15.'\r\n    >>> v.restock(2)\r\n    'Current candy stock: 2'\r\n    >>> v.vend()\r\n    'Please add $10 more funds.'\r\n    >>> v.add_funds(7)\r\n    'Current balance: $7'\r\n    >>> v.vend()\r\n    'Please add $3 more funds.'\r\n    >>> v.add_funds(5)\r\n    'Current balance: $12'\r\n    >>> v.vend()\r\n    'Here is your candy and $2 change.'\r\n    >>> v.add_funds(10)\r\n    'Current balance: $10'\r\n    >>> v.vend()\r\n    'Here is your candy.'\r\n    >>> v.add_funds(15)\r\n    'Nothing left to vend. Please restock. Here is your $15.'\r\n\r\n    >>> w = VendingMachine('soda', 2)\r\n    >>> w.restock(3)\r\n    'Current soda stock: 3'\r\n    >>> w.restock(3)\r\n    'Current soda stock: 6'\r\n    >>> w.add_funds(2)\r\n    'Current balance: $2'\r\n    >>> w.vend()\r\n    'Here is your soda.'\r\n    '''\r\n    def __init__(self, name, price):\r\n        self.name = name\r\n        self.price = price\r\n        self.balance = 0\r\n        self.inventory = 0\r\n    def vend(self):\r\n        if self.inventory == 0:\r\n            return 'Nothing left to vend. Please restock.'\r\n        elif self.balance < self.price:\r\n            return  f'Please add ${self.price - self.balance} more funds.'\r\n        elif self.balance > self.price:\r\n            self.inventory -= 1\r\n            exchange = self.balance - self.price\r\n            self.balance = 0\r\n            return f'Here is your {self.name} and ${exchange} change.'\r\n        else:\r\n            self.balance = 0\r\n            self.inventory -= 1\r\n            return f'Here is your {self.name}.'\r\n    def add_funds(self, funds):\r\n        if self.inventory == 0:\r\n            return f'Nothing left to vend. Please restock. Here is your ${funds}.'\r\n        else:\r\n            self.balance += funds\r\n            return f'Current balance: ${self.balance}'\r\n    def restock(self, inventory):\r\n        self.inventory += inventory\r\n        return f'Current {self.name} stock: {self.inventory}'\r\n\r\n# Tree Data Abstraction\r\n\r\ndef tree(label, branches=[]):\r\n    '''Construct a tree with the given label value and a list of branches.'''\r\n    for branch in branches:\r\n        assert is_tree(branch), 'branches must be trees'\r\n    return [label] + list(branches)\r\n\r\ndef label(tree):\r\n    '''Return the label value of a tree.'''\r\n    return tree[0]\r\n\r\ndef branches(tree):\r\n    '''Return the list of branches of the given tree.'''\r\n    return tree[1:]\r\n\r\ndef is_tree(tree):\r\n    '''Returns True if the given tree is a tree, and False otherwise.'''\r\n    if type(tree) != list or len(tree) < 1:\r\n        return False\r\n    for branch in branches(tree):\r\n        if not is_tree(branch):\r\n            return False\r\n    return True\r\n\r\ndef is_leaf(tree):\r\n    '''Returns True if the given tree's list of branches is empty, and False\r\n    otherwise.\r\n    '''\r\n    return not branches(tree)\r\n\r\ndef print_tree(t, indent=0):\r\n    '''Print a representation of this tree in which each node is\r\n    indented by two spaces times its depth from the root.\r\n\r\n    >>> print_tree(tree(1))\r\n    1\r\n    >>> print_tree(tree(1, [tree(2)]))\r\n    1\r\n      2\r\n    >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])\r\n    >>> print_tree(numbers)\r\n    1\r\n      2\r\n      3\r\n        4\r\n        5\r\n      6\r\n        7\r\n    '''\r\n    print('  ' * indent + str(label(t)))\r\n    for b in branches(t):\r\n        print_tree(b, indent + 1)\r\n\r\ndef copy_tree(t):\r\n    '''Returns a copy of t. Only for testing purposes.\r\n\r\n    >>> t = tree(5)\r\n    >>> copy = copy_tree(t)\r\n    >>> t = tree(6)\r\n    >>> print_tree(copy)\r\n    5\r\n    '''\r\n    return tree(label(t), [copy_tree(b) for b in branches(t)])\r\n\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## hw05\r\n\r\n\r\n\r\n```python\r\n# You do not need to understand what this function does. It is used for testing.\r\ndef make_test_random():\r\n    '''A deterministic random function that cycles between\r\n    [0.0, 0.1, 0.2, ..., 0.9] for testing purposes.\r\n\r\n    >>> random = make_test_random()\r\n    >>> random()\r\n    0.0\r\n    >>> random()\r\n    0.1\r\n    >>> random2 = make_test_random()\r\n    >>> random2()\r\n    0.0\r\n    '''\r\n    rands = [x / 10 for x in range(10)]\r\n    def random():\r\n        rand = rands[0]\r\n        rands.append(rands.pop(0))\r\n        return rand\r\n    return random\r\n\r\n### Phase 1: The Player Class\r\nclass Player:\r\n    '''\r\n    >>> random = make_test_random()\r\n    >>> p1 = Player('Hill', random)\r\n    >>> p2 = Player('Don', random)\r\n    >>> p1.popularity\r\n    100\r\n    >>> p1.debate(p2)  # random() should return 0.0\r\n    >>> p1.popularity\r\n    150\r\n    >>> p2.popularity\r\n    100\r\n    >>> p2.votes\r\n    0\r\n    >>> p2.speech(p1)\r\n    >>> p2.votes\r\n    10\r\n    >>> p2.popularity\r\n    110\r\n    >>> p1.popularity\r\n    135\r\n    >>> p1.speech(p2)\r\n    >>> p1.votes\r\n    13\r\n    >>> p1.popularity\r\n    148\r\n    >>> p2.votes\r\n    10\r\n    >>> p2.popularity\r\n    99\r\n    >>> for _ in range(4):  # 0.1, 0.2, 0.3, 0.4\r\n    ...     p1.debate(p2)\r\n    >>> p2.debate(p1)\r\n    >>> p2.popularity\r\n    49\r\n    >>> p2.debate(p1)\r\n    >>> p2.popularity\r\n    0\r\n    '''\r\n    def __init__(self, name, random_func):\r\n        self.name = name\r\n        self.votes = 0\r\n        self.popularity = 100\r\n        self.random_func = random_func\r\n\r\n    def debate(self, other):\r\n        if self.random_func() < max(0.1, self.popularity / (self.popularity + other.popularity)):\r\n            self.popularity += 50\r\n        else:\r\n            self.popularity = max(0, self.popularity - 50)\r\n\r\n\r\n    def speech(self, other):\r\n        self.votes += self.popularity // 10\r\n        self.popularity += self.popularity // 10\r\n       \r\n        other.popularity -= other.popularity // 10\r\n    def choose(self, other):\r\n        return self.speech\r\n\r\n\r\n### Phase 2: The Game Class\r\nclass Game:\r\n    '''\r\n    >>> random = make_test_random()\r\n    >>> p1, p2 = Player('Hill',random), Player('Don', random)\r\n    >>> g = Game(p1, p2)\r\n    >>> winner = g.play()\r\n    >>> p1 is winner\r\n    True\r\n    >>> # Additional correctness tests\r\n    >>> winner is g.winner()\r\n    True\r\n    >>> g.turn\r\n    10\r\n    >>> p1.votes = p2.votes\r\n    >>> print(g.winner())\r\n    None\r\n    '''\r\n    def __init__(self, player1, player2):\r\n        self.p1 = player1\r\n        self.p2 = player2\r\n        self.turn = 0\r\n\r\n    def play(self):\r\n        while not self.game_over():\r\n            '*** YOUR CODE HERE ***'\r\n        return self.winner()\r\n\r\n    def game_over(self):\r\n        return max(self.p1.votes, self.p2.votes) >= 50 or self.turn >= 10\r\n\r\n    def winner(self):\r\n        '*** YOUR CODE HERE ***'\r\n\r\n\r\n### Phase 3: New Players\r\nclass AggressivePlayer(Player):\r\n    '''\r\n    >>> random = make_test_random()\r\n    >>> p1, p2 = AggressivePlayer('Don', random), Player('Hill', random)\r\n    >>> g = Game(p1, p2)\r\n    >>> winner = g.play()\r\n    >>> p1 is winner\r\n    True\r\n    >>> # Additional correctness tests\r\n    >>> p1.popularity = p2.popularity\r\n    >>> p1.choose(p2) == p1.debate\r\n    True\r\n    >>> p1.popularity += 1\r\n    >>> p1.choose(p2) == p1.debate\r\n    False\r\n    >>> p2.choose(p1) == p2.speech\r\n    True\r\n    '''\r\n    def choose(self, other):\r\n        '*** YOUR CODE HERE ***'\r\n\r\nclass CautiousPlayer(Player):\r\n    '''\r\n    >>> random = make_test_random()\r\n    >>> p1, p2 = CautiousPlayer('Hill', random), AggressivePlayer('Don', random)\r\n    >>> p1.popularity = 0\r\n    >>> p1.choose(p2) == p1.debate\r\n    True\r\n    >>> p1.popularity = 1\r\n    >>> p1.choose(p2) == p1.debate\r\n    False\r\n    >>> # Additional correctness tests\r\n    >>> p2.choose(p1) == p2.speech\r\n    True\r\n    '''\r\n    def choose(self, other):\r\n        '*** YOUR CODE HERE ***'\r\n\r\n\r\ndef add_d_leaves(t, v):\r\n    '''Add d leaves containing v to each node at every depth d.\r\n\r\n    >>> t_one_to_four = Tree(1, [Tree(2), Tree(3, [Tree(4)])])\r\n    >>> print(t_one_to_four)\r\n    1\r\n      2\r\n      3\r\n        4\r\n    >>> add_d_leaves(t_one_to_four, 5)\r\n    >>> print(t_one_to_four)\r\n    1\r\n      2\r\n        5\r\n      3\r\n        4\r\n          5\r\n          5\r\n        5\r\n\r\n    >>> t0 = Tree(9)\r\n    >>> add_d_leaves(t0, 4)\r\n    >>> t0\r\n    Tree(9)\r\n    >>> t1 = Tree(1, [Tree(3)])\r\n    >>> add_d_leaves(t1, 4)\r\n    >>> t1\r\n    Tree(1, [Tree(3, [Tree(4)])])\r\n    >>> t2 = Tree(2, [Tree(5), Tree(6)])\r\n    >>> t3 = Tree(3, [t1, Tree(0), t2])\r\n    >>> print(t3)\r\n    3\r\n      1\r\n        3\r\n          4\r\n      0\r\n      2\r\n        5\r\n        6\r\n    >>> add_d_leaves(t3, 10)\r\n    >>> print(t3)\r\n    3\r\n      1\r\n        3\r\n          4\r\n            10\r\n            10\r\n            10\r\n          10\r\n          10\r\n        10\r\n      0\r\n        10\r\n      2\r\n        5\r\n          10\r\n          10\r\n        6\r\n          10\r\n          10\r\n        10\r\n    '''\r\n    '*** YOUR CODE HERE ***'\r\n\r\n\r\ndef level_mutation_link(t, funcs):\r\n\t'''Mutates t using the functions in the linked list funcs.\r\n\r\n\t>>> t = Tree(1, [Tree(2, [Tree(3)])])\r\n\t>>> funcs = Link(lambda x: x + 1, Link(lambda y: y * 5, Link(lambda z: z ** 2)))\r\n\t>>> level_mutation_link(t, funcs)\r\n\t>>> t    # At level 0, apply x + 1; at level 1, apply y * 5; at level 2 (leaf), apply z ** 2\r\n\tTree(2, [Tree(10, [Tree(9)])])\r\n\t>>> t2 = Tree(1, [Tree(2), Tree(3, [Tree(4)])])\r\n\t>>> level_mutation_link(t2, funcs)\r\n\t>>> t2    # Level 0: 1+1=2; Level 1: 2*5=10 => 10**2 = 100, 3*5=15; Level 2 (leaf): 4**2=16\r\n\tTree(2, [Tree(100), Tree(15, [Tree(16)])])\r\n\t>>> t3 = Tree(1, [Tree(2)])\r\n\t>>> level_mutation_link(t3, funcs)\r\n\t>>> t3    # Level 0: 1+1=2; Level 1: 2*5=10; no further levels, so apply remaining z ** 2: 10**2=100\r\n\tTree(2, [Tree(100)])\r\n\t'''\r\n\tif _____________________:\r\n\t\treturn\r\n\tt.label = _____________________\r\n\tremaining = _____________________\r\n\tif __________________ and __________________:\r\n\t\twhile _____________________:\r\n\t\t\t_____________________\r\n\t\t\tremaining = remaining.rest\r\n\tfor b in t.branches:\r\n\t\t_____________________\r\n\r\n\r\ndef store_digits(n):\r\n    '''Stores the digits of a positive number n in a linked list.\r\n\r\n    >>> s = store_digits(1)\r\n    >>> s\r\n    Link(1)\r\n    >>> store_digits(2345)\r\n    Link(2, Link(3, Link(4, Link(5))))\r\n    >>> store_digits(876)\r\n    Link(8, Link(7, Link(6)))\r\n    >>> store_digits(2450)\r\n    Link(2, Link(4, Link(5, Link(0))))\r\n    >>> # a check for restricted functions\r\n    >>> import inspect, re\r\n    >>> cleaned = re.sub(r'#.*\\\\n', '', re.sub(r''{3}[\\s\\S]*?'{3}', '', inspect.getsource(store_digits)))\r\n    >>> print('Do not use str or reversed!') if any([r in cleaned for r in ['str', 'reversed']]) else None\r\n    '''\r\n    '*** YOUR CODE HERE ***'\r\n\r\n\r\ndef deep_map_mut(func, lnk):\r\n    '''Mutates a deep link lnk by replacing each item found with the\r\n    result of calling func on the item. Does NOT create new Links (so\r\n    no use of Link's constructor).\r\n\r\n    Does not return the modified Link object.\r\n\r\n    >>> link1 = Link(3, Link(Link(4), Link(5, Link(6))))\r\n    >>> print(link1)\r\n    <3 <4> 5 6>\r\n    >>> # Disallow the use of making new Links before calling deep_map_mut\r\n    >>> Link.__init__, hold = lambda *args: print('Do not create any new Links.'), Link.__init__\r\n    >>> try:\r\n    ...     deep_map_mut(lambda x: x * x, link1)\r\n    ... finally:\r\n    ...     Link.__init__ = hold\r\n    >>> print(link1)\r\n    <9 <16> 25 36>\r\n    '''\r\n    '*** YOUR CODE HERE ***'\r\n\r\n\r\ndef crispr_gene_insertion(lnk_of_genes, insert):\r\n    '''Takes a linked list of genes and mutates the genes with the INSERT codon added the correct number of times.\r\n\r\n    >>> link = Link(Link('AUG', Link('GCC', Link('ACG'))), Link(Link('ATG', Link('AUG', Link('ACG', Link('GCC'))))))\r\n    >>> print(link)\r\n    <<AUG GCC ACG> <ATG AUG ACG GCC>>\r\n    >>> crispr_gene_insertion(link, 'TTA')\r\n    >>> print(link)\r\n    <<AUG TTA GCC ACG> <ATG AUG TTA TTA ACG GCC>>\r\n    >>> link = Link(Link('ATG'), Link(Link('AUG', Link('AUG')), Link(Link('AUG', Link('GCC')))))\r\n    >>> print(link)\r\n    <<ATG> <AUG AUG> <AUG GCC>>\r\n    >>> crispr_gene_insertion(link, 'TTA') # first gene has no AUG so unchanged, 2nd gene has 2 AUGs but only first considered for insertion\r\n    >>> print(link)\r\n    <<ATG> <AUG TTA TTA AUG> <AUG TTA TTA TTA GCC>>\r\n    >>> link = Link.empty # empty linked list of genes stays empty\r\n    >>> crispr_gene_insertion(link, 'TTA')\r\n    >>> print(link)\r\n    ()\r\n    '''\r\n    '*** YOUR CODE HERE ***'\r\n\r\ndef transcribe(dna):\r\n    '''Takes a string of DNA and returns a Python list with the RNA codons.\r\n\r\n    >>> DNA = 'TACCTAGCCCATAAA'\r\n    >>> transcribe(DNA)\r\n    ['AUG', 'GAU', 'CGG', 'GUA', 'UUU']\r\n    '''\r\n    dict = {'A': 'U', 'T': 'A', 'G': 'C', 'C': 'G'}\r\n    return __________________\r\n\r\n\r\nclass Tree:\r\n    '''\r\n    >>> t = Tree(3, [Tree(2, [Tree(5)]), Tree(4)])\r\n    >>> t.label\r\n    3\r\n    >>> t.branches[0].label\r\n    2\r\n    >>> t.branches[1].is_leaf()\r\n    True\r\n    '''\r\n    def __init__(self, label, branches=[]):\r\n        for b in branches:\r\n            assert isinstance(b, Tree)\r\n        self.label = label\r\n        self.branches = list(branches)\r\n\r\n    def is_leaf(self):\r\n        return not self.branches\r\n\r\n    def __repr__(self):\r\n        if self.branches:\r\n            branch_str = ', ' + repr(self.branches)\r\n        else:\r\n            branch_str = ''\r\n        return 'Tree({0}{1})'.format(self.label, branch_str)\r\n\r\n    def __str__(self):\r\n        def print_tree(t, indent=0):\r\n            tree_str = '  ' * indent + str(t.label) + '\\n'\r\n            for b in t.branches:\r\n                tree_str += print_tree(b, indent + 1)\r\n            return tree_str\r\n        return print_tree(self).rstrip()\r\n\r\n\r\nclass Link:\r\n    '''A linked list.\r\n\r\n    >>> s = Link(1)\r\n    >>> s.first\r\n    1\r\n    >>> s.rest is Link.empty\r\n    True\r\n    >>> s = Link(2, Link(3, Link(4)))\r\n    >>> s.first = 5\r\n    >>> s.rest.first = 6\r\n    >>> s.rest.rest = Link.empty\r\n    >>> s                                    # Displays the contents of repr(s)\r\n    Link(5, Link(6))\r\n    >>> s.rest = Link(7, Link(Link(8, Link(9))))\r\n    >>> s\r\n    Link(5, Link(7, Link(Link(8, Link(9)))))\r\n    >>> print(s)                             # Prints str(s)\r\n    <5 7 <8 9>>\r\n    '''\r\n    empty = ()\r\n\r\n    def __init__(self, first, rest=empty):\r\n        assert rest is Link.empty or isinstance(rest, Link)\r\n        self.first = first\r\n        self.rest = rest\r\n\r\n    def __repr__(self):\r\n        if self.rest is not Link.empty:\r\n            rest_repr = ', ' + repr(self.rest)\r\n        else:\r\n            rest_repr = ''\r\n        return 'Link(' + repr(self.first) + rest_repr + ')'\r\n\r\n    def __str__(self):\r\n        string = '<'\r\n        while self.rest is not Link.empty:\r\n            string += str(self.first) + ' '\r\n            self = self.rest\r\n        return string + str(self.first) + '>'\r\n \r\n```\r\n\r\n\r\n\r\n\r\n\r\n## hw06\r\n\r\n\r\n\r\n```scheme\r\n(define (square n) (* n n))\r\n\r\n(define (pow base exp) \r\n  (cond \r\n    ((= exp 1) base)\r\n    ((= exp 2) (square base))\r\n    ((even? (modulo exp 2)) (square (pow base (quotient exp 2))))\r\n    (else (* base (square (pow base (quotient exp 2)))))\r\n  )\r\n)\r\n\r\n(define (repeatedly-cube n x)\r\n  (if (zero? n)\r\n      x\r\n      (let ((y (repeatedly-cube (- n 1) x)))\r\n        (* y y y)\r\n      )\r\n  )\r\n)\r\n\r\n(define (cddr s) (cdr (cdr s)))\r\n\r\n(define (cadr s) (car (cdr s)))\r\n\r\n(define (caddr s) (car (cdr (cdr s))))\r\n\r\n(define (ascending? s) \r\n  (cond \r\n    ((or (null? s) (null? (cdr s))) #t)\r\n    ((> (car s) (cadr s)) #f)\r\n    (else (ascending? (cdr s)))\r\n  )\r\n)\r\n\r\n(define (my-filter pred s)\r\n  (cond \r\n    ((null? s) s)\r\n    ((pred (car s)) \r\n      (cons (car s) (my-filter pred (cdr s)))\r\n    )\r\n    (else (my-filter pred (cdr s)))\r\n  )\r\n)\r\n(define (no-repeats s) \r\n  (cond\r\n    ((null? s) s)\r\n    ((null? (cdr s)) s)\r\n    (else (cons (car s) (no-repeats (my-filter (lambda (x) (not (= x (car s)))) (cdr s)))))\r\n  )\r\n)\r\n; helper function\r\n; returns the values of lst that are bigger than x\r\n; e.g., (larger-values 3 '(1 2 3 4 5 1 2 3 4 5)) --> (4 5 4 5)\r\n(define (larger-values x lst)\r\n  (cond \r\n    ((null? lst) lst)\r\n    ((< x (car lst)) (cons (car lst) (larger-values x (cdr lst))))\r\n    (else (larger-values x (cdr lst)))\r\n  )\r\n)\r\n(define (longest-increasing-subsequence lst)\r\n  (if (null? lst)\r\n      nil\r\n      (begin (define first (car lst))\r\n             (define rest (cdr lst))\r\n             (define large-values-rest\r\n                    (larger-values first rest)\r\n             )\r\n             (define with-first\r\n                (cons first (longest-increasing-subsequence large-values-rest)\r\n                )\r\n             )\r\n             (define without-first\r\n                  (longest-increasing-subsequence rest)\r\n              )\r\n            (if (> (length with-first) (length without-first))\r\n                 with-first\r\n                 without-first\r\n            )\r\n      )\r\n  )\r\n)\r\n(define (sqrt x)\r\n  (define (good-enough? guess)\r\n    (< (abs (- (square guess) x)) 0.001))\r\n  (define (improve guess)\r\n    (average guess (/ x guess)))\r\n  (define (sqrt-iter guess)\r\n    (if (good-enough? guess)\r\n        guess\r\n        (sqrt-iter (improve guess))))\r\n  (sqrt-iter 1.0))\r\n(sqrt 9)\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## hw07\r\n\r\n\r\n\r\n```scheme\r\n(define (add-leaf t x)\r\n  (if (is-leaf t)\r\n      (tree (label t) nil)\r\n      (begin (define mapped-branches\r\n                (map  (lambda (b) (add-leaf b x))\r\n                      (branches t)\r\n                )\r\n             )\r\n            (tree (label t)\r\n              (append mapped-branches (list (tree x nil)))\r\n            )\r\n      )\r\n  )\r\n)\r\n```\r\n\r\n\r\n\r\n```sqlite\r\nCREATE TABLE parents AS\r\n  SELECT 'abraham' AS parent, 'barack' AS child UNION\r\n  SELECT 'abraham'          , 'clinton'         UNION\r\n  SELECT 'delano'           , 'herbert'         UNION\r\n  SELECT 'fillmore'         , 'abraham'         UNION\r\n  SELECT 'fillmore'         , 'delano'          UNION\r\n  SELECT 'fillmore'         , 'grover'          UNION\r\n  SELECT 'eisenhower'       , 'fillmore';\r\n\r\nCREATE TABLE dogs AS\r\n  SELECT 'abraham' AS name, 'long' AS fur, 26 AS height UNION\r\n  SELECT 'barack'         , 'short'      , 52           UNION\r\n  SELECT 'clinton'        , 'long'       , 47           UNION\r\n  SELECT 'delano'         , 'long'       , 46           UNION\r\n  SELECT 'eisenhower'     , 'short'      , 35           UNION\r\n  SELECT 'fillmore'       , 'curly'      , 32           UNION\r\n  SELECT 'grover'         , 'short'      , 28           UNION\r\n  SELECT 'herbert'        , 'curly'      , 31;\r\n\r\nCREATE TABLE sizes AS\r\n  SELECT 'toy' AS size, 24 AS min, 28 AS max UNION\r\n  SELECT 'mini'       , 28       , 35        UNION\r\n  SELECT 'medium'     , 35       , 45        UNION\r\n  SELECT 'standard'   , 45       , 60;\r\n\r\n\r\n-- All dogs with parents ordered by decreasing height of their parent\r\nCREATE TABLE by_parent_height AS\r\n  SELECT child FROM parents, dogs WHERE name = parent ORDER BY height desc;\r\n\r\n-- The size of each dog\r\nCREATE TABLE size_of_dogs AS\r\n\r\nSELECT name, size FROM dogs, sizes\r\n    WHERE height > min AND height <= max;\r\n-- Filling out this helper table is optional\r\nCREATE TABLE siblings AS\r\n  SELECT a.child AS first, b.child AS second FROM parents AS a, parents AS b\r\n      WHERE a.parent = b.parent AND a.child < b.child;\r\n-- Sentences about siblings that are the same size\r\nCREATE TABLE sentences AS\r\n  SELECT 'The two siblings, ' || first || ' and ' || second || ', have the same size: ' || a.size\r\n      FROM siblings, size_of_dogs AS a, size_of_dogs AS b\r\n      WHERE a.size = b.size AND a.name = first AND b.name = second;\r\n\r\n-- Height range for each fur type where all of the heights differ by no more than 30% from the average height\r\nCREATE TABLE low_variance AS\r\n  SELECT  fur, max(height) - min(height) \r\n  from dogs \r\n  group by fur \r\n  having MIN(height) >= .7 * AVG(height) AND MAX(height) <= 1.3 * AVG(height) ;\r\n```\r\n\r\n\u3002", "top": 0, "createdAt": 1724838489, "style": "", "script": "", "head": "", "ogImage": "https://img.icons8.com/doodle/480/mugman.png", "createdDate": "2024-08-28", "dateLabelColor": "#bc4c00"}}, "singeListJson": {}, "labelColorDict": {"cmu15-213": "#C0858E", "cs61a": "#1D3AD1", "cs61c": "#6C1C8A", "csapp": "#1d76db", "database": "#33EBC2", "disc": "#CD6E80", "hw": "#B60205", "lab": "#FBCA04", "lecture": "#D33B1C", "mysql": "#FC0661", "project": "#d876e3"}, "displayTitle": "Lizi", "faviconUrl": "https://img.icons8.com/doodle/480/mugman.png", "ogImage": "https://img.icons8.com/doodle/480/mugman.png", "primerCSS": "<link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />", "homeUrl": "https://LianSeKong.github.io/lizi", "prevUrl": "disabled", "nextUrl": "disabled"}