<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Lizi</title><link>https://LianSeKong.github.io/lizi</link><description>即是代码也是生活！</description><copyright>Lizi</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://img.icons8.com/doodle/480/mugman.png</url><title>avatar</title><link>https://LianSeKong.github.io/lizi</link></image><lastBuildDate>Thu, 18 Jul 2024 03:21:14 +0000</lastBuildDate><managingEditor>Lizi</managingEditor><ttl>60</ttl><webMaster>Lizi</webMaster><item><title>cmu15213-fa15-lec25</title><link>https://LianSeKong.github.io/lizi/post/cmu15213-fa15-lec25.html</link><description>&#13;
# 高级&#13;
&#13;
&#13;
&gt; 使用信号量协调对共享资源的访问&#13;
&gt; 使用同步可能会让代码执行变慢&#13;
&#13;
基本思想：线程使用信号量操作来通知另一个线程某个条件已变为真&#13;
1. 使用计数信号量来跟踪资源状态并通知其他线程&#13;
2. 使用互斥锁来保护对资源的访问&#13;
&#13;
两种典型例子： &#13;
1. 生产者-消费者问题&#13;
2. 读者-写者问题&#13;
&#13;
### 生产者-消费者&#13;
&#13;
常见的同步模式：&#13;
1. 生产者等待空位，将项目插入缓冲区，并通知消费者。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/cmu15213-fa15-lec25.html</guid><pubDate>Thu, 18 Jul 2024 03:19:30 +0000</pubDate></item><item><title>cs61a-su24-hw02</title><link>https://LianSeKong.github.io/lizi/post/cs61a-su24-hw02.html</link><description>## Instructions&#13;
&#13;
Download [hw02.zip](https://cs61a.org/hw/hw02/hw02.zip). Inside the archive, you will find a file called [hw02.py](https://cs61a.org/hw/hw02/hw02.py), along with a copy of the `ok` autograder.&#13;
&#13;
**Submission:** When you are done, submit the assignment by uploading all code files you've edited to Gradescope. You may submit more than once before the deadline; only the final submission will be scored. Check that you have successfully submitted your code on Gradescope. See [Lab 0](https://cs61a.org/lab/lab00#task-c-submitting-the-assignment) for more instructions on submitting assignments.&#13;
&#13;
**Using Ok:** If you have any questions about using Ok, please refer to [this guide.](https://cs61a.org/articles/using-ok)&#13;
&#13;
**Readings:** You might find the following references useful:&#13;
&#13;
*   [Section 1.6](https://www.composingprograms.com/pages/16-higher-order-functions.html)&#13;
*   [Section 1.7](https://www.composingprograms.com/pages/17-recursive-functions.html)&#13;
&#13;
**Grading:** Homework is graded based on correctness. Each incorrect problem will decrease the total score by one point. **This homework is out of 2 points.**&#13;
&#13;
Several doctests refer to these functions:&#13;
&#13;
```&#13;
from operator import add, mul&#13;
&#13;
square = lambda x: x * x&#13;
&#13;
identity = lambda x: x&#13;
&#13;
triple = lambda x: 3 * x&#13;
&#13;
increment = lambda x: x + 1&#13;
&#13;
```&#13;
&#13;
## Higher-Order Functions&#13;
&#13;
### Q1: Product&#13;
&#13;
Write a function called `product` that returns the product of the first `n` terms of a sequence. Specifically, `product` takes in an integer `n` and `term`, a single-argument function that determines a sequence. (That is, `term(i)` gives the `i`th term of the sequence.) `product(n, term)` should return `term(1) * ... * term(n)`.&#13;
&#13;
```&#13;
def product(n, term):&#13;
    '''Return the product of the first n terms in a sequence.&#13;
&#13;
    n: a positive integer&#13;
    term:  a function that takes one argument to produce the term&#13;
&#13;
    &gt;&gt;&gt; product(3, identity)  # 1 * 2 * 3&#13;
    6&#13;
    &gt;&gt;&gt; product(5, identity)  # 1 * 2 * 3 * 4 * 5&#13;
    120&#13;
    &gt;&gt;&gt; product(3, square)    # 1^2 * 2^2 * 3^2&#13;
    36&#13;
    &gt;&gt;&gt; product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2&#13;
    14400&#13;
    &gt;&gt;&gt; product(3, increment) # (1+1) * (2+1) * (3+1)&#13;
    24&#13;
    &gt;&gt;&gt; product(3, triple)    # 1*3 * 2*3 * 3*3&#13;
    162&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
Use Ok to test your code:&#13;
&#13;
```&#13;
python3 ok -q product&#13;
&#13;
```&#13;
&#13;
:bear: &lt;u&gt;比较简单，就不解释了&lt;/u&gt;&#13;
&#13;
```python&#13;
def product(n, term):&#13;
    i, count = 1, 1&#13;
    while i &lt;= n:&#13;
        count, i = mul(count, term(i)), add(i, 1)&#13;
    return count&#13;
```&#13;
&#13;
### Q2: Accumulate&#13;
&#13;
Let's take a look at how `product` is an instance of a more general function called `accumulate`, which we would like to implement:&#13;
&#13;
```&#13;
def accumulate(fuse, start, n, term):&#13;
    '''Return the result of fusing together the first n terms in a sequence &#13;
    and start.  The terms to be fused are term(1), term(2), ..., term(n). &#13;
    The function fuse is a two-argument commutative &amp; associative function.&#13;
&#13;
    &gt;&gt;&gt; accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5&#13;
    15&#13;
    &gt;&gt;&gt; accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5&#13;
    26&#13;
    &gt;&gt;&gt; accumulate(add, 11, 0, identity) # 11 (fuse is never used)&#13;
    11&#13;
    &gt;&gt;&gt; accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2&#13;
    25&#13;
    &gt;&gt;&gt; accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2&#13;
    72&#13;
    &gt;&gt;&gt; # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1)&#13;
    &gt;&gt;&gt; accumulate(lambda x, y: x + y + 1, 2, 3, square)&#13;
    19&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
`accumulate` has the following parameters:&#13;
&#13;
*   `fuse`: a two-argument function that specifies how the current term is fused with the previously accumulated terms&#13;
*   `start`: value at which to start the accumulation&#13;
*   `n`: a non-negative integer indicating the number of terms to fuse&#13;
*   `term`: a single-argument function; `term(i)` is the `i`th term of the sequence&#13;
&#13;
Implement `accumulate`, which fuses the first `n` terms of the sequence defined by `term` with the `start` value using the `fuse` function.&#13;
&#13;
For example, the result of `accumulate(add, 11, 3, square)` is&#13;
&#13;
```&#13;
add(11,  add(square(1), add(square(2),  square(3)))) =&#13;
    11 +     square(1) +    square(2) + square(3)    =&#13;
    11 +     1         +    4         + 9            = 25&#13;
&#13;
```&#13;
&#13;
Assume that `fuse` is commutative, `fuse(a, b) == fuse(b, a)`, and associative, `fuse(fuse(a, b), c) == fuse(a, fuse(b, c))`.&#13;
&#13;
Then, implement `summation` (from lecture) and `product` as one-line calls to `accumulate`.&#13;
&#13;
**Important:** Both `summation_using_accumulate` and `product_using_accumulate` should be implemented with a single line of code starting with `return`.&#13;
&#13;
```&#13;
def summation_using_accumulate(n, term):&#13;
    '''Returns the sum: term(1) + ... + term(n), using accumulate.&#13;
&#13;
    &gt;&gt;&gt; summation_using_accumulate(5, square) # square(0) + square(1) + ... + square(4) + square(5)&#13;
    55&#13;
    &gt;&gt;&gt; summation_using_accumulate(5, triple) # triple(0) + triple(1) + ... + triple(4) + triple(5)&#13;
    45&#13;
    &gt;&gt;&gt; # This test checks that the body of the function is just a return statement.&#13;
    &gt;&gt;&gt; import inspect, ast&#13;
    &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body]&#13;
    ['Expr', 'Return']&#13;
    '''&#13;
    return ____&#13;
&#13;
def product_using_accumulate(n, term):&#13;
    '''Returns the product: term(1) * ... * term(n), using accumulate.&#13;
&#13;
    &gt;&gt;&gt; product_using_accumulate(4, square) # square(1) * square(2) * square(3) * square()&#13;
    576&#13;
    &gt;&gt;&gt; product_using_accumulate(6, triple) # triple(1) * triple(2) * ... * triple(5) * triple(6)&#13;
    524880&#13;
    &gt;&gt;&gt; # This test checks that the body of the function is just a return statement.&#13;
    &gt;&gt;&gt; import inspect, ast&#13;
    &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(product_using_accumulate)).body[0].body]&#13;
    ['Expr', 'Return']&#13;
    '''&#13;
    return ____&#13;
&#13;
&#13;
```&#13;
&#13;
Use Ok to test your code:&#13;
&#13;
```&#13;
python3 ok -q accumulate&#13;
python3 ok -q summation_using_accumulate&#13;
python3 ok -q product_using_accumulate&#13;
&#13;
```&#13;
&#13;
:bear: `accumulate： 对product的每次相乘行为替换为抽象的函数`&#13;
&#13;
```python&#13;
def accumulate(fuse, start, n, term):&#13;
    i, count = 1, start&#13;
    while i &lt;= n:&#13;
        start, i = merger(fuse, term(i)), add(i + 1)&#13;
    return count&#13;
```&#13;
&#13;
:bear: `summation_using_accumulate: product的变体`&#13;
&#13;
```python&#13;
def summation_using_accumulate(n, term):&#13;
    return accumulate(add, term(0), n, term)&#13;
```&#13;
&#13;
:bear: `sproduct_using_accumulate: product的变体`&#13;
&#13;
```python&#13;
def product_using_accumulate(n, term):&#13;
 	return accumulate(mul, 1, n, term)&#13;
```&#13;
&#13;
&#13;
&#13;
### Q3: Make Repeater&#13;
&#13;
Implement the function `make_repeater` which takes a one-argument function `f` and a positive integer `n`. It returns a one-argument function, where `make_repeater(f, n)(x)` returns the value of `f(f(...f(x)...))` in which `f` is applied `n` times to `x`. For example, `make_repeater(square, 3)(5)` squares 5 three times and returns 390625, just like `square(square(square(5)))`.&#13;
&#13;
```&#13;
def make_repeater(f, n):&#13;
    '''Returns the function that computes the nth application of f.&#13;
&#13;
    &gt;&gt;&gt; add_three = make_repeater(increment, 3)&#13;
    &gt;&gt;&gt; add_three(5)&#13;
    8&#13;
    &gt;&gt;&gt; make_repeater(triple, 5)(1) # 3 * (3 * (3 * (3 * (3 * 1))))&#13;
    243&#13;
    &gt;&gt;&gt; make_repeater(square, 2)(5) # square(square(5))&#13;
    625&#13;
    &gt;&gt;&gt; make_repeater(square, 3)(5) # square(square(square(5)))&#13;
    390625&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
Use Ok to test your code:&#13;
&#13;
```&#13;
python3 ok -q make_repeater&#13;
&#13;
```&#13;
&#13;
:bear:  &#13;
&#13;
```python&#13;
def make_repeater(f, n):&#13;
    def helper(x):&#13;
        i = n;&#13;
        while i:&#13;
            x = f(x)&#13;
            i = i - 1;&#13;
        return x&#13;
    return helper&#13;
```&#13;
&#13;
&#13;
&#13;
## Recursion&#13;
&#13;
### Q4: Digit Distance&#13;
&#13;
For a given integer, the _digit distance_ is the sum of the absolute differences between consecutive digits. For example:&#13;
&#13;
*   The digit distance of `6` is `0`.&#13;
*   The digit distance of `61` is `5`, as the absolute value of `6 - 1` is `5`.&#13;
*   The digit distance of `71253` is `12` (`6 + 1 + 3 + 2`).&#13;
&#13;
Write a function that determines the digit distance of a given positive integer. You must use recursion or the tests will fail.&#13;
&#13;
**Hint:** There are multiple valid ways of solving this problem! If you're stuck, try writing out an iterative solution first, and then convert your iterative solution into a recursive one.&#13;
&#13;
```&#13;
def digit_distance(n):&#13;
    '''Determines the digit distance of n.&#13;
&#13;
    &gt;&gt;&gt; digit_distance(3)&#13;
    0&#13;
    &gt;&gt;&gt; digit_distance(777)&#13;
    0&#13;
    &gt;&gt;&gt; digit_distance(314)&#13;
    5&#13;
    &gt;&gt;&gt; digit_distance(31415926535)&#13;
    32&#13;
    &gt;&gt;&gt; digit_distance(3464660003)&#13;
    16&#13;
    &gt;&gt;&gt; from construct_check import check&#13;
    &gt;&gt;&gt; # ban all loops&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'digit_distance',&#13;
    ...       ['For', 'While'])&#13;
    True&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
Use Ok to test your code:&#13;
&#13;
```&#13;
python3 ok -q digit_distance&#13;
&#13;
```&#13;
&#13;
:bear:&#13;
&#13;
```python&#13;
def digit_distance(n):&#13;
    if n &lt; 10:&#13;
        return 0&#13;
    else:&#13;
        return abs(sub(n % 10, n // 10 % 10)) + digit_distance(n // 10)&#13;
```&#13;
&#13;
&#13;
&#13;
### Q5: Interleaved Sum&#13;
&#13;
Write a function `interleaved_sum`, which takes in a number `n` and two one-argument functions: `odd_func` and `even_func`. It applies `odd_func` to every odd number and `even_func` to every even number from 1 to `n` _inclusive_ and returns the sum.&#13;
&#13;
For example, executing `interleaved_sum(5, lambda x: x, lambda x: x * x)` returns `1 + 2*2 + 3 + 4*4 + 5 = 29`.&#13;
&#13;
**Important:** Implement this function without using any loops or directly testing if a number is odd or even -- aka modulos (`%`) are not allowed! Instead of directly checking whether a number is even or odd, start with 1, which you know is an odd number.&#13;
&#13;
**Hint:** Introduce an inner helper function that takes an odd number `k` and computes an interleaved sum from `k` to `n` (including `n`).&#13;
&#13;
```&#13;
def interleaved_sum(n, odd_func, even_func):&#13;
    '''Compute the sum odd_func(1) + even_func(2) + odd_func(3) + ..., up&#13;
    to n.&#13;
&#13;
    &gt;&gt;&gt; identity = lambda x: x&#13;
    &gt;&gt;&gt; square = lambda x: x * x&#13;
    &gt;&gt;&gt; triple = lambda x: x * 3&#13;
    &gt;&gt;&gt; interleaved_sum(5, identity, square) # 1   + 2*2 + 3   + 4*4 + 5&#13;
    29&#13;
    &gt;&gt;&gt; interleaved_sum(5, square, identity) # 1*1 + 2   + 3*3 + 4   + 5*5&#13;
    41&#13;
    &gt;&gt;&gt; interleaved_sum(4, triple, square)   # 1*3 + 2*2 + 3*3 + 4*4&#13;
    32&#13;
    &gt;&gt;&gt; interleaved_sum(4, square, triple)   # 1*1 + 2*3 + 3*3 + 4*3&#13;
    28&#13;
    &gt;&gt;&gt; from construct_check import check&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'interleaved_sum', ['While', 'For', 'Mod']) # ban loops and %&#13;
    True&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'interleaved_sum', ['BitAnd', 'BitOr', 'BitXor']) # ban bitwise operators, don't worry about these if you don't know what they are&#13;
    True&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
Use Ok to test your code:&#13;
&#13;
```&#13;
python3 ok -q interleaved_sum&#13;
&#13;
```&#13;
&#13;
:bear:`interleaved_sum`&#13;
&#13;
```python&#13;
def interleaved_sum(n, odd_func, even_func):&#13;
    if n == 0:&#13;
        return 0&#13;
    elif n % 2 == 1:&#13;
        return odd_func(n) + interleaved_sum(n - 1, odd_func, even_func)&#13;
    else:&#13;
        return even_func(n) + interleaved_sum(n - 1, odd_func, even_func)&#13;
&#13;
```&#13;
&#13;
&#13;
&#13;
### Q6: Count Coins&#13;
&#13;
Given a positive integer `total`, a set of coins makes change for `total` if the sum of the values of the coins is `total`. Here we will use standard US Coin values: 1, 5, 10, 25. For example, the following sets make change for `15`:&#13;
&#13;
*   15 1-cent coins&#13;
*   10 1-cent, 1 5-cent coins&#13;
*   5 1-cent, 2 5-cent coins&#13;
*   5 1-cent, 1 10-cent coins&#13;
*   3 5-cent coins&#13;
*   1 5-cent, 1 10-cent coin&#13;
&#13;
Thus, there are 6 ways to make change for `15`. Write a **recursive** function `count_coins` that takes a positive integer `total` and returns the number of ways to make change for `total` using coins.&#13;
&#13;
You can use _either_ of the functions given to you:&#13;
&#13;
*   `next_larger_coin` will return the next larger coin denomination from the input, i.e. `next_larger_coin(5)` is `10`.&#13;
*   `next_smaller_coin` will return the next smaller coin denomination from the input, i.e. `next_smaller_coin(5)` is `1`.&#13;
*   Either function will return `None` if the next coin value does not exist&#13;
&#13;
There are two main ways in which you can approach this problem. One way uses `next_larger_coin`, and another uses `next_smaller_coin`. It is up to you which one you want to use!&#13;
&#13;
**Important:** Use recursion; the tests will fail if you use loops.&#13;
&#13;
**Hint:** Refer to the [implementation](https://www.composingprograms.com/pages/17-recursive-functions.html#example-partitions) of `count_partitions` for an example of how to count the ways to sum up to a final value with smaller parts. If you need to keep track of more than one value across recursive calls, consider writing a helper function.&#13;
&#13;
```&#13;
def next_larger_coin(coin):&#13;
    '''Returns the next larger coin in order.&#13;
    &gt;&gt;&gt; next_larger_coin(1)&#13;
    5&#13;
    &gt;&gt;&gt; next_larger_coin(5)&#13;
    10&#13;
    &gt;&gt;&gt; next_larger_coin(10)&#13;
    25&#13;
    &gt;&gt;&gt; next_larger_coin(2) # Other values return None&#13;
    '''&#13;
    if coin == 1:&#13;
        return 5&#13;
    elif coin == 5:&#13;
        return 10&#13;
    elif coin == 10:&#13;
        return 25&#13;
&#13;
def next_smaller_coin(coin):&#13;
    '''Returns the next smaller coin in order.&#13;
    &gt;&gt;&gt; next_smaller_coin(25)&#13;
    10&#13;
    &gt;&gt;&gt; next_smaller_coin(10)&#13;
    5&#13;
    &gt;&gt;&gt; next_smaller_coin(5)&#13;
    1&#13;
    &gt;&gt;&gt; next_smaller_coin(2) # Other values return None&#13;
    '''&#13;
    if coin == 25:&#13;
        return 10&#13;
    elif coin == 10:&#13;
        return 5&#13;
    elif coin == 5:&#13;
        return 1&#13;
&#13;
def count_coins(total):&#13;
    '''Return the number of ways to make change using coins of value of 1, 5, 10, 25.&#13;
    &gt;&gt;&gt; count_coins(15)&#13;
    6&#13;
    &gt;&gt;&gt; count_coins(10)&#13;
    4&#13;
    &gt;&gt;&gt; count_coins(20)&#13;
    9&#13;
    &gt;&gt;&gt; count_coins(100) # How many ways to make change for a dollar?&#13;
    242&#13;
    &gt;&gt;&gt; count_coins(200)&#13;
    1463&#13;
    &gt;&gt;&gt; from construct_check import check&#13;
    &gt;&gt;&gt; # ban iteration&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'count_coins', ['While', 'For'])&#13;
    True&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
```&#13;
python3 ok -q count_coins&#13;
```&#13;
&#13;
:bear:&#13;
&#13;
```python&#13;
# 边界情况： 硬币为0，方案正确。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/cs61a-su24-hw02.html</guid><pubDate>Wed, 17 Jul 2024 11:38:44 +0000</pubDate></item><item><title>cs61a-su24-hw01</title><link>https://LianSeKong.github.io/lizi/post/cs61a-su24-hw01.html</link><description>---&#13;
url: https://cs61a.org/hw/hw01/&#13;
title: Homework 1 &#13;
date: 2024-07-17 16:08:34&#13;
tag: &#13;
banner: 'https://images.unsplash.com/photo-1719749937847-ab76d3e0dbb7?crop=entropy&amp;cs=srgb&amp;fm=jpg&amp;ixid=M3w0Njc1ODd8MHwxfHJhbmRvbXx8fHx8fHwxfHwxNzIxMjAzNjE1fA&amp;ixlib=rb-4.0.3&amp;q=85&amp;fit=crop&amp;w=624&amp;max-h=540'&#13;
banner_icon: 🔖&#13;
---&#13;
sr-annote { all: unset; }&#13;
&#13;
_Due by 11:59pm on Wednesday, June 26  &#13;
截止日期为 6 月 26 日星期三晚上 11：59_&#13;
&#13;
## Instructions 指示&#13;
&#13;
Download [hw01.zip](https://cs61a.org/hw/hw01/hw01.zip). 下载hw01.zip。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/cs61a-su24-hw01.html</guid><pubDate>Wed, 17 Jul 2024 08:32:14 +0000</pubDate></item><item><title>ProxyLab</title><link>https://LianSeKong.github.io/lizi/post/ProxyLab.html</link><description>&#13;
&gt; 使用信号量协调对共享资源的访问&#13;
&gt; Using Semaphores to Coordinate Access to Shared Resources&#13;
&#13;
1. 基本思想：线程使用信号量操作来通知另一个线程某个条件已变为真&#13;
2. Basic idea: Thread uses a semaphore operation to notify another thread that some condition has become true&#13;
3. 使用计数信号量来跟踪资源状态并通知其他线程&#13;
4. Use counting semaphores to keep track of resource state and to notify other threads&#13;
5. 使用互斥锁来保护对资源的访问&#13;
6. Use mutex to protect access to resource&#13;
&#13;
&gt; 两种典型例子&#13;
&#13;
1. The Producer-­Consumer Problem &#13;
2. The Readers-­Writers Problem&#13;
&#13;
## The Producer­‐Consumer&#13;
&#13;
[[25-sync-advanced.pdf#page=4&amp;selection=0,15,10,26|25-sync-advanced, 页面 4]]&#13;
&#13;
## The Readers-­Writers Problem&#13;
&#13;
[[25-sync-advanced.pdf#page=11&amp;selection=0,15,8,25|25-sync-advanced, 页面 11]]&#13;
&#13;
## 线程安全函数&#13;
&#13;
&gt; 如果一个函数在被多个并发线程重复调用时总能产生正确的结果，那么它就是线程安全的&#13;
&#13;
## 线程不安全函数&#13;
&#13;
1. 使用不安全的函数&#13;
2. 函数返回静态指针变量     &#13;
3. 函数不保护共享变量的访问&#13;
4. 函数维持状态通过多次调用 （操作静态变量）&#13;
&#13;
## reentrant &#13;
&#13;
&gt; 可重入函数： 属于线程安全函数，不需要同步操作，不访问共享变量。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/ProxyLab.html</guid><pubDate>Wed, 17 Jul 2024 07:17:38 +0000</pubDate></item></channel></rss>