<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Lizi</title><link>https://LianSeKong.github.io/lizi</link><description>å³æ˜¯ä»£ç ä¹Ÿæ˜¯ç”Ÿæ´»ï¼</description><copyright>Lizi</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://img.icons8.com/doodle/480/mugman.png</url><title>avatar</title><link>https://LianSeKong.github.io/lizi</link></image><lastBuildDate>Thu, 18 Jul 2024 03:21:14 +0000</lastBuildDate><managingEditor>Lizi</managingEditor><ttl>60</ttl><webMaster>Lizi</webMaster><item><title>cmu15213-fa15-lec25</title><link>https://LianSeKong.github.io/lizi/post/cmu15213-fa15-lec25.html</link><description>&#13;
# é«˜çº§&#13;
&#13;
&#13;
&gt; ä½¿ç”¨ä¿¡å·é‡åè°ƒå¯¹å…±äº«èµ„æºçš„è®¿é—®&#13;
&gt; ä½¿ç”¨åŒæ­¥å¯èƒ½ä¼šè®©ä»£ç æ‰§è¡Œå˜æ…¢&#13;
&#13;
åŸºæœ¬æ€æƒ³ï¼šçº¿ç¨‹ä½¿ç”¨ä¿¡å·é‡æ“ä½œæ¥é€šçŸ¥å¦ä¸€ä¸ªçº¿ç¨‹æŸä¸ªæ¡ä»¶å·²å˜ä¸ºçœŸ&#13;
1. ä½¿ç”¨è®¡æ•°ä¿¡å·é‡æ¥è·Ÿè¸ªèµ„æºçŠ¶æ€å¹¶é€šçŸ¥å…¶ä»–çº¿ç¨‹&#13;
2. ä½¿ç”¨äº’æ–¥é”æ¥ä¿æŠ¤å¯¹èµ„æºçš„è®¿é—®&#13;
&#13;
ä¸¤ç§å…¸å‹ä¾‹å­ï¼š &#13;
1. ç”Ÿäº§è€…-æ¶ˆè´¹è€…é—®é¢˜&#13;
2. è¯»è€…-å†™è€…é—®é¢˜&#13;
&#13;
### ç”Ÿäº§è€…-æ¶ˆè´¹è€…&#13;
&#13;
å¸¸è§çš„åŒæ­¥æ¨¡å¼ï¼š&#13;
1. ç”Ÿäº§è€…ç­‰å¾…ç©ºä½ï¼Œå°†é¡¹ç›®æ’å…¥ç¼“å†²åŒºï¼Œå¹¶é€šçŸ¥æ¶ˆè´¹è€…ã€‚</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/cmu15213-fa15-lec25.html</guid><pubDate>Thu, 18 Jul 2024 03:19:30 +0000</pubDate></item><item><title>cs61a-su24-hw02</title><link>https://LianSeKong.github.io/lizi/post/cs61a-su24-hw02.html</link><description>## Instructions&#13;
&#13;
Download [hw02.zip](https://cs61a.org/hw/hw02/hw02.zip). Inside the archive, you will find a file called [hw02.py](https://cs61a.org/hw/hw02/hw02.py), along with a copy of the `ok` autograder.&#13;
&#13;
**Submission:** When you are done, submit the assignment by uploading all code files you've edited to Gradescope. You may submit more than once before the deadline; only the final submission will be scored. Check that you have successfully submitted your code on Gradescope. See [Lab 0](https://cs61a.org/lab/lab00#task-c-submitting-the-assignment) for more instructions on submitting assignments.&#13;
&#13;
**Using Ok:** If you have any questions about using Ok, please refer to [this guide.](https://cs61a.org/articles/using-ok)&#13;
&#13;
**Readings:** You might find the following references useful:&#13;
&#13;
*   [Section 1.6](https://www.composingprograms.com/pages/16-higher-order-functions.html)&#13;
*   [Section 1.7](https://www.composingprograms.com/pages/17-recursive-functions.html)&#13;
&#13;
**Grading:** Homework is graded based on correctness. Each incorrect problem will decrease the total score by one point. **This homework is out of 2 points.**&#13;
&#13;
Several doctests refer to these functions:&#13;
&#13;
```&#13;
from operator import add, mul&#13;
&#13;
square = lambda x: x * x&#13;
&#13;
identity = lambda x: x&#13;
&#13;
triple = lambda x: 3 * x&#13;
&#13;
increment = lambda x: x + 1&#13;
&#13;
```&#13;
&#13;
## Higher-Order Functions&#13;
&#13;
### Q1: Product&#13;
&#13;
Write a function called `product` that returns the product of the first `n` terms of a sequence. Specifically, `product` takes in an integer `n` and `term`, a single-argument function that determines a sequence. (That is, `term(i)` gives the `i`th term of the sequence.) `product(n, term)` should return `term(1) * ... * term(n)`.&#13;
&#13;
```&#13;
def product(n, term):&#13;
    '''Return the product of the first n terms in a sequence.&#13;
&#13;
    n: a positive integer&#13;
    term:  a function that takes one argument to produce the term&#13;
&#13;
    &gt;&gt;&gt; product(3, identity)  # 1 * 2 * 3&#13;
    6&#13;
    &gt;&gt;&gt; product(5, identity)  # 1 * 2 * 3 * 4 * 5&#13;
    120&#13;
    &gt;&gt;&gt; product(3, square)    # 1^2 * 2^2 * 3^2&#13;
    36&#13;
    &gt;&gt;&gt; product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2&#13;
    14400&#13;
    &gt;&gt;&gt; product(3, increment) # (1+1) * (2+1) * (3+1)&#13;
    24&#13;
    &gt;&gt;&gt; product(3, triple)    # 1*3 * 2*3 * 3*3&#13;
    162&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
Use Ok to test your code:&#13;
&#13;
```&#13;
python3 ok -q product&#13;
&#13;
```&#13;
&#13;
:bear: &lt;u&gt;æ¯”è¾ƒç®€å•ï¼Œå°±ä¸è§£é‡Šäº†&lt;/u&gt;&#13;
&#13;
```python&#13;
def product(n, term):&#13;
    i, count = 1, 1&#13;
    while i &lt;= n:&#13;
        count, i = mul(count, term(i)), add(i, 1)&#13;
    return count&#13;
```&#13;
&#13;
### Q2: Accumulate&#13;
&#13;
Let's take a look at how `product` is an instance of a more general function called `accumulate`, which we would like to implement:&#13;
&#13;
```&#13;
def accumulate(fuse, start, n, term):&#13;
    '''Return the result of fusing together the first n terms in a sequence &#13;
    and start.  The terms to be fused are term(1), term(2), ..., term(n). &#13;
    The function fuse is a two-argument commutative &amp; associative function.&#13;
&#13;
    &gt;&gt;&gt; accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5&#13;
    15&#13;
    &gt;&gt;&gt; accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5&#13;
    26&#13;
    &gt;&gt;&gt; accumulate(add, 11, 0, identity) # 11 (fuse is never used)&#13;
    11&#13;
    &gt;&gt;&gt; accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2&#13;
    25&#13;
    &gt;&gt;&gt; accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2&#13;
    72&#13;
    &gt;&gt;&gt; # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1)&#13;
    &gt;&gt;&gt; accumulate(lambda x, y: x + y + 1, 2, 3, square)&#13;
    19&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
`accumulate` has the following parameters:&#13;
&#13;
*   `fuse`: a two-argument function that specifies how the current term is fused with the previously accumulated terms&#13;
*   `start`: value at which to start the accumulation&#13;
*   `n`: a non-negative integer indicating the number of terms to fuse&#13;
*   `term`: a single-argument function; `term(i)` is the `i`th term of the sequence&#13;
&#13;
Implement `accumulate`, which fuses the first `n` terms of the sequence defined by `term` with the `start` value using the `fuse` function.&#13;
&#13;
For example, the result of `accumulate(add, 11, 3, square)` is&#13;
&#13;
```&#13;
add(11,  add(square(1), add(square(2),  square(3)))) =&#13;
    11 +     square(1) +    square(2) + square(3)    =&#13;
    11 +     1         +    4         + 9            = 25&#13;
&#13;
```&#13;
&#13;
Assume that `fuse` is commutative, `fuse(a, b) == fuse(b, a)`, and associative, `fuse(fuse(a, b), c) == fuse(a, fuse(b, c))`.&#13;
&#13;
Then, implement `summation` (from lecture) and `product` as one-line calls to `accumulate`.&#13;
&#13;
**Important:** Both `summation_using_accumulate` and `product_using_accumulate` should be implemented with a single line of code starting with `return`.&#13;
&#13;
```&#13;
def summation_using_accumulate(n, term):&#13;
    '''Returns the sum: term(1) + ... + term(n), using accumulate.&#13;
&#13;
    &gt;&gt;&gt; summation_using_accumulate(5, square) # square(0) + square(1) + ... + square(4) + square(5)&#13;
    55&#13;
    &gt;&gt;&gt; summation_using_accumulate(5, triple) # triple(0) + triple(1) + ... + triple(4) + triple(5)&#13;
    45&#13;
    &gt;&gt;&gt; # This test checks that the body of the function is just a return statement.&#13;
    &gt;&gt;&gt; import inspect, ast&#13;
    &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body]&#13;
    ['Expr', 'Return']&#13;
    '''&#13;
    return ____&#13;
&#13;
def product_using_accumulate(n, term):&#13;
    '''Returns the product: term(1) * ... * term(n), using accumulate.&#13;
&#13;
    &gt;&gt;&gt; product_using_accumulate(4, square) # square(1) * square(2) * square(3) * square()&#13;
    576&#13;
    &gt;&gt;&gt; product_using_accumulate(6, triple) # triple(1) * triple(2) * ... * triple(5) * triple(6)&#13;
    524880&#13;
    &gt;&gt;&gt; # This test checks that the body of the function is just a return statement.&#13;
    &gt;&gt;&gt; import inspect, ast&#13;
    &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(product_using_accumulate)).body[0].body]&#13;
    ['Expr', 'Return']&#13;
    '''&#13;
    return ____&#13;
&#13;
&#13;
```&#13;
&#13;
Use Ok to test your code:&#13;
&#13;
```&#13;
python3 ok -q accumulate&#13;
python3 ok -q summation_using_accumulate&#13;
python3 ok -q product_using_accumulate&#13;
&#13;
```&#13;
&#13;
:bear: `accumulateï¼š å¯¹productçš„æ¯æ¬¡ç›¸ä¹˜è¡Œä¸ºæ›¿æ¢ä¸ºæŠ½è±¡çš„å‡½æ•°`&#13;
&#13;
```python&#13;
def accumulate(fuse, start, n, term):&#13;
    i, count = 1, start&#13;
    while i &lt;= n:&#13;
        start, i = merger(fuse, term(i)), add(i + 1)&#13;
    return count&#13;
```&#13;
&#13;
:bear: `summation_using_accumulate: productçš„å˜ä½“`&#13;
&#13;
```python&#13;
def summation_using_accumulate(n, term):&#13;
    return accumulate(add, term(0), n, term)&#13;
```&#13;
&#13;
:bear: `sproduct_using_accumulate: productçš„å˜ä½“`&#13;
&#13;
```python&#13;
def product_using_accumulate(n, term):&#13;
 	return accumulate(mul, 1, n, term)&#13;
```&#13;
&#13;
&#13;
&#13;
### Q3: Make Repeater&#13;
&#13;
Implement the function `make_repeater` which takes a one-argument function `f` and a positive integer `n`. It returns a one-argument function, where `make_repeater(f, n)(x)` returns the value of `f(f(...f(x)...))` in which `f` is applied `n` times to `x`. For example, `make_repeater(square, 3)(5)` squares 5 three times and returns 390625, just like `square(square(square(5)))`.&#13;
&#13;
```&#13;
def make_repeater(f, n):&#13;
    '''Returns the function that computes the nth application of f.&#13;
&#13;
    &gt;&gt;&gt; add_three = make_repeater(increment, 3)&#13;
    &gt;&gt;&gt; add_three(5)&#13;
    8&#13;
    &gt;&gt;&gt; make_repeater(triple, 5)(1) # 3 * (3 * (3 * (3 * (3 * 1))))&#13;
    243&#13;
    &gt;&gt;&gt; make_repeater(square, 2)(5) # square(square(5))&#13;
    625&#13;
    &gt;&gt;&gt; make_repeater(square, 3)(5) # square(square(square(5)))&#13;
    390625&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
Use Ok to test your code:&#13;
&#13;
```&#13;
python3 ok -q make_repeater&#13;
&#13;
```&#13;
&#13;
:bear:  &#13;
&#13;
```python&#13;
def make_repeater(f, n):&#13;
    def helper(x):&#13;
        i = n;&#13;
        while i:&#13;
            x = f(x)&#13;
            i = i - 1;&#13;
        return x&#13;
    return helper&#13;
```&#13;
&#13;
&#13;
&#13;
## Recursion&#13;
&#13;
### Q4: Digit Distance&#13;
&#13;
For a given integer, the _digit distance_ is the sum of the absolute differences between consecutive digits. For example:&#13;
&#13;
*   The digit distance of `6` is `0`.&#13;
*   The digit distance of `61` is `5`, as the absolute value of `6 - 1` is `5`.&#13;
*   The digit distance of `71253` is `12` (`6 + 1 + 3 + 2`).&#13;
&#13;
Write a function that determines the digit distance of a given positive integer. You must use recursion or the tests will fail.&#13;
&#13;
**Hint:** There are multiple valid ways of solving this problem! If you're stuck, try writing out an iterative solution first, and then convert your iterative solution into a recursive one.&#13;
&#13;
```&#13;
def digit_distance(n):&#13;
    '''Determines the digit distance of n.&#13;
&#13;
    &gt;&gt;&gt; digit_distance(3)&#13;
    0&#13;
    &gt;&gt;&gt; digit_distance(777)&#13;
    0&#13;
    &gt;&gt;&gt; digit_distance(314)&#13;
    5&#13;
    &gt;&gt;&gt; digit_distance(31415926535)&#13;
    32&#13;
    &gt;&gt;&gt; digit_distance(3464660003)&#13;
    16&#13;
    &gt;&gt;&gt; from construct_check import check&#13;
    &gt;&gt;&gt; # ban all loops&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'digit_distance',&#13;
    ...       ['For', 'While'])&#13;
    True&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
Use Ok to test your code:&#13;
&#13;
```&#13;
python3 ok -q digit_distance&#13;
&#13;
```&#13;
&#13;
:bear:&#13;
&#13;
```python&#13;
def digit_distance(n):&#13;
    if n &lt; 10:&#13;
        return 0&#13;
    else:&#13;
        return abs(sub(n % 10, n // 10 % 10)) + digit_distance(n // 10)&#13;
```&#13;
&#13;
&#13;
&#13;
### Q5: Interleaved Sum&#13;
&#13;
Write a function `interleaved_sum`, which takes in a number `n` and two one-argument functions: `odd_func` and `even_func`. It applies `odd_func` to every odd number and `even_func` to every even number from 1 to `n` _inclusive_ and returns the sum.&#13;
&#13;
For example, executing `interleaved_sum(5, lambda x: x, lambda x: x * x)` returns `1 + 2*2 + 3 + 4*4 + 5 = 29`.&#13;
&#13;
**Important:** Implement this function without using any loops or directly testing if a number is odd or even -- aka modulos (`%`) are not allowed! Instead of directly checking whether a number is even or odd, start with 1, which you know is an odd number.&#13;
&#13;
**Hint:** Introduce an inner helper function that takes an odd number `k` and computes an interleaved sum from `k` to `n` (including `n`).&#13;
&#13;
```&#13;
def interleaved_sum(n, odd_func, even_func):&#13;
    '''Compute the sum odd_func(1) + even_func(2) + odd_func(3) + ..., up&#13;
    to n.&#13;
&#13;
    &gt;&gt;&gt; identity = lambda x: x&#13;
    &gt;&gt;&gt; square = lambda x: x * x&#13;
    &gt;&gt;&gt; triple = lambda x: x * 3&#13;
    &gt;&gt;&gt; interleaved_sum(5, identity, square) # 1   + 2*2 + 3   + 4*4 + 5&#13;
    29&#13;
    &gt;&gt;&gt; interleaved_sum(5, square, identity) # 1*1 + 2   + 3*3 + 4   + 5*5&#13;
    41&#13;
    &gt;&gt;&gt; interleaved_sum(4, triple, square)   # 1*3 + 2*2 + 3*3 + 4*4&#13;
    32&#13;
    &gt;&gt;&gt; interleaved_sum(4, square, triple)   # 1*1 + 2*3 + 3*3 + 4*3&#13;
    28&#13;
    &gt;&gt;&gt; from construct_check import check&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'interleaved_sum', ['While', 'For', 'Mod']) # ban loops and %&#13;
    True&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'interleaved_sum', ['BitAnd', 'BitOr', 'BitXor']) # ban bitwise operators, don't worry about these if you don't know what they are&#13;
    True&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
Use Ok to test your code:&#13;
&#13;
```&#13;
python3 ok -q interleaved_sum&#13;
&#13;
```&#13;
&#13;
:bear:`interleaved_sum`&#13;
&#13;
```python&#13;
def interleaved_sum(n, odd_func, even_func):&#13;
    if n == 0:&#13;
        return 0&#13;
    elif n % 2 == 1:&#13;
        return odd_func(n) + interleaved_sum(n - 1, odd_func, even_func)&#13;
    else:&#13;
        return even_func(n) + interleaved_sum(n - 1, odd_func, even_func)&#13;
&#13;
```&#13;
&#13;
&#13;
&#13;
### Q6: Count Coins&#13;
&#13;
Given a positive integer `total`, a set of coins makes change for `total` if the sum of the values of the coins is `total`. Here we will use standard US Coin values: 1, 5, 10, 25. For example, the following sets make change for `15`:&#13;
&#13;
*   15 1-cent coins&#13;
*   10 1-cent, 1 5-cent coins&#13;
*   5 1-cent, 2 5-cent coins&#13;
*   5 1-cent, 1 10-cent coins&#13;
*   3 5-cent coins&#13;
*   1 5-cent, 1 10-cent coin&#13;
&#13;
Thus, there are 6 ways to make change for `15`. Write a **recursive** function `count_coins` that takes a positive integer `total` and returns the number of ways to make change for `total` using coins.&#13;
&#13;
You can use _either_ of the functions given to you:&#13;
&#13;
*   `next_larger_coin` will return the next larger coin denomination from the input, i.e. `next_larger_coin(5)` is `10`.&#13;
*   `next_smaller_coin` will return the next smaller coin denomination from the input, i.e. `next_smaller_coin(5)` is `1`.&#13;
*   Either function will return `None` if the next coin value does not exist&#13;
&#13;
There are two main ways in which you can approach this problem. One way uses `next_larger_coin`, and another uses `next_smaller_coin`. It is up to you which one you want to use!&#13;
&#13;
**Important:** Use recursion; the tests will fail if you use loops.&#13;
&#13;
**Hint:** Refer to the [implementation](https://www.composingprograms.com/pages/17-recursive-functions.html#example-partitions) of `count_partitions` for an example of how to count the ways to sum up to a final value with smaller parts. If you need to keep track of more than one value across recursive calls, consider writing a helper function.&#13;
&#13;
```&#13;
def next_larger_coin(coin):&#13;
    '''Returns the next larger coin in order.&#13;
    &gt;&gt;&gt; next_larger_coin(1)&#13;
    5&#13;
    &gt;&gt;&gt; next_larger_coin(5)&#13;
    10&#13;
    &gt;&gt;&gt; next_larger_coin(10)&#13;
    25&#13;
    &gt;&gt;&gt; next_larger_coin(2) # Other values return None&#13;
    '''&#13;
    if coin == 1:&#13;
        return 5&#13;
    elif coin == 5:&#13;
        return 10&#13;
    elif coin == 10:&#13;
        return 25&#13;
&#13;
def next_smaller_coin(coin):&#13;
    '''Returns the next smaller coin in order.&#13;
    &gt;&gt;&gt; next_smaller_coin(25)&#13;
    10&#13;
    &gt;&gt;&gt; next_smaller_coin(10)&#13;
    5&#13;
    &gt;&gt;&gt; next_smaller_coin(5)&#13;
    1&#13;
    &gt;&gt;&gt; next_smaller_coin(2) # Other values return None&#13;
    '''&#13;
    if coin == 25:&#13;
        return 10&#13;
    elif coin == 10:&#13;
        return 5&#13;
    elif coin == 5:&#13;
        return 1&#13;
&#13;
def count_coins(total):&#13;
    '''Return the number of ways to make change using coins of value of 1, 5, 10, 25.&#13;
    &gt;&gt;&gt; count_coins(15)&#13;
    6&#13;
    &gt;&gt;&gt; count_coins(10)&#13;
    4&#13;
    &gt;&gt;&gt; count_coins(20)&#13;
    9&#13;
    &gt;&gt;&gt; count_coins(100) # How many ways to make change for a dollar?&#13;
    242&#13;
    &gt;&gt;&gt; count_coins(200)&#13;
    1463&#13;
    &gt;&gt;&gt; from construct_check import check&#13;
    &gt;&gt;&gt; # ban iteration&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'count_coins', ['While', 'For'])&#13;
    True&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
```&#13;
python3 ok -q count_coins&#13;
```&#13;
&#13;
:bear:&#13;
&#13;
```python&#13;
# è¾¹ç•Œæƒ…å†µï¼š ç¡¬å¸ä¸º0ï¼Œæ–¹æ¡ˆæ­£ç¡®ã€‚</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/cs61a-su24-hw02.html</guid><pubDate>Wed, 17 Jul 2024 11:38:44 +0000</pubDate></item><item><title>cs61a-su24-hw01</title><link>https://LianSeKong.github.io/lizi/post/cs61a-su24-hw01.html</link><description>---&#13;
url: https://cs61a.org/hw/hw01/&#13;
title: Homework 1 &#13;
date: 2024-07-17 16:08:34&#13;
tag: &#13;
banner: 'https://images.unsplash.com/photo-1719749937847-ab76d3e0dbb7?crop=entropy&amp;cs=srgb&amp;fm=jpg&amp;ixid=M3w0Njc1ODd8MHwxfHJhbmRvbXx8fHx8fHwxfHwxNzIxMjAzNjE1fA&amp;ixlib=rb-4.0.3&amp;q=85&amp;fit=crop&amp;w=624&amp;max-h=540'&#13;
banner_icon: ğŸ”–&#13;
---&#13;
sr-annote { all: unset; }&#13;
&#13;
_Due by 11:59pm on Wednesday, June 26  &#13;
æˆªæ­¢æ—¥æœŸä¸º 6 æœˆ 26 æ—¥æ˜ŸæœŸä¸‰æ™šä¸Š 11ï¼š59_&#13;
&#13;
## Instructions æŒ‡ç¤º&#13;
&#13;
Download [hw01.zip](https://cs61a.org/hw/hw01/hw01.zip). ä¸‹è½½hw01.zipã€‚</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/cs61a-su24-hw01.html</guid><pubDate>Wed, 17 Jul 2024 08:32:14 +0000</pubDate></item><item><title>ProxyLab</title><link>https://LianSeKong.github.io/lizi/post/ProxyLab.html</link><description>&#13;
&gt; ä½¿ç”¨ä¿¡å·é‡åè°ƒå¯¹å…±äº«èµ„æºçš„è®¿é—®&#13;
&gt; Using Semaphores to Coordinate Access to Shared Resources&#13;
&#13;
1. åŸºæœ¬æ€æƒ³ï¼šçº¿ç¨‹ä½¿ç”¨ä¿¡å·é‡æ“ä½œæ¥é€šçŸ¥å¦ä¸€ä¸ªçº¿ç¨‹æŸä¸ªæ¡ä»¶å·²å˜ä¸ºçœŸ&#13;
2. Basic idea: Thread uses a semaphore operation to notify another thread that some condition has become true&#13;
3. ä½¿ç”¨è®¡æ•°ä¿¡å·é‡æ¥è·Ÿè¸ªèµ„æºçŠ¶æ€å¹¶é€šçŸ¥å…¶ä»–çº¿ç¨‹&#13;
4. Use counting semaphores to keep track of resource state and to notify other threads&#13;
5. ä½¿ç”¨äº’æ–¥é”æ¥ä¿æŠ¤å¯¹èµ„æºçš„è®¿é—®&#13;
6. Use mutex to protect access to resource&#13;
&#13;
&gt; ä¸¤ç§å…¸å‹ä¾‹å­&#13;
&#13;
1. The Producer-Â­Consumer Problem &#13;
2. The Readers-Â­Writers Problem&#13;
&#13;
## The ProducerÂ­â€Consumer&#13;
&#13;
[[25-sync-advanced.pdf#page=4&amp;selection=0,15,10,26|25-sync-advanced, é¡µé¢ 4]]&#13;
&#13;
## The Readers-Â­Writers Problem&#13;
&#13;
[[25-sync-advanced.pdf#page=11&amp;selection=0,15,8,25|25-sync-advanced, é¡µé¢ 11]]&#13;
&#13;
## çº¿ç¨‹å®‰å…¨å‡½æ•°&#13;
&#13;
&gt; å¦‚æœä¸€ä¸ªå‡½æ•°åœ¨è¢«å¤šä¸ªå¹¶å‘çº¿ç¨‹é‡å¤è°ƒç”¨æ—¶æ€»èƒ½äº§ç”Ÿæ­£ç¡®çš„ç»“æœï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯çº¿ç¨‹å®‰å…¨çš„&#13;
&#13;
## çº¿ç¨‹ä¸å®‰å…¨å‡½æ•°&#13;
&#13;
1. ä½¿ç”¨ä¸å®‰å…¨çš„å‡½æ•°&#13;
2. å‡½æ•°è¿”å›é™æ€æŒ‡é’ˆå˜é‡     &#13;
3. å‡½æ•°ä¸ä¿æŠ¤å…±äº«å˜é‡çš„è®¿é—®&#13;
4. å‡½æ•°ç»´æŒçŠ¶æ€é€šè¿‡å¤šæ¬¡è°ƒç”¨ ï¼ˆæ“ä½œé™æ€å˜é‡ï¼‰&#13;
&#13;
## reentrant &#13;
&#13;
&gt; å¯é‡å…¥å‡½æ•°ï¼š å±äºçº¿ç¨‹å®‰å…¨å‡½æ•°ï¼Œä¸éœ€è¦åŒæ­¥æ“ä½œï¼Œä¸è®¿é—®å…±äº«å˜é‡ã€‚</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/ProxyLab.html</guid><pubDate>Wed, 17 Jul 2024 07:17:38 +0000</pubDate></item></channel></rss>