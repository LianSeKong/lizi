<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <link rel="icon" href="https://img.icons8.com/doodle/480/mugman.png"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="## Instructions

Download [hw02.zip](https://cs61a.org/hw/hw02/hw02.zip). Inside the archive, you will find a file called [hw02.py](https://cs61a.org/hw/hw02/hw02.py), along with a copy of the `ok` autograder.

**Submission:** When you are done, submit the assignment by uploading all code files you've edited to Gradescope. You may submit more than once before the deadline; only the final submission will be scored. Check that you have successfully submitted your code on Gradescope. See [Lab 0](https://cs61a.org/lab/lab00#task-c-submitting-the-assignment) for more instructions on submitting assignments.

**Using Ok:** If you have any questions about using Ok, please refer to [this guide.](https://cs61a.org/articles/using-ok)

**Readings:** You might find the following references useful:

*   [Section 1.6](https://www.composingprograms.com/pages/16-higher-order-functions.html)
*   [Section 1.7](https://www.composingprograms.com/pages/17-recursive-functions.html)

**Grading:** Homework is graded based on correctness. Each incorrect problem will decrease the total score by one point. **This homework is out of 2 points.**

Several doctests refer to these functions:

```
from operator import add, mul

square = lambda x: x * x

identity = lambda x: x

triple = lambda x: 3 * x

increment = lambda x: x + 1

```

## Higher-Order Functions

### Q1: Product

Write a function called `product` that returns the product of the first `n` terms of a sequence. Specifically, `product` takes in an integer `n` and `term`, a single-argument function that determines a sequence. (That is, `term(i)` gives the `i`th term of the sequence.) `product(n, term)` should return `term(1) * ... * term(n)`.

```
def product(n, term):
    '''Return the product of the first n terms in a sequence.

    n: a positive integer
    term:  a function that takes one argument to produce the term

    >>> product(3, identity)  # 1 * 2 * 3
    6
    >>> product(5, identity)  # 1 * 2 * 3 * 4 * 5
    120
    >>> product(3, square)    # 1^2 * 2^2 * 3^2
    36
    >>> product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2
    14400
    >>> product(3, increment) # (1+1) * (2+1) * (3+1)
    24
    >>> product(3, triple)    # 1*3 * 2*3 * 3*3
    162
    '''
    '*** YOUR CODE HERE ***'


```

Use Ok to test your code:

```
python3 ok -q product

```

:bear: <u>比较简单，就不解释了</u>

```python
def product(n, term):
    i, count = 1, 1
    while i <= n:
        count, i = mul(count, term(i)), add(i, 1)
    return count
```

### Q2: Accumulate

Let's take a look at how `product` is an instance of a more general function called `accumulate`, which we would like to implement:

```
def accumulate(fuse, start, n, term):
    '''Return the result of fusing together the first n terms in a sequence 
    and start.  The terms to be fused are term(1), term(2), ..., term(n). 
    The function fuse is a two-argument commutative & associative function.

    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5
    15
    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5
    26
    >>> accumulate(add, 11, 0, identity) # 11 (fuse is never used)
    11
    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2
    25
    >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2
    72
    >>> # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1)
    >>> accumulate(lambda x, y: x + y + 1, 2, 3, square)
    19
    '''
    '*** YOUR CODE HERE ***'


```

`accumulate` has the following parameters:

*   `fuse`: a two-argument function that specifies how the current term is fused with the previously accumulated terms
*   `start`: value at which to start the accumulation
*   `n`: a non-negative integer indicating the number of terms to fuse
*   `term`: a single-argument function; `term(i)` is the `i`th term of the sequence

Implement `accumulate`, which fuses the first `n` terms of the sequence defined by `term` with the `start` value using the `fuse` function.

For example, the result of `accumulate(add, 11, 3, square)` is

```
add(11,  add(square(1), add(square(2),  square(3)))) =
    11 +     square(1) +    square(2) + square(3)    =
    11 +     1         +    4         + 9            = 25

```

Assume that `fuse` is commutative, `fuse(a, b) == fuse(b, a)`, and associative, `fuse(fuse(a, b), c) == fuse(a, fuse(b, c))`.

Then, implement `summation` (from lecture) and `product` as one-line calls to `accumulate`.

**Important:** Both `summation_using_accumulate` and `product_using_accumulate` should be implemented with a single line of code starting with `return`.

```
def summation_using_accumulate(n, term):
    '''Returns the sum: term(1) + ... + term(n), using accumulate.

    >>> summation_using_accumulate(5, square) # square(0) + square(1) + ... + square(4) + square(5)
    55
    >>> summation_using_accumulate(5, triple) # triple(0) + triple(1) + ... + triple(4) + triple(5)
    45
    >>> # This test checks that the body of the function is just a return statement.
    >>> import inspect, ast
    >>> [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body]
    ['Expr', 'Return']
    '''
    return ____

def product_using_accumulate(n, term):
    '''Returns the product: term(1) * ... * term(n), using accumulate.

    >>> product_using_accumulate(4, square) # square(1) * square(2) * square(3) * square()
    576
    >>> product_using_accumulate(6, triple) # triple(1) * triple(2) * ... * triple(5) * triple(6)
    524880
    >>> # This test checks that the body of the function is just a return statement.
    >>> import inspect, ast
    >>> [type(x).__name__ for x in ast.parse(inspect.getsource(product_using_accumulate)).body[0].body]
    ['Expr', 'Return']
    '''
    return ____


```

Use Ok to test your code:

```
python3 ok -q accumulate
python3 ok -q summation_using_accumulate
python3 ok -q product_using_accumulate

```

:bear: `accumulate： 对product的每次相乘行为替换为抽象的函数`

```python
def accumulate(fuse, start, n, term):
    i, count = 1, start
    while i <= n:
        start, i = merger(fuse, term(i)), add(i + 1)
    return count
```

:bear: `summation_using_accumulate: product的变体`

```python
def summation_using_accumulate(n, term):
    return accumulate(add, term(0), n, term)
```

:bear: `sproduct_using_accumulate: product的变体`

```python
def product_using_accumulate(n, term):
 	return accumulate(mul, 1, n, term)
```



### Q3: Make Repeater

Implement the function `make_repeater` which takes a one-argument function `f` and a positive integer `n`. It returns a one-argument function, where `make_repeater(f, n)(x)` returns the value of `f(f(...f(x)...))` in which `f` is applied `n` times to `x`. For example, `make_repeater(square, 3)(5)` squares 5 three times and returns 390625, just like `square(square(square(5)))`.

```
def make_repeater(f, n):
    '''Returns the function that computes the nth application of f.

    >>> add_three = make_repeater(increment, 3)
    >>> add_three(5)
    8
    >>> make_repeater(triple, 5)(1) # 3 * (3 * (3 * (3 * (3 * 1))))
    243
    >>> make_repeater(square, 2)(5) # square(square(5))
    625
    >>> make_repeater(square, 3)(5) # square(square(square(5)))
    390625
    '''
    '*** YOUR CODE HERE ***'


```

Use Ok to test your code:

```
python3 ok -q make_repeater

```

:bear:  

```python
def make_repeater(f, n):
    def helper(x):
        i = n;
        while i:
            x = f(x)
            i = i - 1;
        return x
    return helper
```



## Recursion

### Q4: Digit Distance

For a given integer, the _digit distance_ is the sum of the absolute differences between consecutive digits. For example:

*   The digit distance of `6` is `0`.
*   The digit distance of `61` is `5`, as the absolute value of `6 - 1` is `5`.
*   The digit distance of `71253` is `12` (`6 + 1 + 3 + 2`).

Write a function that determines the digit distance of a given positive integer. You must use recursion or the tests will fail.

**Hint:** There are multiple valid ways of solving this problem! If you're stuck, try writing out an iterative solution first, and then convert your iterative solution into a recursive one.

```
def digit_distance(n):
    '''Determines the digit distance of n.

    >>> digit_distance(3)
    0
    >>> digit_distance(777)
    0
    >>> digit_distance(314)
    5
    >>> digit_distance(31415926535)
    32
    >>> digit_distance(3464660003)
    16
    >>> from construct_check import check
    >>> # ban all loops
    >>> check(HW_SOURCE_FILE, 'digit_distance',
    ...       ['For', 'While'])
    True
    '''
    '*** YOUR CODE HERE ***'


```

Use Ok to test your code:

```
python3 ok -q digit_distance

```

:bear:

```python
def digit_distance(n):
    if n < 10:
        return 0
    else:
        return abs(sub(n % 10, n // 10 % 10)) + digit_distance(n // 10)
```



### Q5: Interleaved Sum

Write a function `interleaved_sum`, which takes in a number `n` and two one-argument functions: `odd_func` and `even_func`. It applies `odd_func` to every odd number and `even_func` to every even number from 1 to `n` _inclusive_ and returns the sum.

For example, executing `interleaved_sum(5, lambda x: x, lambda x: x * x)` returns `1 + 2*2 + 3 + 4*4 + 5 = 29`.

**Important:** Implement this function without using any loops or directly testing if a number is odd or even -- aka modulos (`%`) are not allowed! Instead of directly checking whether a number is even or odd, start with 1, which you know is an odd number.

**Hint:** Introduce an inner helper function that takes an odd number `k` and computes an interleaved sum from `k` to `n` (including `n`).

```
def interleaved_sum(n, odd_func, even_func):
    '''Compute the sum odd_func(1) + even_func(2) + odd_func(3) + ..., up
    to n.

    >>> identity = lambda x: x
    >>> square = lambda x: x * x
    >>> triple = lambda x: x * 3
    >>> interleaved_sum(5, identity, square) # 1   + 2*2 + 3   + 4*4 + 5
    29
    >>> interleaved_sum(5, square, identity) # 1*1 + 2   + 3*3 + 4   + 5*5
    41
    >>> interleaved_sum(4, triple, square)   # 1*3 + 2*2 + 3*3 + 4*4
    32
    >>> interleaved_sum(4, square, triple)   # 1*1 + 2*3 + 3*3 + 4*3
    28
    >>> from construct_check import check
    >>> check(HW_SOURCE_FILE, 'interleaved_sum', ['While', 'For', 'Mod']) # ban loops and %
    True
    >>> check(HW_SOURCE_FILE, 'interleaved_sum', ['BitAnd', 'BitOr', 'BitXor']) # ban bitwise operators, don't worry about these if you don't know what they are
    True
    '''
    '*** YOUR CODE HERE ***'


```

Use Ok to test your code:

```
python3 ok -q interleaved_sum

```

:bear:`interleaved_sum`

```python
def interleaved_sum(n, odd_func, even_func):
    if n == 0:
        return 0
    elif n % 2 == 1:
        return odd_func(n) + interleaved_sum(n - 1, odd_func, even_func)
    else:
        return even_func(n) + interleaved_sum(n - 1, odd_func, even_func)

```



### Q6: Count Coins

Given a positive integer `total`, a set of coins makes change for `total` if the sum of the values of the coins is `total`. Here we will use standard US Coin values: 1, 5, 10, 25. For example, the following sets make change for `15`:

*   15 1-cent coins
*   10 1-cent, 1 5-cent coins
*   5 1-cent, 2 5-cent coins
*   5 1-cent, 1 10-cent coins
*   3 5-cent coins
*   1 5-cent, 1 10-cent coin

Thus, there are 6 ways to make change for `15`. Write a **recursive** function `count_coins` that takes a positive integer `total` and returns the number of ways to make change for `total` using coins.

You can use _either_ of the functions given to you:

*   `next_larger_coin` will return the next larger coin denomination from the input, i.e. `next_larger_coin(5)` is `10`.
*   `next_smaller_coin` will return the next smaller coin denomination from the input, i.e. `next_smaller_coin(5)` is `1`.
*   Either function will return `None` if the next coin value does not exist

There are two main ways in which you can approach this problem. One way uses `next_larger_coin`, and another uses `next_smaller_coin`. It is up to you which one you want to use!

**Important:** Use recursion; the tests will fail if you use loops.

**Hint:** Refer to the [implementation](https://www.composingprograms.com/pages/17-recursive-functions.html#example-partitions) of `count_partitions` for an example of how to count the ways to sum up to a final value with smaller parts. If you need to keep track of more than one value across recursive calls, consider writing a helper function.

```
def next_larger_coin(coin):
    '''Returns the next larger coin in order.
    >>> next_larger_coin(1)
    5
    >>> next_larger_coin(5)
    10
    >>> next_larger_coin(10)
    25
    >>> next_larger_coin(2) # Other values return None
    '''
    if coin == 1:
        return 5
    elif coin == 5:
        return 10
    elif coin == 10:
        return 25

def next_smaller_coin(coin):
    '''Returns the next smaller coin in order.
    >>> next_smaller_coin(25)
    10
    >>> next_smaller_coin(10)
    5
    >>> next_smaller_coin(5)
    1
    >>> next_smaller_coin(2) # Other values return None
    '''
    if coin == 25:
        return 10
    elif coin == 10:
        return 5
    elif coin == 5:
        return 1

def count_coins(total):
    '''Return the number of ways to make change using coins of value of 1, 5, 10, 25.
    >>> count_coins(15)
    6
    >>> count_coins(10)
    4
    >>> count_coins(20)
    9
    >>> count_coins(100) # How many ways to make change for a dollar?
    242
    >>> count_coins(200)
    1463
    >>> from construct_check import check
    >>> # ban iteration
    >>> check(HW_SOURCE_FILE, 'count_coins', ['While', 'For'])
    True
    '''
    '*** YOUR CODE HERE ***'


```

```
python3 ok -q count_coins
```

:bear:

```python
# 边界情况： 硬币为0，方案正确。">
<meta property="og:title" content="cs61a-su24-hw02">
<meta property="og:description" content="## Instructions

Download [hw02.zip](https://cs61a.org/hw/hw02/hw02.zip). Inside the archive, you will find a file called [hw02.py](https://cs61a.org/hw/hw02/hw02.py), along with a copy of the `ok` autograder.

**Submission:** When you are done, submit the assignment by uploading all code files you've edited to Gradescope. You may submit more than once before the deadline; only the final submission will be scored. Check that you have successfully submitted your code on Gradescope. See [Lab 0](https://cs61a.org/lab/lab00#task-c-submitting-the-assignment) for more instructions on submitting assignments.

**Using Ok:** If you have any questions about using Ok, please refer to [this guide.](https://cs61a.org/articles/using-ok)

**Readings:** You might find the following references useful:

*   [Section 1.6](https://www.composingprograms.com/pages/16-higher-order-functions.html)
*   [Section 1.7](https://www.composingprograms.com/pages/17-recursive-functions.html)

**Grading:** Homework is graded based on correctness. Each incorrect problem will decrease the total score by one point. **This homework is out of 2 points.**

Several doctests refer to these functions:

```
from operator import add, mul

square = lambda x: x * x

identity = lambda x: x

triple = lambda x: 3 * x

increment = lambda x: x + 1

```

## Higher-Order Functions

### Q1: Product

Write a function called `product` that returns the product of the first `n` terms of a sequence. Specifically, `product` takes in an integer `n` and `term`, a single-argument function that determines a sequence. (That is, `term(i)` gives the `i`th term of the sequence.) `product(n, term)` should return `term(1) * ... * term(n)`.

```
def product(n, term):
    '''Return the product of the first n terms in a sequence.

    n: a positive integer
    term:  a function that takes one argument to produce the term

    >>> product(3, identity)  # 1 * 2 * 3
    6
    >>> product(5, identity)  # 1 * 2 * 3 * 4 * 5
    120
    >>> product(3, square)    # 1^2 * 2^2 * 3^2
    36
    >>> product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2
    14400
    >>> product(3, increment) # (1+1) * (2+1) * (3+1)
    24
    >>> product(3, triple)    # 1*3 * 2*3 * 3*3
    162
    '''
    '*** YOUR CODE HERE ***'


```

Use Ok to test your code:

```
python3 ok -q product

```

:bear: <u>比较简单，就不解释了</u>

```python
def product(n, term):
    i, count = 1, 1
    while i <= n:
        count, i = mul(count, term(i)), add(i, 1)
    return count
```

### Q2: Accumulate

Let's take a look at how `product` is an instance of a more general function called `accumulate`, which we would like to implement:

```
def accumulate(fuse, start, n, term):
    '''Return the result of fusing together the first n terms in a sequence 
    and start.  The terms to be fused are term(1), term(2), ..., term(n). 
    The function fuse is a two-argument commutative & associative function.

    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5
    15
    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5
    26
    >>> accumulate(add, 11, 0, identity) # 11 (fuse is never used)
    11
    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2
    25
    >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2
    72
    >>> # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1)
    >>> accumulate(lambda x, y: x + y + 1, 2, 3, square)
    19
    '''
    '*** YOUR CODE HERE ***'


```

`accumulate` has the following parameters:

*   `fuse`: a two-argument function that specifies how the current term is fused with the previously accumulated terms
*   `start`: value at which to start the accumulation
*   `n`: a non-negative integer indicating the number of terms to fuse
*   `term`: a single-argument function; `term(i)` is the `i`th term of the sequence

Implement `accumulate`, which fuses the first `n` terms of the sequence defined by `term` with the `start` value using the `fuse` function.

For example, the result of `accumulate(add, 11, 3, square)` is

```
add(11,  add(square(1), add(square(2),  square(3)))) =
    11 +     square(1) +    square(2) + square(3)    =
    11 +     1         +    4         + 9            = 25

```

Assume that `fuse` is commutative, `fuse(a, b) == fuse(b, a)`, and associative, `fuse(fuse(a, b), c) == fuse(a, fuse(b, c))`.

Then, implement `summation` (from lecture) and `product` as one-line calls to `accumulate`.

**Important:** Both `summation_using_accumulate` and `product_using_accumulate` should be implemented with a single line of code starting with `return`.

```
def summation_using_accumulate(n, term):
    '''Returns the sum: term(1) + ... + term(n), using accumulate.

    >>> summation_using_accumulate(5, square) # square(0) + square(1) + ... + square(4) + square(5)
    55
    >>> summation_using_accumulate(5, triple) # triple(0) + triple(1) + ... + triple(4) + triple(5)
    45
    >>> # This test checks that the body of the function is just a return statement.
    >>> import inspect, ast
    >>> [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body]
    ['Expr', 'Return']
    '''
    return ____

def product_using_accumulate(n, term):
    '''Returns the product: term(1) * ... * term(n), using accumulate.

    >>> product_using_accumulate(4, square) # square(1) * square(2) * square(3) * square()
    576
    >>> product_using_accumulate(6, triple) # triple(1) * triple(2) * ... * triple(5) * triple(6)
    524880
    >>> # This test checks that the body of the function is just a return statement.
    >>> import inspect, ast
    >>> [type(x).__name__ for x in ast.parse(inspect.getsource(product_using_accumulate)).body[0].body]
    ['Expr', 'Return']
    '''
    return ____


```

Use Ok to test your code:

```
python3 ok -q accumulate
python3 ok -q summation_using_accumulate
python3 ok -q product_using_accumulate

```

:bear: `accumulate： 对product的每次相乘行为替换为抽象的函数`

```python
def accumulate(fuse, start, n, term):
    i, count = 1, start
    while i <= n:
        start, i = merger(fuse, term(i)), add(i + 1)
    return count
```

:bear: `summation_using_accumulate: product的变体`

```python
def summation_using_accumulate(n, term):
    return accumulate(add, term(0), n, term)
```

:bear: `sproduct_using_accumulate: product的变体`

```python
def product_using_accumulate(n, term):
 	return accumulate(mul, 1, n, term)
```



### Q3: Make Repeater

Implement the function `make_repeater` which takes a one-argument function `f` and a positive integer `n`. It returns a one-argument function, where `make_repeater(f, n)(x)` returns the value of `f(f(...f(x)...))` in which `f` is applied `n` times to `x`. For example, `make_repeater(square, 3)(5)` squares 5 three times and returns 390625, just like `square(square(square(5)))`.

```
def make_repeater(f, n):
    '''Returns the function that computes the nth application of f.

    >>> add_three = make_repeater(increment, 3)
    >>> add_three(5)
    8
    >>> make_repeater(triple, 5)(1) # 3 * (3 * (3 * (3 * (3 * 1))))
    243
    >>> make_repeater(square, 2)(5) # square(square(5))
    625
    >>> make_repeater(square, 3)(5) # square(square(square(5)))
    390625
    '''
    '*** YOUR CODE HERE ***'


```

Use Ok to test your code:

```
python3 ok -q make_repeater

```

:bear:  

```python
def make_repeater(f, n):
    def helper(x):
        i = n;
        while i:
            x = f(x)
            i = i - 1;
        return x
    return helper
```



## Recursion

### Q4: Digit Distance

For a given integer, the _digit distance_ is the sum of the absolute differences between consecutive digits. For example:

*   The digit distance of `6` is `0`.
*   The digit distance of `61` is `5`, as the absolute value of `6 - 1` is `5`.
*   The digit distance of `71253` is `12` (`6 + 1 + 3 + 2`).

Write a function that determines the digit distance of a given positive integer. You must use recursion or the tests will fail.

**Hint:** There are multiple valid ways of solving this problem! If you're stuck, try writing out an iterative solution first, and then convert your iterative solution into a recursive one.

```
def digit_distance(n):
    '''Determines the digit distance of n.

    >>> digit_distance(3)
    0
    >>> digit_distance(777)
    0
    >>> digit_distance(314)
    5
    >>> digit_distance(31415926535)
    32
    >>> digit_distance(3464660003)
    16
    >>> from construct_check import check
    >>> # ban all loops
    >>> check(HW_SOURCE_FILE, 'digit_distance',
    ...       ['For', 'While'])
    True
    '''
    '*** YOUR CODE HERE ***'


```

Use Ok to test your code:

```
python3 ok -q digit_distance

```

:bear:

```python
def digit_distance(n):
    if n < 10:
        return 0
    else:
        return abs(sub(n % 10, n // 10 % 10)) + digit_distance(n // 10)
```



### Q5: Interleaved Sum

Write a function `interleaved_sum`, which takes in a number `n` and two one-argument functions: `odd_func` and `even_func`. It applies `odd_func` to every odd number and `even_func` to every even number from 1 to `n` _inclusive_ and returns the sum.

For example, executing `interleaved_sum(5, lambda x: x, lambda x: x * x)` returns `1 + 2*2 + 3 + 4*4 + 5 = 29`.

**Important:** Implement this function without using any loops or directly testing if a number is odd or even -- aka modulos (`%`) are not allowed! Instead of directly checking whether a number is even or odd, start with 1, which you know is an odd number.

**Hint:** Introduce an inner helper function that takes an odd number `k` and computes an interleaved sum from `k` to `n` (including `n`).

```
def interleaved_sum(n, odd_func, even_func):
    '''Compute the sum odd_func(1) + even_func(2) + odd_func(3) + ..., up
    to n.

    >>> identity = lambda x: x
    >>> square = lambda x: x * x
    >>> triple = lambda x: x * 3
    >>> interleaved_sum(5, identity, square) # 1   + 2*2 + 3   + 4*4 + 5
    29
    >>> interleaved_sum(5, square, identity) # 1*1 + 2   + 3*3 + 4   + 5*5
    41
    >>> interleaved_sum(4, triple, square)   # 1*3 + 2*2 + 3*3 + 4*4
    32
    >>> interleaved_sum(4, square, triple)   # 1*1 + 2*3 + 3*3 + 4*3
    28
    >>> from construct_check import check
    >>> check(HW_SOURCE_FILE, 'interleaved_sum', ['While', 'For', 'Mod']) # ban loops and %
    True
    >>> check(HW_SOURCE_FILE, 'interleaved_sum', ['BitAnd', 'BitOr', 'BitXor']) # ban bitwise operators, don't worry about these if you don't know what they are
    True
    '''
    '*** YOUR CODE HERE ***'


```

Use Ok to test your code:

```
python3 ok -q interleaved_sum

```

:bear:`interleaved_sum`

```python
def interleaved_sum(n, odd_func, even_func):
    if n == 0:
        return 0
    elif n % 2 == 1:
        return odd_func(n) + interleaved_sum(n - 1, odd_func, even_func)
    else:
        return even_func(n) + interleaved_sum(n - 1, odd_func, even_func)

```



### Q6: Count Coins

Given a positive integer `total`, a set of coins makes change for `total` if the sum of the values of the coins is `total`. Here we will use standard US Coin values: 1, 5, 10, 25. For example, the following sets make change for `15`:

*   15 1-cent coins
*   10 1-cent, 1 5-cent coins
*   5 1-cent, 2 5-cent coins
*   5 1-cent, 1 10-cent coins
*   3 5-cent coins
*   1 5-cent, 1 10-cent coin

Thus, there are 6 ways to make change for `15`. Write a **recursive** function `count_coins` that takes a positive integer `total` and returns the number of ways to make change for `total` using coins.

You can use _either_ of the functions given to you:

*   `next_larger_coin` will return the next larger coin denomination from the input, i.e. `next_larger_coin(5)` is `10`.
*   `next_smaller_coin` will return the next smaller coin denomination from the input, i.e. `next_smaller_coin(5)` is `1`.
*   Either function will return `None` if the next coin value does not exist

There are two main ways in which you can approach this problem. One way uses `next_larger_coin`, and another uses `next_smaller_coin`. It is up to you which one you want to use!

**Important:** Use recursion; the tests will fail if you use loops.

**Hint:** Refer to the [implementation](https://www.composingprograms.com/pages/17-recursive-functions.html#example-partitions) of `count_partitions` for an example of how to count the ways to sum up to a final value with smaller parts. If you need to keep track of more than one value across recursive calls, consider writing a helper function.

```
def next_larger_coin(coin):
    '''Returns the next larger coin in order.
    >>> next_larger_coin(1)
    5
    >>> next_larger_coin(5)
    10
    >>> next_larger_coin(10)
    25
    >>> next_larger_coin(2) # Other values return None
    '''
    if coin == 1:
        return 5
    elif coin == 5:
        return 10
    elif coin == 10:
        return 25

def next_smaller_coin(coin):
    '''Returns the next smaller coin in order.
    >>> next_smaller_coin(25)
    10
    >>> next_smaller_coin(10)
    5
    >>> next_smaller_coin(5)
    1
    >>> next_smaller_coin(2) # Other values return None
    '''
    if coin == 25:
        return 10
    elif coin == 10:
        return 5
    elif coin == 5:
        return 1

def count_coins(total):
    '''Return the number of ways to make change using coins of value of 1, 5, 10, 25.
    >>> count_coins(15)
    6
    >>> count_coins(10)
    4
    >>> count_coins(20)
    9
    >>> count_coins(100) # How many ways to make change for a dollar?
    242
    >>> count_coins(200)
    1463
    >>> from construct_check import check
    >>> # ban iteration
    >>> check(HW_SOURCE_FILE, 'count_coins', ['While', 'For'])
    True
    '''
    '*** YOUR CODE HERE ***'


```

```
python3 ok -q count_coins
```

:bear:

```python
# 边界情况： 硬币为0，方案正确。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://LianSeKong.github.io/lizi/post/cs61a-su24-hw02.html">
<meta property="og:image" content="https://img.icons8.com/doodle/480/mugman.png">
<title>cs61a-su24-hw02</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />

</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">cs61a-su24-hw02</h1>
<div class="title-right">
    <a href="https://LianSeKong.github.io/lizi" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/LianSeKong/lizi/issues/3" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h2>Instructions</h2>
<p>Download <a href="https://cs61a.org/hw/hw02/hw02.zip" rel="nofollow">hw02.zip</a>. Inside the archive, you will find a file called <a href="https://cs61a.org/hw/hw02/hw02.py" rel="nofollow">hw02.py</a>, along with a copy of the <code class="notranslate">ok</code> autograder.</p>
<p><strong>Submission:</strong> When you are done, submit the assignment by uploading all code files you've edited to Gradescope. You may submit more than once before the deadline; only the final submission will be scored. Check that you have successfully submitted your code on Gradescope. See <a href="https://cs61a.org/lab/lab00#task-c-submitting-the-assignment" rel="nofollow">Lab 0</a> for more instructions on submitting assignments.</p>
<p><strong>Using Ok:</strong> If you have any questions about using Ok, please refer to <a href="https://cs61a.org/articles/using-ok" rel="nofollow">this guide.</a></p>
<p><strong>Readings:</strong> You might find the following references useful:</p>
<ul>
<li><a href="https://www.composingprograms.com/pages/16-higher-order-functions.html" rel="nofollow">Section 1.6</a></li>
<li><a href="https://www.composingprograms.com/pages/17-recursive-functions.html" rel="nofollow">Section 1.7</a></li>
</ul>
<p><strong>Grading:</strong> Homework is graded based on correctness. Each incorrect problem will decrease the total score by one point. <strong>This homework is out of 2 points.</strong></p>
<p>Several doctests refer to these functions:</p>
<pre class="notranslate"><code class="notranslate">from operator import add, mul

square = lambda x: x * x

identity = lambda x: x

triple = lambda x: 3 * x

increment = lambda x: x + 1

</code></pre>
<h2>Higher-Order Functions</h2>
<h3>Q1: Product</h3>
<p>Write a function called <code class="notranslate">product</code> that returns the product of the first <code class="notranslate">n</code> terms of a sequence. Specifically, <code class="notranslate">product</code> takes in an integer <code class="notranslate">n</code> and <code class="notranslate">term</code>, a single-argument function that determines a sequence. (That is, <code class="notranslate">term(i)</code> gives the <code class="notranslate">i</code>th term of the sequence.) <code class="notranslate">product(n, term)</code> should return <code class="notranslate">term(1) * ... * term(n)</code>.</p>
<pre class="notranslate"><code class="notranslate">def product(n, term):
    """Return the product of the first n terms in a sequence.

    n: a positive integer
    term:  a function that takes one argument to produce the term

    &gt;&gt;&gt; product(3, identity)  # 1 * 2 * 3
    6
    &gt;&gt;&gt; product(5, identity)  # 1 * 2 * 3 * 4 * 5
    120
    &gt;&gt;&gt; product(3, square)    # 1^2 * 2^2 * 3^2
    36
    &gt;&gt;&gt; product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2
    14400
    &gt;&gt;&gt; product(3, increment) # (1+1) * (2+1) * (3+1)
    24
    &gt;&gt;&gt; product(3, triple)    # 1*3 * 2*3 * 3*3
    162
    """
    "*** YOUR CODE HERE ***"


</code></pre>
<p>Use Ok to test your code:</p>
<pre class="notranslate"><code class="notranslate">python3 ok -q product

</code></pre>
<p>🐻 比较简单，就不解释了</p>
<div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-k">def</span> <span class="pl-en">product</span>(<span class="pl-s1">n</span>, <span class="pl-s1">term</span>):
    <span class="pl-s1">i</span>, <span class="pl-s1">count</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span>, <span class="pl-c1">1</span>
    <span class="pl-k">while</span> <span class="pl-s1">i</span> <span class="pl-c1">&lt;=</span> <span class="pl-s1">n</span>:
        <span class="pl-s1">count</span>, <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-en">mul</span>(<span class="pl-s1">count</span>, <span class="pl-en">term</span>(<span class="pl-s1">i</span>)), <span class="pl-en">add</span>(<span class="pl-s1">i</span>, <span class="pl-c1">1</span>)
    <span class="pl-k">return</span> <span class="pl-s1">count</span></pre></div>
<h3>Q2: Accumulate</h3>
<p>Let's take a look at how <code class="notranslate">product</code> is an instance of a more general function called <code class="notranslate">accumulate</code>, which we would like to implement:</p>
<pre class="notranslate"><code class="notranslate">def accumulate(fuse, start, n, term):
    """Return the result of fusing together the first n terms in a sequence 
    and start.  The terms to be fused are term(1), term(2), ..., term(n). 
    The function fuse is a two-argument commutative &amp; associative function.

    &gt;&gt;&gt; accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5
    15
    &gt;&gt;&gt; accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5
    26
    &gt;&gt;&gt; accumulate(add, 11, 0, identity) # 11 (fuse is never used)
    11
    &gt;&gt;&gt; accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2
    25
    &gt;&gt;&gt; accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2
    72
    &gt;&gt;&gt; # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1)
    &gt;&gt;&gt; accumulate(lambda x, y: x + y + 1, 2, 3, square)
    19
    """
    "*** YOUR CODE HERE ***"


</code></pre>
<p><code class="notranslate">accumulate</code> has the following parameters:</p>
<ul>
<li><code class="notranslate">fuse</code>: a two-argument function that specifies how the current term is fused with the previously accumulated terms</li>
<li><code class="notranslate">start</code>: value at which to start the accumulation</li>
<li><code class="notranslate">n</code>: a non-negative integer indicating the number of terms to fuse</li>
<li><code class="notranslate">term</code>: a single-argument function; <code class="notranslate">term(i)</code> is the <code class="notranslate">i</code>th term of the sequence</li>
</ul>
<p>Implement <code class="notranslate">accumulate</code>, which fuses the first <code class="notranslate">n</code> terms of the sequence defined by <code class="notranslate">term</code> with the <code class="notranslate">start</code> value using the <code class="notranslate">fuse</code> function.</p>
<p>For example, the result of <code class="notranslate">accumulate(add, 11, 3, square)</code> is</p>
<pre class="notranslate"><code class="notranslate">add(11,  add(square(1), add(square(2),  square(3)))) =
    11 +     square(1) +    square(2) + square(3)    =
    11 +     1         +    4         + 9            = 25

</code></pre>
<p>Assume that <code class="notranslate">fuse</code> is commutative, <code class="notranslate">fuse(a, b) == fuse(b, a)</code>, and associative, <code class="notranslate">fuse(fuse(a, b), c) == fuse(a, fuse(b, c))</code>.</p>
<p>Then, implement <code class="notranslate">summation</code> (from lecture) and <code class="notranslate">product</code> as one-line calls to <code class="notranslate">accumulate</code>.</p>
<p><strong>Important:</strong> Both <code class="notranslate">summation_using_accumulate</code> and <code class="notranslate">product_using_accumulate</code> should be implemented with a single line of code starting with <code class="notranslate">return</code>.</p>
<pre class="notranslate"><code class="notranslate">def summation_using_accumulate(n, term):
    """Returns the sum: term(1) + ... + term(n), using accumulate.

    &gt;&gt;&gt; summation_using_accumulate(5, square) # square(0) + square(1) + ... + square(4) + square(5)
    55
    &gt;&gt;&gt; summation_using_accumulate(5, triple) # triple(0) + triple(1) + ... + triple(4) + triple(5)
    45
    &gt;&gt;&gt; # This test checks that the body of the function is just a return statement.
    &gt;&gt;&gt; import inspect, ast
    &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body]
    ['Expr', 'Return']
    """
    return ____

def product_using_accumulate(n, term):
    """Returns the product: term(1) * ... * term(n), using accumulate.

    &gt;&gt;&gt; product_using_accumulate(4, square) # square(1) * square(2) * square(3) * square()
    576
    &gt;&gt;&gt; product_using_accumulate(6, triple) # triple(1) * triple(2) * ... * triple(5) * triple(6)
    524880
    &gt;&gt;&gt; # This test checks that the body of the function is just a return statement.
    &gt;&gt;&gt; import inspect, ast
    &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(product_using_accumulate)).body[0].body]
    ['Expr', 'Return']
    """
    return ____


</code></pre>
<p>Use Ok to test your code:</p>
<pre class="notranslate"><code class="notranslate">python3 ok -q accumulate
python3 ok -q summation_using_accumulate
python3 ok -q product_using_accumulate

</code></pre>
<p>🐻 <code class="notranslate">accumulate： 对product的每次相乘行为替换为抽象的函数</code></p>
<div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-k">def</span> <span class="pl-en">accumulate</span>(<span class="pl-s1">fuse</span>, <span class="pl-s1">start</span>, <span class="pl-s1">n</span>, <span class="pl-s1">term</span>):
    <span class="pl-s1">i</span>, <span class="pl-s1">count</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span>, <span class="pl-s1">start</span>
    <span class="pl-k">while</span> <span class="pl-s1">i</span> <span class="pl-c1">&lt;=</span> <span class="pl-s1">n</span>:
        <span class="pl-s1">start</span>, <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-en">merger</span>(<span class="pl-s1">fuse</span>, <span class="pl-en">term</span>(<span class="pl-s1">i</span>)), <span class="pl-en">add</span>(<span class="pl-s1">i</span> <span class="pl-c1">+</span> <span class="pl-c1">1</span>)
    <span class="pl-k">return</span> <span class="pl-s1">count</span></pre></div>
<p>🐻 <code class="notranslate">summation_using_accumulate: product的变体</code></p>
<div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-k">def</span> <span class="pl-en">summation_using_accumulate</span>(<span class="pl-s1">n</span>, <span class="pl-s1">term</span>):
    <span class="pl-k">return</span> <span class="pl-en">accumulate</span>(<span class="pl-s1">add</span>, <span class="pl-en">term</span>(<span class="pl-c1">0</span>), <span class="pl-s1">n</span>, <span class="pl-s1">term</span>)</pre></div>
<p>🐻 <code class="notranslate">sproduct_using_accumulate: product的变体</code></p>
<div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-k">def</span> <span class="pl-en">product_using_accumulate</span>(<span class="pl-s1">n</span>, <span class="pl-s1">term</span>):
 	<span class="pl-k">return</span> <span class="pl-en">accumulate</span>(<span class="pl-s1">mul</span>, <span class="pl-c1">1</span>, <span class="pl-s1">n</span>, <span class="pl-s1">term</span>)</pre></div>
<h3>Q3: Make Repeater</h3>
<p>Implement the function <code class="notranslate">make_repeater</code> which takes a one-argument function <code class="notranslate">f</code> and a positive integer <code class="notranslate">n</code>. It returns a one-argument function, where <code class="notranslate">make_repeater(f, n)(x)</code> returns the value of <code class="notranslate">f(f(...f(x)...))</code> in which <code class="notranslate">f</code> is applied <code class="notranslate">n</code> times to <code class="notranslate">x</code>. For example, <code class="notranslate">make_repeater(square, 3)(5)</code> squares 5 three times and returns 390625, just like <code class="notranslate">square(square(square(5)))</code>.</p>
<pre class="notranslate"><code class="notranslate">def make_repeater(f, n):
    """Returns the function that computes the nth application of f.

    &gt;&gt;&gt; add_three = make_repeater(increment, 3)
    &gt;&gt;&gt; add_three(5)
    8
    &gt;&gt;&gt; make_repeater(triple, 5)(1) # 3 * (3 * (3 * (3 * (3 * 1))))
    243
    &gt;&gt;&gt; make_repeater(square, 2)(5) # square(square(5))
    625
    &gt;&gt;&gt; make_repeater(square, 3)(5) # square(square(square(5)))
    390625
    """
    "*** YOUR CODE HERE ***"


</code></pre>
<p>Use Ok to test your code:</p>
<pre class="notranslate"><code class="notranslate">python3 ok -q make_repeater

</code></pre>
<p>🐻</p>
<div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-k">def</span> <span class="pl-en">make_repeater</span>(<span class="pl-s1">f</span>, <span class="pl-s1">n</span>):
    <span class="pl-k">def</span> <span class="pl-en">helper</span>(<span class="pl-s1">x</span>):
        <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-s1">n</span>;
        <span class="pl-k">while</span> <span class="pl-s1">i</span>:
            <span class="pl-s1">x</span> <span class="pl-c1">=</span> <span class="pl-en">f</span>(<span class="pl-s1">x</span>)
            <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-s1">i</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>;
        <span class="pl-k">return</span> <span class="pl-s1">x</span>
    <span class="pl-k">return</span> <span class="pl-s1">helper</span></pre></div>
<h2>Recursion</h2>
<h3>Q4: Digit Distance</h3>
<p>For a given integer, the <em>digit distance</em> is the sum of the absolute differences between consecutive digits. For example:</p>
<ul>
<li>The digit distance of <code class="notranslate">6</code> is <code class="notranslate">0</code>.</li>
<li>The digit distance of <code class="notranslate">61</code> is <code class="notranslate">5</code>, as the absolute value of <code class="notranslate">6 - 1</code> is <code class="notranslate">5</code>.</li>
<li>The digit distance of <code class="notranslate">71253</code> is <code class="notranslate">12</code> (<code class="notranslate">6 + 1 + 3 + 2</code>).</li>
</ul>
<p>Write a function that determines the digit distance of a given positive integer. You must use recursion or the tests will fail.</p>
<p><strong>Hint:</strong> There are multiple valid ways of solving this problem! If you're stuck, try writing out an iterative solution first, and then convert your iterative solution into a recursive one.</p>
<pre class="notranslate"><code class="notranslate">def digit_distance(n):
    """Determines the digit distance of n.

    &gt;&gt;&gt; digit_distance(3)
    0
    &gt;&gt;&gt; digit_distance(777)
    0
    &gt;&gt;&gt; digit_distance(314)
    5
    &gt;&gt;&gt; digit_distance(31415926535)
    32
    &gt;&gt;&gt; digit_distance(3464660003)
    16
    &gt;&gt;&gt; from construct_check import check
    &gt;&gt;&gt; # ban all loops
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'digit_distance',
    ...       ['For', 'While'])
    True
    """
    "*** YOUR CODE HERE ***"


</code></pre>
<p>Use Ok to test your code:</p>
<pre class="notranslate"><code class="notranslate">python3 ok -q digit_distance

</code></pre>
<p>🐻</p>
<div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-k">def</span> <span class="pl-en">digit_distance</span>(<span class="pl-s1">n</span>):
    <span class="pl-k">if</span> <span class="pl-s1">n</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">10</span>:
        <span class="pl-k">return</span> <span class="pl-c1">0</span>
    <span class="pl-k">else</span>:
        <span class="pl-k">return</span> <span class="pl-en">abs</span>(<span class="pl-en">sub</span>(<span class="pl-s1">n</span> <span class="pl-c1">%</span> <span class="pl-c1">10</span>, <span class="pl-s1">n</span> <span class="pl-c1">//</span> <span class="pl-c1">10</span> <span class="pl-c1">%</span> <span class="pl-c1">10</span>)) <span class="pl-c1">+</span> <span class="pl-en">digit_distance</span>(<span class="pl-s1">n</span> <span class="pl-c1">//</span> <span class="pl-c1">10</span>)</pre></div>
<h3>Q5: Interleaved Sum</h3>
<p>Write a function <code class="notranslate">interleaved_sum</code>, which takes in a number <code class="notranslate">n</code> and two one-argument functions: <code class="notranslate">odd_func</code> and <code class="notranslate">even_func</code>. It applies <code class="notranslate">odd_func</code> to every odd number and <code class="notranslate">even_func</code> to every even number from 1 to <code class="notranslate">n</code> <em>inclusive</em> and returns the sum.</p>
<p>For example, executing <code class="notranslate">interleaved_sum(5, lambda x: x, lambda x: x * x)</code> returns <code class="notranslate">1 + 2*2 + 3 + 4*4 + 5 = 29</code>.</p>
<p><strong>Important:</strong> Implement this function without using any loops or directly testing if a number is odd or even -- aka modulos (<code class="notranslate">%</code>) are not allowed! Instead of directly checking whether a number is even or odd, start with 1, which you know is an odd number.</p>
<p><strong>Hint:</strong> Introduce an inner helper function that takes an odd number <code class="notranslate">k</code> and computes an interleaved sum from <code class="notranslate">k</code> to <code class="notranslate">n</code> (including <code class="notranslate">n</code>).</p>
<pre class="notranslate"><code class="notranslate">def interleaved_sum(n, odd_func, even_func):
    """Compute the sum odd_func(1) + even_func(2) + odd_func(3) + ..., up
    to n.

    &gt;&gt;&gt; identity = lambda x: x
    &gt;&gt;&gt; square = lambda x: x * x
    &gt;&gt;&gt; triple = lambda x: x * 3
    &gt;&gt;&gt; interleaved_sum(5, identity, square) # 1   + 2*2 + 3   + 4*4 + 5
    29
    &gt;&gt;&gt; interleaved_sum(5, square, identity) # 1*1 + 2   + 3*3 + 4   + 5*5
    41
    &gt;&gt;&gt; interleaved_sum(4, triple, square)   # 1*3 + 2*2 + 3*3 + 4*4
    32
    &gt;&gt;&gt; interleaved_sum(4, square, triple)   # 1*1 + 2*3 + 3*3 + 4*3
    28
    &gt;&gt;&gt; from construct_check import check
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'interleaved_sum', ['While', 'For', 'Mod']) # ban loops and %
    True
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'interleaved_sum', ['BitAnd', 'BitOr', 'BitXor']) # ban bitwise operators, don't worry about these if you don't know what they are
    True
    """
    "*** YOUR CODE HERE ***"


</code></pre>
<p>Use Ok to test your code:</p>
<pre class="notranslate"><code class="notranslate">python3 ok -q interleaved_sum

</code></pre>
<p>🐻<code class="notranslate">interleaved_sum</code></p>
<div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-k">def</span> <span class="pl-en">interleaved_sum</span>(<span class="pl-s1">n</span>, <span class="pl-s1">odd_func</span>, <span class="pl-s1">even_func</span>):
    <span class="pl-k">if</span> <span class="pl-s1">n</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span>:
        <span class="pl-k">return</span> <span class="pl-c1">0</span>
    <span class="pl-k">elif</span> <span class="pl-s1">n</span> <span class="pl-c1">%</span> <span class="pl-c1">2</span> <span class="pl-c1">==</span> <span class="pl-c1">1</span>:
        <span class="pl-k">return</span> <span class="pl-en">odd_func</span>(<span class="pl-s1">n</span>) <span class="pl-c1">+</span> <span class="pl-en">interleaved_sum</span>(<span class="pl-s1">n</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>, <span class="pl-s1">odd_func</span>, <span class="pl-s1">even_func</span>)
    <span class="pl-k">else</span>:
        <span class="pl-k">return</span> <span class="pl-en">even_func</span>(<span class="pl-s1">n</span>) <span class="pl-c1">+</span> <span class="pl-en">interleaved_sum</span>(<span class="pl-s1">n</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>, <span class="pl-s1">odd_func</span>, <span class="pl-s1">even_func</span>)</pre></div>
<h3>Q6: Count Coins</h3>
<p>Given a positive integer <code class="notranslate">total</code>, a set of coins makes change for <code class="notranslate">total</code> if the sum of the values of the coins is <code class="notranslate">total</code>. Here we will use standard US Coin values: 1, 5, 10, 25. For example, the following sets make change for <code class="notranslate">15</code>:</p>
<ul>
<li>15 1-cent coins</li>
<li>10 1-cent, 1 5-cent coins</li>
<li>5 1-cent, 2 5-cent coins</li>
<li>5 1-cent, 1 10-cent coins</li>
<li>3 5-cent coins</li>
<li>1 5-cent, 1 10-cent coin</li>
</ul>
<p>Thus, there are 6 ways to make change for <code class="notranslate">15</code>. Write a <strong>recursive</strong> function <code class="notranslate">count_coins</code> that takes a positive integer <code class="notranslate">total</code> and returns the number of ways to make change for <code class="notranslate">total</code> using coins.</p>
<p>You can use <em>either</em> of the functions given to you:</p>
<ul>
<li><code class="notranslate">next_larger_coin</code> will return the next larger coin denomination from the input, i.e. <code class="notranslate">next_larger_coin(5)</code> is <code class="notranslate">10</code>.</li>
<li><code class="notranslate">next_smaller_coin</code> will return the next smaller coin denomination from the input, i.e. <code class="notranslate">next_smaller_coin(5)</code> is <code class="notranslate">1</code>.</li>
<li>Either function will return <code class="notranslate">None</code> if the next coin value does not exist</li>
</ul>
<p>There are two main ways in which you can approach this problem. One way uses <code class="notranslate">next_larger_coin</code>, and another uses <code class="notranslate">next_smaller_coin</code>. It is up to you which one you want to use!</p>
<p><strong>Important:</strong> Use recursion; the tests will fail if you use loops.</p>
<p><strong>Hint:</strong> Refer to the <a href="https://www.composingprograms.com/pages/17-recursive-functions.html#example-partitions" rel="nofollow">implementation</a> of <code class="notranslate">count_partitions</code> for an example of how to count the ways to sum up to a final value with smaller parts. If you need to keep track of more than one value across recursive calls, consider writing a helper function.</p>
<pre class="notranslate"><code class="notranslate">def next_larger_coin(coin):
    """Returns the next larger coin in order.
    &gt;&gt;&gt; next_larger_coin(1)
    5
    &gt;&gt;&gt; next_larger_coin(5)
    10
    &gt;&gt;&gt; next_larger_coin(10)
    25
    &gt;&gt;&gt; next_larger_coin(2) # Other values return None
    """
    if coin == 1:
        return 5
    elif coin == 5:
        return 10
    elif coin == 10:
        return 25

def next_smaller_coin(coin):
    """Returns the next smaller coin in order.
    &gt;&gt;&gt; next_smaller_coin(25)
    10
    &gt;&gt;&gt; next_smaller_coin(10)
    5
    &gt;&gt;&gt; next_smaller_coin(5)
    1
    &gt;&gt;&gt; next_smaller_coin(2) # Other values return None
    """
    if coin == 25:
        return 10
    elif coin == 10:
        return 5
    elif coin == 5:
        return 1

def count_coins(total):
    """Return the number of ways to make change using coins of value of 1, 5, 10, 25.
    &gt;&gt;&gt; count_coins(15)
    6
    &gt;&gt;&gt; count_coins(10)
    4
    &gt;&gt;&gt; count_coins(20)
    9
    &gt;&gt;&gt; count_coins(100) # How many ways to make change for a dollar?
    242
    &gt;&gt;&gt; count_coins(200)
    1463
    &gt;&gt;&gt; from construct_check import check
    &gt;&gt;&gt; # ban iteration
    &gt;&gt;&gt; check(HW_SOURCE_FILE, 'count_coins', ['While', 'For'])
    True
    """
    "*** YOUR CODE HERE ***"


</code></pre>
<pre class="notranslate"><code class="notranslate">python3 ok -q count_coins
</code></pre>
<p>🐻</p>
<div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-c"># 边界情况： 硬币为0，方案正确。 硬币为负， 方案失败。</span>
<span class="pl-c"># 有四种硬币 25、10、5、1 </span>
<span class="pl-c"># 总硬币数： total</span>
<span class="pl-c"># 每次使用硬币有四种情况 total - 25, total - 10, total - 5, total - 1</span>
<span class="pl-c"># total： 10 -&gt;</span>
<span class="pl-c"># 10</span>
<span class="pl-c"># 5 5</span>
<span class="pl-c"># 5 1 1 1 1 1 </span>
<span class="pl-c"># 1 1 1 1 1 1 1 1 1 1 </span>
<span class="pl-c"># 观察可发现， 按照25-10-5-1这样递减。</span>
<span class="pl-k">def</span> <span class="pl-en">count_coins</span>(<span class="pl-s1">total</span>):                                            
    <span class="pl-k">def</span> <span class="pl-en">helper</span>(<span class="pl-s1">total</span>, <span class="pl-s1">coin</span>):
        <span class="pl-k">if</span> <span class="pl-s1">total</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span>:
            <span class="pl-k">return</span> <span class="pl-c1">1</span>
        <span class="pl-k">if</span> <span class="pl-s1">total</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">0</span> <span class="pl-c1">or</span> <span class="pl-c1">not</span> <span class="pl-s1">coin</span> :
            <span class="pl-k">return</span> <span class="pl-c1">0</span>
        <span class="pl-k">return</span> <span class="pl-en">helper</span>(<span class="pl-s1">total</span> <span class="pl-c1">-</span> <span class="pl-s1">coin</span>,<span class="pl-s1">coin</span>) <span class="pl-c1">+</span> <span class="pl-en">helper</span>(<span class="pl-s1">total</span>, <span class="pl-en">next_smaller_coin</span>(<span class="pl-s1">coin</span>))
    <span class="pl-k">return</span> <span class="pl-en">helper</span>(<span class="pl-s1">total</span>, <span class="pl-c1">25</span>)</pre></div></div>
<div style="font-size:small;margin-top:8px;float:right;">转载请注明出处</div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer">Copyright © <span id="year"></span><a href="https://LianSeKong.github.io/lizi"> Lizi </a>
<p>
<span id="runday"></span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a>
</p>

<script>
if(""!=""){
    var now=new Date();
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("year").innerHTML=now.getFullYear();
    if(""!=""){document.getElementById("runday").innerHTML=" • "+"网站运行"+diffDay+"天"+" • ";}
    else{document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";}
}
</script>
</div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n\n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","LianSeKong/lizi");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}
</script>


</html>
